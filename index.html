 
 

<!-- PAPERMAKER 3 free license -->

  <!-- VERSION : 3+ -->

<!-- list  -->
<!-- config,
updateViewport,
moveTilesRandomly,
buildBlock,
loop-->


<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<script>
// test removed in this version buildBlocksAroundPosition newtilemap
/* edit it for your game preferences */

          var gmgravity = 0
          var resetMusicifdeath = 1
          var disableDEBUGPAUSE=0
          

</script>
<style>
  html{
    filter: brightness(0);
  }
</style>
<!-- put your water mark -->
<div class="Ylyl" style="position: fixed; left:0; bottom:0px; background: #333 ; z-index: 9; width:30px;height:30px" onclick="saveToFile()">S</div>
<div class="Ylyl" style="position: fixed; left:30px; bottom:0px; background: #333; z-index: 9; width:30px;height:30px" onclick="loadfile()">L</div>
<img src="./watermark.gif" id="pastemark" onclick="config.testmode = config.testmode === 1 ? 0 : 1;up1();playUpdateSound2()"style="position: fixed; top:5px; left:10px;  width:100px;height:30px; transform: translate(0,25%); z-index: 99999999999" >
<style>
  @font-face {
  font-family: font;
  src: url('./font.ttf');
}
body{
  font-family: font;
}
</style>


<style>
  gui{
    margin-left: 50px
  }
</style>
<script>
var editor="right"
var config ={  "HpBarConfiguration": {
      "texture": "./cross.png",
      "textureempty": "./grass.png",
      "numberHP": 0,
      "maxHp": 0,
      "top": "10",
      "left": "50",
      "bottom": "",
      "right": "",
      "hurtDelay": 2000, 
      "Work": true,
    },"folder":{"texture":{"player":[],"projectile":[0,0]},"textures":{},"sounds":{"player":[],"ambients":[]},"script":{},"config":{}},"v":1,"playershoots":1,
  "guiHTML2":"","gravitypower":0.1,"chrom":false,"engine":" DogLog beta 1.5.1","info":" experimental game editor some bugs but a lot\n  of stuffs :) \n  \n  ","width":400,"height":300,"asemblyinstructions":"","requests":0,"bgsize":0,"cameraX":201,"cameraY":200,"customcamera":1,"debugmode":0,"px":6.628533333333328,"py":6.690066666666651,"tilesize":30,"linesperframe":1,"entities":{"alltiles3":[8,"follow",10,3,0,199,[0,0,999999,999999],true,[[10,0],[-10,0]],null,1,1,,null,1],"alltiles5":[1,"null",4,3,0,0,[0,0,999999,999999],true,[[10,0],[-10,0]],0,1,1],"alltiles2":[2,"move",4,3,0,1,[0,0,999999,999999],true,[[5,0],[-5,0]]],"alltiles6":[2,"move",4,3,0,100,[0,0,999999,999999],true,[[0,3],[0,-3]],1,0]},"Hz":0,
  "code":"1: l hp 10\n2:\n3: \n4: \n5: col player alltiles8 14\n6: l zero 0\n7: and hp zero +5\n8: col player alltiles99 +2\n9: jmp -5\n10: sub hp 1\n11: jmp -4\n12: ppos 202 180 0\n13: jmp 5\n14: movem 20 0 1 \n15: eval collect()\n16: jmp 1","zoomoff":0.2,"zoomadd":1,"customGUI":1,
  "EMULATOR":0.1,"guiHTML":"  <div class=\"btns\">\n      <div class=\"null added\"></div>\n      <div class=\"btn added\" id=\"Up\"></div>\n      <div class=\"null added\"></div>\n      <div class=\"btn added\" id=\"Left\"></div>\n      <div class=\"null added\"></div>\n      <div class=\"btn added\" id=\"Right\"></div>\n      <div class=\"null added\"></div>\n      <div class=\"btn added\" id=\"Down\"></div>\n      <div class=\"null added\"></div>\n  \n    </div>\n\n \t   \t  <div class=\"jumpbtn added\" id=\"Attack\" style=\"transform: translate(0%, -100%); right: 1px;\" onclick=\"attack2()\"></div>\n<div id=\"Start\" class=\" przesuwalny added\" style=\"width: 250px; height: 250px; background: rgb(80, 80, 200); display: none;\"></div><div id=\"Start\" class=\" przesuwalny added\" style=\"z-index: 217; width: 450px; height: 250px; background: rgb(80, 80, 200); display: none;\"></div>","longjump":28,"jumpingpower":0.09,"speed":2,
  "backspeed":1.3,"norspeed":2,"spawnX":200,"spawnY":200,"testmode":0,"collisions":0,"loadgamefile":0,"sidescroll":1,"ts":10,"gravity":0,"noasm":0,"bg":"/grass","playersize":0,"music":"/.wav","blocks":[[0,1,"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIHWNgqPj/HwAEagJ3t6MPBQAAAABJRU5ErkJggg==",1,0],[1,1,"/ NAN.png"],[2,0,"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIHWP4z5D2HwAFzAJlXbviVwAAAABJRU5ErkJggg==",1,0],[3,1,"/ NAN.png"],[4,1,"/ NAN.png"]],"savedTileMap":
  [[],[],[]],"playerskin1":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIHWPgYfj/HwADMgIL4wnJsQAAAABJRU5ErkJggg=="}
</script>
<script src="./defaul.js"></script>
<script src="./bigexample.js"></script>
<script>
            if (!('defps' in config)) {
            config['defps'] = 15;
          }
          var defaultFps = config.defps;
          var targetFPS = config.defps;
</script>
<script src="//cdn.jsdelivr.net/npm/eruda"></script>
<script>eruda.init();</script> 
<!-- HEY PUT HERE YOUR PROJECt Path -->
<!-- ---------+----+----+----------- -->
<!-- ---------+----+----+----------- -->
<script src="./ your path"></script>
<!-- ---------+----+----+----------- -->
<!-- ---------+----+----+----------- -->
        <script>
          let path = 'newproject';
        </script>
        <e_gameinfoinput>
          Game Info 
        </e_gameinfoinput>
<script>
  if (document.querySelector('e_gameinfoinput')) {
  document.querySelector('e_gameinfoinput').style.display = "none"
}
</script>
<script>
function toggle(value) {
    return value === 0 ? 1 : 0;
}


  const textsArray = [
`
<div style=' color: rgb(100,250,240);  height:90vh; width:90vw'> 
just a pme 3.5+ full  </div>
`,`
<div style=' color: rgb(100,250,240);  height:90vh; width:90vw'>
  v1.3.5.1E
  </div>
`];

</script>
    <script>
        function hd() {
  up1();
  config.testmode = 1;
  var elementsToHide = document.getElementsByClassName('notaproject');
  Array.from(elementsToHide).forEach(element => {
    element.style.display = "none";
  });
}
        function hideProjectPath() {
            setTimeout(() => {
                document.querySelector('project-path').style.display = "none";
            }, 1000);
        }
        function setupNewProject() {
            document.getElementById('viewport').style.resize = "both";
            document.getElementById('viewport').style.border = "1px solid gray";
            let container3 = document.getElementById("viewport");
            container3.addEventListener("touchstart", touchStart);
            container3.addEventListener("touchmove", touchMove);
            container3.addEventListener("touchend", touchEnd);
            container3.addEventListener("mouseenter", onMouseEnter);
            container3.addEventListener("mouseleave", onMouseLeave);
            container3.addEventListener("wheel", onWheel);
        }
        document.addEventListener('DOMContentLoaded', () => {
            if (document.querySelector('_gameinfoinput_')) {
  document.querySelector('_gameinfoinput_').style.display = "none"
}
setTimeout(function() {
  if (path !== "newproject") {
    document.querySelector('#pastemark').style.display = "none";
    document.querySelector('#resizableHandle').style.display = "none";
    setTimeout(() => config.testmode = 1, 6000);
    setTimeout(() => {
      config.testmode = 1;
      gravity = tdt.gravity;
      dimension=config.dimension
      updateViewport()
    }, 100);
    requestAnimationFrame(hd);
    let contentd=config
    handleFileContent(contentd)
    requestAnimationFrame(hd);
    togglemode1();
  } else {
    setupNewProject();
  }
}, 3000)
        });
    </script>
</head>
<body>
</body>
</html>
<script>
  let finishproject=1
  function playUpdateSound() {
  var audio = new Audio('./Update.mp3');
  audio.play();
}
function playUpdateSound2() {
  var audio = new Audio('./bopbup.mp3');
  audio.play();
}
function playUpdateSound3() {
  var audio = new Audio('./click.mp3');
  audio.play();
}
</script>
<script>
  function loadtestgame(){
  var gccpath='./robotgame-ex'
setTimeout(function (){
  fetch(gccpath)
    .then(response => response.text())
    .then(data => handleFileContent(data))
    .catch(error => {
    }
    );
},1000)
 }
  setTimeout(function(){
    let d =document.querySelectorAll('button')
    d.forEach(el =>{
      el.addEventListener('touchstart', function() {
      playUpdateSound3()
    })
    })
  },3000)
</script>
<script>
  var shader={
    "DarknessEffect":1,
    "Sepia":0,
    "Noises":0,
  }
  setTimeout(function(){
    if (!(config.guiHTML2)) {
      config.guiHTML2 = ""
    }
if(config.DarknessEffect==1){
  let vp =document.getElementById("viewport")
  let el= document.createElement('div')
  el.style=`width:${vp.style.width};height:${vp.style.height};`
  el.className='dark effects added'
  document.querySelector('#project').appendChild(el)
}else{
let y = document.querySelectorAll('.effects')
for (var i = 0; i < y.length; i++) {
 if(y[i].classList=='dark'){
  y[i].remove()
 }
}
}
  },1000)
</script>
<style>
  .dark{
    background: radial-gradient(#FF000000,#000000 45%);
    top:50vh;
    position: fixed;
    left:50vw;
    transform: translate(-50%,-50%);
    z-index: 0;
  }
</style>
<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta http-equiv="X-UA-Compatible" content="IE=7">
<audio id="audio2"src="/path"></audio>
<p id="mbs" style="position: absolute;z-index: 999; color:lime; display: none"></p>


 <style>
 :root{
   position:fixed;
  width: 100vw;
  height:100vh;
 }
*::-webkit-scrollbar {
  display: none;
}
*::-webkit-scrollbar-thumb {
  background-color: transparent;
}
 </style>
<script>let isgamepaused = 0;
let mbs=document.querySelector("#mbs")
window.addEventListener('load', function () {
    var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
    var speed = connection.downlink; 
mbs.innerHTML = speed+'mb/s'
    if (speed && speed < 2) {
        mbs.innerHTML = '<h1>.</h1>';
    }
});
</script>

<script>
  var sizescale=config.tilesize;
</script>
  <style>
.b{
}
    #blackScreen {
      display: none;
      position: fixed;
      order: 99;
      z-index:999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: black;
     display: flex;
     transform: translateZ(9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999);
      align-items: center;
      justify-content: center;
      color: white;
      opacity: 1;
      transition: opacity 2s ease-in-out;
    }
.hide3{
  display: none;
  visibility: hidden;
  touch-action: none;
}
    #helloWorldText {
      display: block;
      position: absolute;
      top:50vh;
      z-index: 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999;
      left:50vw;
      transform: translate(-50%,-50%);
      opacity: 1;
      transition: opacity 0.25s ease-in-out;
    }
  </style>
  </head>
  <body>
<script>


var tileMap =
[[[9, 0, 1]],[],[]]
let update3=()=>{ document.querySelector('#player').style.background=`url("${config.playerskin1}");`;config.playerskin1=playerskin;config.bg=bgimg;config.blocks=TILES;config.px=(playerX)/tileSize;config.py=playerY/tileSize; /*console.log(config)*/ }

setTimeout(function(){

  playerskin=config.playerskin1

var contentElement = document.getElementById("content");
contentElement.style.backgroundImage = `url('${config.bg}')`;
TILES=config.blocks
tileMap=config.savedTileMap
checki1()
var playerelement = document.getElementById("player");
playerelement.style.backgroundImage = `url('${config.playerskin1}')`;

  updateViewport();

  window.setInterval(update3,5000)
},100)
setTimeout(function (){
  document.querySelector('.player').style.background = `url(${config.playerskin1});`;
  playerskin = config.playerskin1
},1600)
setTimeout(function(){
document.getElementById('project').style.zoom="1.0"

},500)
</script>
  <button class="notaproject d hide" style="position: absolute; left:30vw; bottom:0px; background: blue; z-index: 99999999999999999999999999999999999999999999" onclick="saveToFile()">Save Project File</button>
<button class="notaproject d hide" style="position: absolute; left:50vw; bottom:0px; background: blue; z-index: 99999999999999999999999999999999999999999999999999" onclick="chooseFile()">Project Loop main Music</button>
<script>
let toonce = 1;
let audioInstance = null;
function handleClick() {
    if (toonce === 1) {
        if (audioInstance) {

            audioInstance.pause();
            audioInstance.currentTime = 0;
            audioInstance = null;
        }
        if (config.music !== '') {
            const base64Wav = config.music;

            audioInstance = new Audio();
            audioInstance.src = base64Wav;
            audioInstance.setAttribute('preload', 'auto');

            document.body.appendChild(audioInstance);

            audioInstance.play();
            audioInstance.loop = true;
            toonce = 0;
        }
    }
}
document.querySelector('html').addEventListener('click', handleClick);
function chooseFile() {
    const input = document.createElement('input');
    input.type = 'file';

    input.addEventListener('change', function() {
        const file = input.files[0];
        toonce = 1;
        if (file) {

            const reader = new FileReader();
            reader.onload = function(e) {
                const base64Wav = e.target.result;

                if (audioInstance) {
                    audioInstance.pause();
                    audioInstance.currentTime = 0;
                    audioInstance = null;
                }

                config.music = base64Wav;

                audioInstance = new Audio();
                audioInstance.src = base64Wav;
                audioInstance.setAttribute('preload', 'auto');

                document.body.appendChild(audioInstance);

            };
            reader.readAsDataURL(file);
        }
    });

    input.click();
}
</script>
<div>
</div>
<script>

</script>
  <script>
  var isonfloor=0
  var cantsavebugfix=1
    function saveToFile() {
      if(isonfloor==1||cantsavebugfix==0){
config.blocks.push([TILES.length+(config.sprites).length,1,"/ NAN.png"])
config.code = code;
config.debugmode=0
config.testmode=0
let code2=JSON.stringify(config)

      let blob = new Blob([code2], { type: "text/plain" });

      let a = document.createElement("a");

 a.href = window.URL.createObjectURL(blob);

      a.download = "defaul.js";


      a.click();
    }}
function saveToFileasJs() {
  config.blocks.push([TILES.length+(config.sprites).length, 1, "/ NAN.png"])
  config.code = code;
  config.debugmode = 0
  config.testmode = 0
  let code2 = "config ="+JSON.stringify(config)

  let blob = new Blob([code2], { type: "text/plain" });

  let a = document.createElement("a");

  a.href = window.URL.createObjectURL(blob);

  a.download = "defaul.js";

  a.click();
}
  </script>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    body {
      margin: 0;
      background: #000000;
      padding: 0;
      font-family: Arial, sans-serif;
    }
    #container {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      width: 70%;
      height: 70%;
      border: 1px solid #ccc;
      overflow: hidden;
    }
    #toolbar {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background-color: #f1f1f1;
      padding: 10px;
      overflow-x: scroll;
    }
    .tool {
      display: inline-block;
      margin-right: 20px;
    }
    .menu-btn, .options-btn {
      cursor: pointer;
      margin-right: 10px;
    }
    .selected {
      background-color: lightblue;
    }
    .hidden {
      display: none;
    }
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: none;
    }
    .popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #fff;
      padding: 20px;
      z-index: 2;
    }
    #sidebar {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      width: 10%;
      background-color: #ddd;
      overflow-y: scroll;
      padding: 10px;
    }
    .tab {
      margin-bottom: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
    }
    .tab:hover {
      background-color: #eee;
    }
    .tab img {
      margin-right: 5px;
    }
    .content {
      margin-left: 10%;
    }
        .Econtent {
          touch-action: none;
          position: absolute;
          margin-left: 10%;
        }
        .Dcontent {
          touch-action: none;
          position: absolute;
          margin-left: 10%;
        }
                .Scontent {
                  touch-action: none;
                  position: absolute;
                  margin-left: 10%;
                }

#info{
  position: fixed;
  right:0;
  top:calc(80% - 20px);
}
    .nested-div {
      margin-left: 20px;
      cursor: pointer;
    }
    .dr{
      width:50px;
      height:50px;
    }
  </style>
</head>
<body>

</div>
<style>
  #resizableDiv {
    width: 300px;
    height: 200px;
    border: 1px solid black;
    overflow: auto;
    text-align: center;
    cursor: pointer;
    position: relative;
  }
  #resizableHandle {
    width: 50px;
    height: 50px;
    background-color: #5B25257D;
    color:#A886867D;
    position: absolute;
    z-index: 9999;
    bottom:0;
    right:0;
    cursor: nwse-resize;

  }
  #dimensions {
    text-align: center;
    margin-top: 10px;
  }
  #vpfilter{
    z-index: 50;
   width:999999999999999999999999pc; 
   height:99999999999999999999999pc;
   height: 100%;
    touch-action: none;
    pointer-events: none;
overflow: hidden auto;
position: absolute ;
  }
</style>
</head>
<body>
<div id="project">
  <div id="content2">
  </div>
  <div id="alaviewport">
<div id="resizableHandle" class="">drag to resize renderer</div>

</div>

  <div id="viewport"  >

    <div id="viewport2">
      

  <div id="player" class="player">
  </div>
  <div id="playerskin"></div>
  <div id="content"></div>
  
    <div id="Econtent" ></div>
    <div id="Scontent" ></div>
    <div id="Tcontent" ></div>
<div id="Dcontent" ></div>
</div></div></div>
  <div id="project2">
  </div>
   <div class="playPauseButton" id="playPauseButton" onclick="togglePlayPause()">
     <span id="icon">⏸️</span>
   </div>
   <div class="playPauseButton" id="playPauseButton2" style="right:40px" onclick="restart()">
     <span id="icon">🔁</span>
   </div>


<style>body {
            margin: 0;
            padding: 0;
            
            height: 100vh;
            background-color: #f0f0f0;
            overflow: hidden;
        }

     /*   #viewport2 {
            position: absolute;
            background-color: #4a90e2;
            color: white;
            font-size: 20px;
            width:200px;height: 200px;
           
            transform: perspective(2px) rotateX(3deg) translateY(-50px) ;
            
            animation: wave 5s infinite;
        }*/
/*
        #viewport {
            width: 200px;
            height: 200px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #42445A;
            overflow: hidden;
            
        }*/



        @keyframes wave {
            0% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(10px);
            }
            100% {
                transform: translateY(0px);
            }
        }

    /*    #viewport2::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            pointer-events: none;
            animation: blurWave 5s infinite;
        }*/

        @keyframes blurWave {
            0% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(5px);
            }
            100% {
                transform: translateY(0px);
            }
        }</style>

<script>

if(disableDEBUGPAUSE==1){
  document.getElementById('playPauseButton').style.display="none"
}
  document.querySelector('#viewport').style.width = config.width + "px"
  document.querySelector('#viewport').style.height = config.height + "px"
  document.querySelector('#content2').style.width = config.width + "px"
  document.querySelector('#content2').style.height = config.height + "px"
</script>
	<div class="joystick">	  <div class="stick"></div>
  </div>
 	  <div class="jumpbtn added" id="Jump" ></div>
 	   	  <div class="jumpbtn added" id="Attack" style="transform: translate(0%,-100%)" onclick="attack2()"></div>
</div>
<script>
  var container3 = document.getElementById("viewport");
  var initialTouchDistance = 0;
  var initialZoom = 1;
  function touchStart(event) {
    if (event.touches.length === 2) {
      initialTouchDistance = Math.hypot(event.touches[0].pageX - event.touches[1].pageX, event.touches[0].pageY - event.touches[1].pageY);
      initialZoom = parseFloat(window.getComputedStyle(container3).zoom);
    }
  }
  function touchMove(event) {
    if (event.touches.length === 2) {
      var currentTouchDistance = Math.hypot(event.touches[0].pageX - event.touches[1].pageX, event.touches[0].pageY - event.touches[1].pageY);
      var scaleFactor = currentTouchDistance / initialTouchDistance;
      container3.style.zoom = initialZoom * scaleFactor * 0.5;
      if (!('zoom' in config)) {

  config['zoom'] = 0;
}
config.zoom=initialZoom * scaleFactor * 0.5;

    }
  }
  function touchEnd(event) {
    initialTouchDistance = 0;
  }
  function onWheel(event) {
    event.preventDefault(); 
    var delta = Math.sign(event.deltaY);
    var currentZoom = parseFloat(window.getComputedStyle(container).zoom);
    container3.style.zoom = currentZoom + (delta * 0.1);
  }
  function onMouseEnter() {
    //container3.style.border = "2px solid red"; 
  }
  function onMouseLeave() {
    container3.style.border = "1px solid black"; 
  }
</script>
<script>
  const resizableDiv = document.getElementById('viewport');
  const resizableHandle = document.getElementById('resizableHandle');

  let isResizing = false;
  let startX;
  let startY;
  let startWidth;
  let startHeight;
  resizableHandle.addEventListener('mousedown', startResize);
  resizableHandle.addEventListener('touchstart', startResizeTouch, { passive: false });
  document.addEventListener('mouseup', stopResize);
  document.addEventListener('touchend', stopResize);
  document.addEventListener('mousemove', resize);
  document.addEventListener('touchmove', resize);
  function startResize(e) {
    e.preventDefault(); 
    isResizing = true;
    startX = e.clientX;
    startY = e.clientY;
    startWidth = resizableDiv.offsetWidth;
    startHeight = resizableDiv.offsetHeight;
  }
  function startResizeTouch(e) {
    e.preventDefault(); 
    const touch = e.touches[0];
    isResizing = true;
    startX = touch.clientX;
    startY = touch.clientY;
    startWidth = resizableDiv.offsetWidth;
    startHeight = resizableDiv.offsetHeight;
  }
  function stopResize() {
    isResizing = false;
  }
  function resize(e) {
    if (isResizing) {
      let clientX, clientY;
      if (e.type === 'touchmove') {
        const touch = e.touches[0];
        clientX = touch.clientX;
        clientY = touch.clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }
      const newWidth = startWidth + (clientX - startX);
      const newHeight = startHeight + (clientY - startY);
      resizableDiv.style.width = `${newWidth}px`;
      viewportWidth=newWidth
      viewportHeight=newHeight
      config.width=newWidth
      config.height=newHeight
      resizableDiv.style.height = `${newHeight}px`;

    }
  }
</script>
<style>
  #project{
    position: absolute;
    background: #000000;
    width: 100%;
    height: 100vh;
  }
  #project2 {
    position: absolute;
    background: #00000000;
        pointer-events: none ;
    width: 100%;
    height: 100vh;
  }
</style>
<html onclick="setTimeout(function(){document.documentElement.requestFullscreen()},200)">
  <audio id="audio" src=""></audio>

<title></title>

<style>
.f{
}
@keyframes rainbow {
  0% { color: #FF7C7C; }
  16% { color: #FFE47E; }
  33% { color: #89FF7E; }
  50% { color: #7BF1FC; }
  66% { color: #C3B2FF; }
  83% { color: #D89FCC; }
  100% { color: #FBBED3; }
}
  .f div{
    margin-right:5px;
  }
</style>
<script>
setTimeout(function(){
},500)
var first1=0
function checki1(){
  if (first1 == 0) {

    first1 = 1
  }
setTimeout(function (){
  let v=[]
  
for (let i=0;i<TILES.length;i++){
let cnt=document.querySelector('#Iblocks')
if(TILES[i][2]){
 if(TILES[i][2]!=='/ NAN.png'){
 v +=`<div style="width: 30px;
 height: 30px;
 display: inline-block;
 image-rendering: pixelated;
 background:url('${TILES[i][2]}');
 background-size:100%; color: lightgrey; font-size:6px;
 " ondblclick="changeTexture('${TILES[i][2]}')" onclick="build(${TILES[i][0]})">i${TILES[i][0]} , S${TILES[i][1]}
</div>`
cnt.innerHTML=v
}
}}
let v23=[]
for (let i=0;i<SPRITES.length;i++){
let cnt=document.querySelector('#I2blocks')
if(SPRITES[i][2]){
  if(SPRITES[i][2]!=='/ NAN.png'){
 v23 +=`<div style="width: 30px;
 height: 30px;
 display: inline-block;
 outline:1px solid blue;
 image-rendering: pixelated;
 background:url('${SPRITES[i][2]}');
 background-size:100%; color: lightgrey; font-size:6px;
 "  ondblclick="changeTexture2('${TILES[i][2]}')" onclick="build2(${SPRITES[i][0]})">i${SPRITES[i][0]} , S${SPRITES[i][1]}
</div>`
cnt.innerHTML=v23
}
}}
},0)
}
setTimeout(function(){
  checki1()
},2000)
//window.setInterval(checki1,3000)
function build(e){
buildmap=1
  item=e
}
function build2(e) {
buildmap=0
  item2 = e
}
let selectedTileIndex = null;
function changeTexture(textureBase64) {
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept= "image/png"
    fileInput.addEventListener('change', (event) => {
        const files = event.target.files;
        if (files.length > 0) {
            const newBlockIndex = TILES.length; 
            const collisionValue = 1;
            const image = event.target.files[0];
     
            const reader = new FileReader()

            reader.readAsDataURL(image)
            reader.addEventListener('load', () => {
//const newTextureBase64 = reader.result; 
for (let i = 0; i < TILES.length; i++) {

  if (TILES[i][2] === textureBase64) {
    TILES[i][2] = reader.result;
  }
}
                checki1()
                updateViewport();
            })
        }
    });
    fileInput.click();
}
function changeTexture2(textureBase64) {
  const fileInput = document.createElement('input');
  fileInput.type = 'file';
  fileInput.accept = "image/png"
  fileInput.addEventListener('change', (event) => {
    const files = event.target.files;
    if (files.length > 0) {
      const newBlockIndex = SPRITES.length;
      const collisionValue = 1;
      const image = event.target.files[0];

      const reader = new FileReader()

      reader.readAsDataURL(image)
      reader.addEventListener('load', () => {
        //const newTextureBase64 = reader.result; 
        for (let i = 0; i < SPRITES.length; i++) {

          if (SPRITES[i][2] === textureBase64) {
            SPRITES[i][2] = reader.result;
          }
        }
        checki1()
        updateViewport();
        config.sprites=SPRITES
      })
    }
  });
  fileInput.click();
}
</script>
<style>
  *{
    margin:0;
  }
  .containerZ {
    position: fixed;
    width: 100vw;
    height: 100vh;
    color:#FFFFFF;
    background-color: #1F1F1F;
    z-index: 99999999999999;
  }
  .tile-info {
    position: absolute;
    top: 0;
    right: 0;
    width: 40%;
    height:100px;
    border: 1px solid #ccc;
    padding: 10px;
  }
  .tile-info img {
    max-width: 150px;
    max-height: 50px;
    width:100%;
    height: 100%;
    display: block;
    margin: 0 auto 10px; 
  }
  .stats {
    text-align: center;
    overflow: hidden;
    overflow: scroll;
    height: 200px
  }
  .tile-details {
    position: absolute;
    top: 0px; 
    left: 0px; 
    width: calc(100% - 40% - 50px); 
    height: calc(100% - 25px);
    border: 1px solid #ccc;
    overflow: hidden;
overflow: scroll;
    padding: 10px;
  }
  .options {
    position: absolute;
    top: 0;
    right: 0;
    margin-top: 120px; 
    width: 40%;
    height: calc(100vh - 145px) ;
    border: 1px solid #ccc;
    overflow: hidden;
overflow: scroll;
    padding: 10px;
  }#ICON{
   //image-rendering: pixelated
  }
</style>
</head>
<body>
<div class="containerZ hide2">
  <div style="width:8px; height: 8px; background: red; color:white; padding :10px; position: absolute; right:0; top:0; z-index: 99" onclick="toggleVS()">
    x
  </div>
  <div class="tile-info">
    <img src="/watermark.gif" id="ICON" alt="">
  </div>
  <div class="tile-details">
    <h2 style="animation: 5s rainbow infinite cubic-bezier(0.19, 1, 0.22, 1);" >Make Sprite</h2>
  <input type="file" class="a hide2" accept="image/png, image/gif" id="imageInput" style="display: none;">
  <button class="a hide2" id="addButton" style="animation: 5s rainbow infinite cubic-bezier(0.19, 1, 0.22, 1);">add block <br></button>
    <input type="file" class="a hide2"  accept="image/png, image/gif"id="imageInput2" style="display: none;">
  <button class="a hide2" style="animation: 5s rainbow infinite cubic-bezier(0.19, 1, 0.22, 1); filter: hue-rotate(50deg); filter: sepia(50%);" id="addButton2"> Add normal deco <br></button>
        <input type="file" class="a hide2" accept="image/png, image/gif" id="imageInput5" style="display: none;">
        <button class="a hide2" style="animation: 5s rainbow infinite cubic-bezier(0.19, 1, 0.22, 1);" id="addButton5" style="animation: 5s rainbow infinite ;" >add entity<br></button>
        <input type="file" class="a hide2" accept="image/png, image/gif" id="imageInput10" style="display: none;">
<button class="a hide2" style="animation: 5s rainbow infinite cubic-bezier(0.19, 1, 0.22, 1);" id="addButton10" style="animation: 5s rainbow infinite ;" >add special entity <p style="font-size: 7px">it will be rendered outside of viewport</p><br></button> 

        <input type="file" class="a hide2" accept="image/png, image/gif" id="imageInput6" style="display: none;">
        <button class="a hide2"  id="addButton6">add Text Element (experiment can doesn't work properly)<br></button>
      <input type="file" class="a hide2"  id="imageInput3" accept="image/png, image/gif" style="display: none;">
      <button style="animation: 5s rainbow infinite cubic-bezier(0.19, 1, 0.22, 1);" class="a hide2"  id="addButton3">Change Player<br></button>
      <input class="a hide2" type="file"  accept="image/png, image/gif" id="imageInput4" style="display: none;">
      <button class="a hide2" id="addButton4" style="animation: 5s rainbow infinite cubic-bezier(0.19, 1, 0.22, 1);">change BG<br></button>
  </div>
  <div class="options">
    <div class="stats">
<style>
  #container123212{
    zoom:0.5;
    float: left;
  }
  #container12321{
    zoom:0.5;
    float: left;
  }
  #container123211{
    zoom:0.5;
    float: left;
  }
</style>
ENTITY IDENTYFICATOR
<div id="container123212" class="notaproject  a hide2">
  <div  class="box0 " onclick="add123212()"   >+</div>
  <input type="number" id="value123212" oninput="DZ(this.value)" class="box1"></input>
  <div class="box0" onclick="sub123212()"   >-</div>
</div>
<script>
var isentity=2;
function testupd(){

   let elemento = "alltiles" + isentity;
if (elemento in config.entities) {
  document.getElementById('value123212').style.color = "red";
} else {
  document.getElementById('value123212').style.color = "lime";
}
}
function entityupd(){
  let entityName=isentity
  let testexample2={"examples":{"alltiles0":[2,"follow,move,avoid",0,3,0,1,[0,0,999999,999999],true,"[[0,0],[0,0]]",0,1,0,"player",,,,,,,1]}}
  if (entityName) {
  const entityId = parseInt(entityName);
  const entityKey = "alltiles" + entityId;
  if(!(entityKey in config)){
  if (!isNaN(entityId)) {
    const selectedExample = "alltiles0";
    if(!(entityKey in config.entities)){
   //   alert(entityKey)
    config.entities[entityKey] = JSON.parse(JSON.stringify(testexample2.examples[selectedExample]));
    displayEntities();}
  } else {
  }}
}
}
window.setInterval(testupd,1500)
  function add123212(){ if(isentity > -1 ){ isentity +=1; updt212()}}function sub123212(){if(isentity > 0 ){ isentity -=1 ; updt212()}}function updt212(){document.getElementById('value123212').value=isentity; updateViewport()}
  function DZ(data){
    isentity=parseInt(data)
  }
</script>
<br> <br> <br>
block size
<div id="container12321" class="notaproject  a hide2">
  <div  class="box0" onclick="add12321()"   >+</div>
  <div id="value12321" class="box1"                      >scale 1</div>
  <div class="box0" onclick="sub12321()"   >-</div>
</div>
<script>
var thistilesize=1;
  function add12321(){ if(thistilesize > -1 ){ thistilesize +=0.5; updt21()}}function sub12321(){if(thistilesize > 0 ){ thistilesize -=0.5 ; updt21()}}function updt21(){document.getElementById('value12321').innerText=thistilesize; updateViewport()}
</script>
<div id="container123211" class="notaproject  a hide2">
  <div  class="box0" onclick="add123211()"   >+</div>
  <div id="value123211" class="box1"                      >Layer 0-def 5- on the player</div>
  <div class="box0" onclick="sub123211()"   >-</div>
</div>
<script>
var translateY=0;
  function add123211(){ if(true ){ translateY +=1; updt211()}}function sub123211(){if(true){ translateY -=1 ; updt211()}}function updt211(){document.getElementById('value123211').innerText=translateY; updateViewport()}
</script>
        </div>
  </div>
</div>
  <input type="file" class="a hide2" style="position: absolute ;top:calc(5% + 30px);left:20%;" accept="image/png/gif" id="imageInput" style="display: none;">
  <button class="a hide2" style="position: absolute ;top:calc(5% + 30px);left:20%;" id="addButton">add block <br></button>
    <input type="file" class="a hide2" style="position: absolute; top:calc(5% + 60px);left:20%; width: 30px" accept="image/png/gif" id="imageInput2" style="display: none;">
  <button class="a hide2" style="position: fixed; top:calc(5% + 60px);left:20%;"id="addButton2">add deco <br></button>
        <input type="file" class="a hide2" style="position: absolute; top:calc(5%);left:20%;width: 30px" accept="image/png/gif" id="imageInput5" style="display: none;">
        <button class="a hide2" style="position: fixed; top:calc(5%);left:20%;" id="addButton5">add entity<br></button>
        
        <input type="file" class="a hide2" accept="image/png/gif" id="imageInput10" style="display: none;">
        <button class="a hide2" style="animation: 5s rainbow infinite cubic-bezier(0.19, 1, 0.22, 1);" id="addButton10" style="animation: 5s rainbow infinite ;">add DOM entity <br></button>
        
        <input type="file" class="a hide2" style="position: absolute; top:calc(70%);left:20%;width: 30px" accept="image/png/gif" id="imageInput6" style="display: none;">
       <button class="a hide2" style="position: fixed; top:calc(70%);left:20%; display:none;" id="addButton6">add projetitle<br></button>
      <input type="file" class="a hide2" style="position: absolute; top:calc(5% + 90px);left:20%;width: 30px"  id="imageInput3" style="display: none;">
      <button class="a hide2" style="position: fixed; top:calc(5% + 90px);left:20%;" id="addButton3">Change default player<br></button>
      <input class="a hide2" type="file" style="position: absolute; top:calc(5% + 120px);left:20%;width: 30px" accept="image/png" id="imageInput4" style="display: none;">
      <button class="a hide2" style="position: fixed; top:calc(5% + 120px);left:20%;" id="addButton4">change background<br></button>
	  <p id="cns" ><p id="fps"></p>
	  <p id="console" style="z-index: 999999999999999" class="notaproject"></p></p>
<style>
#cns{
  position :absolute ;
  top :0;
  right :200px;
  z-index :5;
}
.darkness{
  position :absolute ;
  width: 100vw;
  background-image : radial-gradient(circle,#00000026 20%,#000000C9 40%);
  height: 100vh;
  z-index :1;
 left: 0;
}
#woter {
  position: absolute;
  width: 150vw;
  background-image: radial-gradient(circle, #00000026 20%, #000000D1 50%);
  height: 100vh;
  z-index: 1;
  animation :2s d infinite;
}
@keyframes d{
  0%{
    rotate: 20deg;
    opacity :0.1;
  }
  100%{
    rotate: 30deg ;
    opacity :0.01;
  }
}
#console {
width: 140px;
color:white;
background: #00000047;
position: absolute;
z-index: 999;
bottom: 0;
left:30px;
}
.player {
  position: absolute;
 
  z-index: 6;
  opacity:0;
  width: 16px;
  background: #2D2D2D;
  height: 16px;
  
  opacity:0;
 
}
/*.player::after {
  content: ''; 
  position: absolute;
  z-index: 6; 
  width: 150%; 
  height: 150%; 
  background: inherit;
  background-size: 100%; 
  transform: scale(1.2); 
  
}*/
#playerskin{
  position: absolute;
  content: '';
z-index: 6;
width: 21px;

height: 21px;
background: #42445A;




background-size: 200%;
transform: var(--after-transform);

//image-rendering: pixelated;
}

#fps{
  position: fixed;
  display: none;
  top:0;
  left:0;
}
		.joystick {
		  display: none;
  position: fixed ;
  z-index :2;
  bottom :60px;
  right:70%;
  width: 100px;
  height: 100px;
  border-radius: 50%;
  background-color: #978A8A42;
}
.jumpbtn{
position: fixed;
  z-index :2;
  bottom :60px;
  right:150px;
  width: 100px;
  height: 100px;
  border-radius: 50%;
  background-color: #6F6F6FA1;
}
.stick {
  position: absolute;
  width: 50px;
  height: 50px;
  top: 25px;
  left: 25px;
  border-radius: 50%;
  background-color: #00000080;
}
#viewport {
  touch-action: none;
  overflow: hidden auto;
 transform: translate(-50%, -50%);
  top:50%;
  left:50%;
  position :absolute ;
  
}
#content2 {
//image-rendering: pixelated;
  overflow: auto;
  transform: translate(-50%, -50%);
  top: 50%;
  left: 50%;
  position: fixed;
background-size: 100%;
}
#content {
  position: relative;
 //image-rendering: pixelated;
}
#content2 {
 //image-rendering: pixelated;
}
.tile {
  position: absolute;
  background-size: 32px;
  box-sizing: border-box;
  
}
.nothing {
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAK0lEQVQYGWNkYGD4D8Rw8J9hCpwNYjCh8LBwKFfAgm4nI0MOikWUW0HQBACOVgSkom3uKAAAAABJRU5ErkJggg==");
  //image-rendering: pixelated;
  background-size: 100%;
}
.tile1 {
  position: absolute;
  background-size: 32px;
  box-sizing: border-box;
}
.sampletile {
  position: absolute;
  width: 32px;
  height: 32px;
  background-color: #00000000;
  background-size: 32px;
  box-sizing: border-box;
}
.alltiles{
}
.line-number{
  background: #42445A70;
  color:#FFFFFF;
  width: 32px;
  font-size: 6px;
  height:32px;
  z-index: 2;
  position: absolute;
}
.SPRITE{
  background-size: cover;
  background-position: center center; 
width: 10%;
//image-rendering: pixelated;
height: 10%
}
</style>
<script>
/* Script With Actually function of a game */
var leftButtonDown = 0;
var rightButtonDown = 0;
var upButtonDown = 0;
var downButtonDown = 0;
const viewport = document.getElementById('viewport');
const content = document.getElementById('content');
var showlines=0

let shiftFix=0
content.style.backgroundSize=(config.bgsize)+"px"

var tileSize = config.tilesize; 
var cfigZ = config.zoomoff;
var vp = document.getElementById("viewport");
vp.style.zoom = cfigZ*config.zoomadd;
document.querySelector('#content2').style.zoom = cfigZ*config.zoomadd;
var originalWidth = parseInt(vp.style.width);
var originalHeight = parseInt(vp.style.height);
var newWidth = originalWidth /cfigZ;
var newHeight = originalHeight / cfigZ;
document.querySelector('#content2').style.width = newWidth + "px";
document.querySelector('#content2').style.height = newHeight + "px";
vp.style.width = newWidth + "px";
vp.style.height = newHeight + "px";
if(config.testmode==0){
  newWidth = config.width;
newHeight = config.height;
cfigZ=1; 
vp.style.zoom = cfigZ;
 newWidth = config.width;
 newHeight = config.height;
vp.style.width = newWidth + 'px';
vp.style.height = newHeight + 'px';
}
let viewportWidth = viewport.clientWidth;
let viewportHeight = viewport.clientHeight;
const numTilesX = 99999
const numTilesY = 99999
const contentWidth = numTilesX ;
const contentHeight = numTilesY;
content.style.width = contentWidth + 'px';
content.style.height = contentHeight + 'px';
let numVisibleTilesX = Math.ceil(viewportWidth/tileSize);
let numVisibleTilesY = Math.ceil(viewportHeight/tileSize );
let startTileX = 0
let startTileY = -2
const tileCache = {}; 
let lastplayerpos = [];
var dimension = 0;
var canJUMP=0
if (!('sprites' in config)) {
  config['sprites'] = [];
}
if (!('spritesmap' in config)) {
  config['spritesmap'] = [[],[],[]];
}
var SPRITES = config.sprites

var TILES = config.blocks;
var blockstoaddtocollision=[
]
var deletedtiles=[]
// observer
function handleIntersection(entries) {
  entries.forEach((entry) => {
    const tile = entry.target;
    if (!entry.isIntersecting && tile.parentElement.id === 'Econtent') {
return 1;
    }
  });
}
function calculateVisibleTiles() {
  const numVisibleTilesX = Math.ceil(viewportWidth / sizescale)+6;
  const numVisibleTilesY = Math.ceil(viewportHeight / sizescale)+6;
  return { numVisibleTilesX, numVisibleTilesY };
}

const observer = new IntersectionObserver(handleIntersection, { threshold: 0.5 });

function up1() {
  setTimeout(function() {
    newWidth = config.width;
      newHeight = config.height;
      cfigZ = 0;
      vp.style.zoom = cfigZ;
      newWidth = config.width;
      newHeight = config.height;
      vp.style.width = newWidth + 'px';
      vp.style.height = newHeight + 'px';
    if (config.testmode == 1) {
      cfigZ = config.zoomadd
      vp.style.zoom = cfigZ * config.zoomadd;
      originalWidth = parseInt(vp.style.width);
      originalHeight = parseInt(vp.style.height);
      newWidth = originalWidth / cfigZ;
      newHeight = originalHeight / cfigZ;
      vp.style.width = newWidth + "px";
      vp.style.height = newHeight + "px";
      document.querySelector('#content2').style.width = vp.style.width 
      document.querySelector('#content2').style.height = vp.style.height 
      document.querySelector('#content2').style.zoom = vp.style.zoom 
    }
    if (config.testmode === 1) {
      document.getElementById('viewport').style.left = "50%"
      var elementsToHide = document.getElementsByClassName('notaproject');
      Array.from(elementsToHide).forEach(element => {
        element.classList.add('hide3')
      });
      var elementsTomove = document.getElementsByClassName('jumpbtn');
      Array.from(elementsTomove).forEach(element => {
        element.style.right = '1px';
      });
      document.getElementById('withgui').style.transform = ""
      document.getElementById('pastemark').style.left = "5px"
      document.getElementById('pastemark').style.top = ""
      document.getElementById('pastemark').style.opacity="0.5"
document.getElementById('withgui').style.position = ""
    } else {
      // editor mode
      if(editor=="left"){
      document.getElementById('viewport').style.left = "calc(50% + 100px)"
      document.getElementById('pastemark').style.left = "220px"
      document.getElementById('pastemark').style.opacity="1"
      document.getElementById('pastemark').style.top = "0px"
     document.getElementById('withgui').style.transform = "translate(150px,0%)"
      document.getElementById('withgui').style.position="absolute"
      document.getElementById('sus').style.right = ""
document.getElementById('sus').style.left = "0px"
document.getElementById('sus').style.right = ""
document.getElementById('sus').style.left = "0px"
      }else{
        document.getElementById('sus').style.right="0px"
        document.getElementById('sus').style.left=""
        document.getElementById('viewport').style.left = "calc(50%)"
        document.getElementById('withgui').style.transform = "translate(0%,0%)"
        document.getElementById('toggleButton').style.left="0px"
      }
      var elementsToHide = document.getElementsByClassName('notaproject');
      Array.from(elementsToHide).forEach(element => {
        element.classList.remove('hide3')
      });
      var elementsTomove = document.getElementsByClassName('jumpbtn');
      Array.from(elementsTomove).forEach(element => {
        element.style.right = '1px';
      });
    }
  }, 300)
}
setTimeout(up1,1000)


/* RENDERING ALL TILES AT ONCE */


/* RENDERING ALL SPRITES AT ONCE */
function updatePORTEl() {
  var Eldercontent=document.getElementById('Tcontent')
    var Spritesdatasheetmap = config.spritesmap;
    var Spritesdatasheet = config.sprites;
    /* spritesmap [[[x,y,t],[x,y,t]],[]] */
    /* [[],[],[]] dimensions */
    
    Eldercontent.innerHTML = "";
    const fragment = document.createDocumentFragment();

    Spritesdatasheetmap[dimension].forEach(sprite => {
        const [x, y, t] = sprite;
        const spriteData = Spritesdatasheet.find(data => data[0] === t);

        if (spriteData) {
            const tile = document.createElement('div');
             
           /* if (spriteData[2] == 1) {
  tile.className = 'tile1 nothing alltiles';
}else{*/
            tile.className = `tile alltiles${spriteData[1]} entities sprite${t}`;
            
            if(spriteData[1]==4){
              tile.classList.add('hurtblock')
            }
            tile.classList.add('extra_sprites'+spriteData[0]);
           tile.classList.add('SPRITE')
            tile.style.backgroundImage = `url("${spriteData[2]}")`;
            tile.style.left = x * tileSize + 'px';
            tile.style.top = y * tileSize + 'px';
            tile.style.width = tileSize + 'px';
            tile.style.height = tileSize + 'px';
tile.dataset.x = x;
tile.dataset.y = y;
tile.dataset.startx = x;
tile.dataset.starty = y;
tile.dataset.s = t;
            if (spriteData[3]) {
                tile.style.transform = `scale(${spriteData[3]})`;
            }

            if (spriteData[4]) {
                tile.style.zIndex = spriteData[4];
            }

            fragment.appendChild(tile);
        }
    });

    Eldercontent.appendChild(fragment);
}

/* RENDERING */
function updateViewport() {
  
  content.innerHTML=""
  
  content.innerHTML+=`<div id="vpfilter"></div>`
  if (!('screenfilter' in config)) {
  config['screenfilter'] = [0, 0, 0, 0];
}
if(document.getElementById('vpfilter')){
document.getElementById('vpfilter').style.background=`rgba(${config.screenfilter[0]*255},${config.screenfilter[1]*255},${config.screenfilter[2]*255},${config.screenfilter[3]})`;
  document.getElementById('vpfilter').style.width=99**20+"px"
  document.getElementById('vpfilter').style.height=99**20+"px"
  document.getElementById('vpfilter').style.zoom=document.getElementById('viewport').style.zoom}
  const scrollLeft = viewport.scrollLeft;
  const scrollTop = viewport.scrollTop;
  const { numVisibleTilesX, numVisibleTilesY } = calculateVisibleTiles();
  const startTileX = Math.floor(scrollLeft / tileSize) - 3;
  const startTileY = Math.floor(scrollTop / tileSize) - 3;
  const endTileX = startTileX + numVisibleTilesX + 3;
  const endTileY = startTileY + numVisibleTilesY + 3
const fragment = document.createDocumentFragment();
    var treh = 0;
    var s = 0;
    for (let x = startTileX; x < endTileX; x++) {
      for (let y = startTileY; y < endTileY; y++) {
        let cty = 0;
        const tileKey = `${x}-${y}`;
        if (true) {
          const tileCoords = [x * 1, y * 1];
          const tileType = tileMap[dimension].find(
            (coords) => coords[0] === tileCoords[0] && coords[1] === tileCoords[1]
          );
const tileCoords2 = [x, y];
      const matchingTiles = tileMap[dimension].filter(
        (coords) => coords[0] === tileCoords2[0] && coords[1] === tileCoords2[1]
      );
let blockzindex=0
      matchingTiles.forEach((tileType) => {
       blockzindex++
       let blockdataindex=0
       const tile = document.createElement('div');
          if (tileType) {
                          s = tileType[2];
            if (tileType[2] === 1) {
              tile.className = 'tile1 nothing alltiles';
              treh = 0;
            } else {
              tile.className = ` tile${parseFloat(tileType[2])} alltiles`;
              for (let i = 0; i < TILES.length; i++) {

                if (TILES[i][0] == tileType[2]) {
                  if (TILES[i][1] == 1) {
                    tile.className = `tile alltiles`;
                    tile.style.backgroundImage = `url("${TILES[i][2]}")`;
                  }else  if (TILES[i][1] == 4) {
                    tile.className = `tile1  alltiles hurtblock`;
                    tile.style.backgroundImage = `url("${TILES[i][2]}")`;
                  }else if (TILES[i][1] == -1) {
                    tile.className = `tile1 projetitle  alltiles hurtblock`;
                    tile.style.backgroundImage = `url("${TILES[i][2]}")`;
                  } else if (TILES[i][1] == 2) {
                    tile.className = `tile alltiles2`;
                    tile.style.backgroundImage = `url("${TILES[i][2]}")`;
                    const existingTile = document.querySelector(`.alltiles2[data-x="${x}"][data-y="${y}"][data-s="${s}"]`);
const similarDeletedTile = deletedtiles.find((deletedTile) => {
  return deletedTile.dataset.x === x.toString() && deletedTile.dataset.y === y.toString() && deletedTile.dataset.s === s.toString();
});
                    if (!existingTile && !similarDeletedTile) {
                      tile.dataset.x = x;
                      tile.dataset.y = y;
                      tile.dataset.s = s;
                      tile.style.left = x * tileSize + 'px';
                      tile.style.top = (y + treh) * tileSize + 'px';
                      document.querySelector('#Econtent').appendChild(tile);
                    }
                    cty = 1;
                  }else if (TILES[i][1] > 2) {

                    tile.className = `tile alltiles${TILES[i][1]} entities`;
                    tile.style.backgroundImage = `url("${TILES[i][2]}")`;
                    const existingTile = document.querySelector(`.alltiles${TILES[i][1]}[data-x="${x}"][data-y="${y}"][data-s="${s}"]`);
                    blockdataindex=1
const similarDeletedTile = deletedtiles.find((deletedTile) => {
  return deletedTile.dataset.x === x.toString() && deletedTile.dataset.y === y.toString() && deletedTile.dataset.s === s.toString();
});
                    if (!existingTile && !similarDeletedTile) {
                      tile.dataset.x = x;
                      tile.dataset.y = y;
                      tile.dataset.s = s;
                      tile.style.left = x * tileSize + 'px';
                      tile.style.top = (y + treh) * tileSize + 'px';
                      document.querySelector('#Econtent').appendChild(tile);
                    }
                    cty = 1;
                  } else {
                    tile.className = `tile1 alltiles nothing`;
                    if(TILES[i][2]){
                    tile.style.backgroundImage = `url("${TILES[i][2]}")`;
                    }
                  }
                  tile.classList.add('sprites'+TILES[i+1][0])
                  tile.style.transform=`scale(${TILES[i][3]||1})`;
                  tile.style.zIndex=(TILES[i][4]||0)
                }
              }
              treh = 0;
            }
          }
          tile.classList.add('SPRITE')
          // tile.style.willChange = 'transform';
          tile.style.width=tileSize-parseInt(tile.style.width/2)+0.1+"px"
          tile.style.height=tileSize-parseInt(tile.style.height/2)+0.1+"px"
          if (cty == 0) {
            tile.dataset.x = x;
            tile.dataset.y = y;
            tile.dataset.startx = x;
            tile.dataset.starty = y;
            tile.dataset.s = s;
            if(showlines==1){
            var line=document.createElement('div')
            line.classList='line-number'
            line.style.left = x * tileSize + 'px';
            line.style.top = (y + treh) * tileSize + 'px';
            line.textContent=tile.classList
            fragment.appendChild(line);
            }
            tile.style.left = x * tileSize + 'px';
            tile.style.top = (y + treh) * tileSize + 'px';
            fragment.appendChild(tile);
          }
          if(blockzindex>1||blockdataindex>0){
          tile.style.zIndex=(parseInt(tile.style.zIndex)||0)+blockzindex+blockdataindex+1
          }
        });}
      }
  }
  
  content.appendChild(fragment);
  
}
if (!('deletedtiles' in config)) {

  config['deletedtiles'] = [];
} else {
}
var elementGenerateAll="10"
function generateAllTiles() {
/*  document.querySelector('#Econtent').innerHTML = "";
  console.log('')
  //const { numTilesX, numTilesY } = calculateTotalTiles();
  const fragment = document.createDocumentFragment();
  tileMap[dimension].forEach((tileCoords) => {
    const matchingTiles = tileMap[dimension].filter(
      (coords) => coords[0] === tileCoords[0] && coords[1] === tileCoords[1]
    );
    matchingTiles.forEach((tileType) => {
      if(tileType[1]==elementGenerateAll){
      const [x, y] = tileCoords;
      const tile = document.createElement('div');
      tile.className = `tile alltiles${tileType[1]} entities`;
      tile.style.backgroundImage = `url("${tileType[2]}")`;
      tile.dataset.x = x;
      tile.dataset.y = y;
      tile.dataset.s = 0; // Assuming s value is always 0 for now
      tile.style.left = x * tileSize + 'px';
      tile.style.top = y * tileSize + 'px';
document.querySelector('#Econtent').appendChild(tile);
     // fragment.appendChild(tile);
    }});
  });
  */
}
generateAllTiles()

const scrollInterval = 1500
let isScrolling = false;
viewport.addEventListener('scroll', function () {
  isScrolling = true;
});
/* Editor Click to remove entity*/
document.addEventListener("DOMContentLoaded", function() {
  document.addEventListener("click", function(event) {
    if(config.testmode==0){
    if (event.target.classList.contains("entities")) {
      const x = event.target.dataset.x;
      const y = event.target.dataset.y;
      const s = event.target.dataset.s;
      // Remove from the tileMap
      tileMap[dimension] = tileMap[dimension].filter(
        (coords) => coords[0] !== parseFloat(x) || coords[1] !== parseFloat(y) || coords[2] !== parseFloat(s)
      );
      // Remove the element from the DOM
      event.target.remove();
    }}
  });
});

var entityblocks = [[], [], []];
var killed=0
if (!('killed' in config)) {

  config['killed'] = killed;
} else {
 killed=config.killed
}
var score=0
var tileConfig = config.entities
var stop=0
var spritetomove = 0;
function movemap(dataSpriteX, dataSpriteY, tag) {
  dataSpriteX= parseFloat(dataSpriteX)
  dataSpriteY= parseFloat(dataSpriteY)
  tag= parseFloat(tag)

  tileMap[dimension].forEach((tileCoords) => {
    const [x, y, t] = tileCoords;

    if (t === tag) {
      let newX = parseInt(x) + parseInt(dataSpriteX);
      let newY = parseInt(y) + parseInt(dataSpriteY);

      tileCoords[0] = newX;
      tileCoords[1] = newY;
tileCoords[0] = newX;
tileCoords[1] = newY;
setTimeout(function(){
  tileCoords[0] = newX;
  tileCoords[1] = newY;
  for (var i = 0; i < 10; i++) {
tileCoords[0] = newX;
    tileCoords[1] = newY;
  }
},5)

      let econtentBlocks = document.querySelectorAll("#Econtent div");
      econtentBlocks.forEach((block) => {
        if (parseInt(block.dataset.x) === x && parseInt(block.dataset.y) === y) {
          block.parentNode.removeChild(block);
        }
      });
    }
  });
}
function movesprite(dataSpriteX, dataSpriteY) {
  if (stop == 0) {
      if (stop == 0) {
        var tiles = document.querySelectorAll(`.${spritetomove}`);
       // console.log(spritetomove)
        tiles.forEach((tile) => {
          let left = parseFloat(tile.style.left) || 0;
          let top = parseFloat(tile.style.top) || 0;
          top += parseFloat(dataSpriteY);
          left += parseFloat(dataSpriteX);
          tile.style.left = left + "px";
          tile.style.top = top + "px";
        });
      }
  }
}function teleportSprite(sourceClass, destinationClass) {
  if (stop == 0) {
    var sourceTiles = document.querySelectorAll(`.${sourceClass}`);
    var destinationTiles = document.querySelectorAll(`.${destinationClass}`);
    sourceTiles.forEach((sourceTile, index) => {
      let destinationTile = destinationTiles[index % destinationTiles.length];
      let left = parseFloat(destinationTile.style.left) || 0;
      let top = parseFloat(destinationTile.style.top) || 0;
      sourceTile.style.left = left + "px";
      sourceTile.style.top = top + "px";
    });
  }
}
function convertspritetoblock(spriteKey) {
  if (stop == 0) {
    let tilesExist = false;
    for (let spriteKey in tileConfig) {
      if (stop == 0) {
        var tiles = document.querySelectorAll(`.${spriteKey}`);
        if (tiles.length > 0) {
          tilesExist = true;
          tiles.forEach((tile) => {
// // // // //
            tile.dataset.hide=true
          });
        }
      }
    }
  }
}
/*document.querySelectorAll('.entities').forEach((tile) => {
  observer.observe(tile);
});*/
function findClosestProjetitle(tile, collisionobject) {
    let closestProjetitle = null;
    let closestDistance = Infinity;
    const projetitles = document.querySelectorAll('.projetitle');
    const tileX = parseInt(tile.style.left) / tileSize;
    const tileY = parseInt(tile.style.top) / tileSize;
    projetitles.forEach(projetitle => {
        const projetitleX = parseInt(projetitle.style.left) / tileSize;
        const projetitleY = parseInt(projetitle.style.top) / tileSize;
        const distance = Math.sqrt(Math.pow(tileX - projetitleX, 2) + Math.pow(tileY - projetitleY, 2));
        if (distance < closestDistance) {
            closestDistance = distance;
            closestProjetitle = projetitle;
        }
    });
    return closestProjetitle;
}

var codes=[]
var onece5 = 1
var newtilemap=config.savedTileMap
let Vables = {};
function getPlayerPositionRelativeToTile(tile,left,top) {
    const tileRect = tile.getBoundingClientRect();
    const tileCenterX = left;
    const tileCenterY = top;
    const playerCenterX = playerX
    const playerCenterY = playerY ;
    const deltaX = playerCenterX - tileCenterX;
    const deltaY = playerCenterY - tileCenterY;

    const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
let data=0;
    if (angle > -45 && angle <= 45) {
        data= 'right';
        if(ostclick=='left'){
return true;
        }
    } else if (angle > 45 && angle <= 135) {
        data= 'bottom';
        if (ostclick == 'up') {
return true;
}
    } else if (angle > 135 || angle <= -135) {
        data= 'left';
        if (ostclick == 'right') {
return true;
}
    } else {
        data= 'top';
        if (ostclick == 'down') {
return true;
}
    }
}
function loadoldergamestate(){
  config.bg=config.oldbg
  tileMap=config.savedTileMap

deletedtiles = []
const playerskin69 = config.playerskin1

document.querySelector('.player').style.background = `url(${playerskin69})`
playerskin = playerskin69
updateViewport();
setTimeout(function() {
  if (config.DarknessEffect == 1) {
    let vp = document.getElementById("viewport")
    let el = document.createElement('div')
    el.style = `width:${vp.style.width};height:${vp.style.height};`
    el.className = 'dark effects added'
    document.querySelector('#project').appendChild(el)
  } else {
    let y = document.querySelectorAll('.effects')
    for (var i = 0; i < y.length; i++) {
      if (y[i].classList == 'dark') {
        y[i].remove()
      }
    }
  }
}, 1000)
bgimg = config.bg
deletedtiles = []
document.getElementById('edytor').textContent = config.code
stop = 1
code = config.code;
classicspeed = config.norspeed;
playerY = config.spawnY;
playerX = config.spawnX;
setPlayer(config.spawnX, config.spawnY)
speed = config.speed;
playerskin = config.playerskin1;
TILES = config.blocks;
tileMap = config.savedTileMap;
gravity = config.gravity;
content.style.backgroundSize = (config.bgsize) + "px"
code = config.code
if (audioInstance) {

  audioInstance.pause();
  audioInstance.currentTime = 0;
  audioInstance = null;
}
if (config.music !== '') {
  let base64Wav = config.oldmusic;

 if (base64Wav!==null&&base64Wav!==undefined) {
  base64Wav = config.oldmusic;
} else {
  base64Wav = config.music;
}

  audioInstance = new Audio();
  audioInstance.src = base64Wav;
  audioInstance.setAttribute('preload', 'auto');

  document.body.appendChild(audioInstance);

  audioInstance.play();
  audioInstance.loop = true;
  toonce = 0;
}
if (config.customcamera == 1) {
  viewport.scrollTo(config.cameraX * tileSize2 - viewportWidth / 2, (config.cameraY * tileSize2) - viewportHeight / viewportHeight * viewportHeight / 2)
}
const contentElement = document.getElementById("content");
document.querySelector('gui').innerHTML = config.guiHTML
ukonczoneGUI()

contentElement.style.backgroundImage = `url('${bgimg}')`;
document.getElementById('Scontent').innerHTML = ''
document.getElementById('Econtent').innerHTML = ''
tileConfig = config.entities

moveTilesRandomly()
setTimeout(function() {
  curline = 0
  currentLine = 0
  generateAllTiles()
  candocmd = 1
  curline = 0
  currentLine = 0;
  candothath = 0
  defy = 0
  jmptimes = 0
  stop = 0
  RESET()
  if (config.stickybg1 == 0) {
    document.getElementById('content').style.backgroundImage = `url('${config.bg}')`
    document.getElementById('content2').style.backgroundImage = ``
  } else {
    document.getElementById('content2').style.backgroundImage = `url('${config.bg}')`
    document.getElementById('content').style.backgroundImage = ``
  }
}, 3000)

tileSize = config.tilesize
cfigZ = config.zoomoff;
vp = document.getElementById("viewport");

}
function savegameslot(){
}
function loadgameslot(){
}
let currentbase64=''
let currentdimension=dimension
let currentbase64img=''
var currentsoundformessage=''
let oldGravity=null;
var base64WavY=null;
function moveTilesRandomly() {
  if(stop==0){
    for (let tileId in tileConfig) {
      if(stop==0){
        var [speed, movementType, distance, randomMovement, collision, initialHp, area, deletebool,arena,hurt,vi,score1,collisionobject="player",detectanabled,collisionwithotherblocks,deletewhencustommoveended,anableshootingattackforentities,collectable,spawnpoint,cantbedamaged,teleportBy,movetilesdeffacted,spawn,despawn,oneDirectionFollow,changeLoopMusicMain,changeLoopMusic, abilities, noAttackfunction, Respawn , collisioneventprojectilespeed,collisioneventprojectilemove,collisioneventprojectileduration,collisioneventprojectilelifetime, collisioneventprojectiletexture, collisioneventprojectilesize,codescript,puzzleblock,patternendbacktostart,gravitypow,
        changeVariablecollisionevent, gethurttexture,gethurtdelay,
        reversedistance ,
        collisiontexture,
        distance2,
        movementType2,
        collisionobject2,
        whendistance2makepattern,
        NPCdialogue,
        collisionEVAL,
        NPCdialogueends_remove,
        NPCdialogueends_spawn,
        collisiondistance,
        spawn2,
        showindicator,
moveonlywhenplayerlooking,
moveonlywhenplayerlookingaway,
randomteleporting,// [duration,xmin,xmax,ymin,ymax]
dialogueends_killedmoveandthisremove,//[killed===,(i),x,y]
spawn_if_killed,
changebackground, backgroundtexture,
hideifevent,
showifevent,
mindistance,
playertextureleft,
playertextureright,
playertextureup,
playertexturedown,
playertexturestayleft,
playertexturestayright,
playertexturedefault,
playertexturestaydown,
changeplayertexture,
resetkills,
ifentityexistonVPmovetilesandthiskill,
otherentitycollision,
addotherclasses,
collisionchangedimension,
lookatobject,
spawningdistance,//number
spawningoffset,//[x,y]
spawnnumber,
despawnMS,
playercollisiondistance,
damageplayer,
changeplayerdamage,
spawn3inside,
changeloopmusicwhendialogueends,
changedimensionifdeffacted,
collisionchangerandomdimension,
whenkilledspawnSprite,
dialiguesounds,//+stop
ifvariablekillthiswhencollision,
ifvariablekillthiswhenshown,
regenerateplayerpos,
removefroviewpirtifoutside,
BLOCKTYPE,
weird3dblockwall,
hideshowplayer,
customhitboxplayercollision,
playerstayup,
collisionfilter,
nothing
        ] = tileConfig[tileId];

        var tiles = document.querySelectorAll(`.${tileId}`);
        let gototarget;
tiles.forEach((tile) => {
  var closestIndex = 0;
  var closestDistance
  let executeall=0
  let executeall2=0
  let viewport3 = document.getElementById('viewport');
  if (damageplayer !== undefined && damageplayer !== null) {
  tile.dataset.damage = parseInt(damageplayer) || 1
} else {
  tile.dataset.damage = 1
}
                let dist = 1
                if (playercollisiondistance !== undefined &&playercollisiondistance&& playercollisiondistance !== null) {
                  dist = parseInt(playercollisiondistance) ||1
                }
                tile.dataset.damagedist=dist
let tileRect8 = tile.getBoundingClientRect();
const viewportRect8 = viewport3.getBoundingClientRect();
if (
  tileRect8.top + 2 * tileSize >= viewportRect8.top &&
  tileRect8.left + 2 * tileSize >= viewportRect8.left &&
  tileRect8.bottom - 2 * tileSize <= viewportRect8.bottom &&
  tileRect8.right - 2 * tileSize <= viewportRect8.right&& tile.dataset.x
) {
  function findTileDimension(tileMapp, x, y, s) {
  // Przejście przez wszystkie wymiary tileMap
  for (var dimensioned = 0; dimensioned < tileMapp.length; dimensioned++) {
    // Sprawdzenie, czy kafelek o podanych współrzędnych istnieje w danym wymiarze
    const foundTile = tileMapp[dimensioned].find(block =>
      parseInt(block[0]) === x &&
      parseInt(block[1]) === y &&
      parseInt(block[2]) === s
    );

    if (foundTile) {
      return dimensioned;
    }
  }

  return -1;
}

const xc = parseInt(tile.dataset.x)
const yc = parseInt(tile.dataset.y)
const sc = parseInt(tile.dataset.s)
if(xc!== undefined){
const dimensionIndex = findTileDimension(tileMap, xc, yc, sc);
if (parseInt(dimensionIndex) == parseInt(dimension)||parseInt(dimensionIndex) == -1) {
executeall=1

} else {
  tile.remove()

  executeall=0
}}
}else{executeall=1/*
  if(vi==1){executeall=0}else{
  executeall=1}*/
}
if (
  tileRect8.top + 2 * tileSize >= viewportRect8.top &&
  tileRect8.left + 2 * tileSize >= viewportRect8.left &&
  tileRect8.bottom - 2 * tileSize <= viewportRect8.bottom &&
  tileRect8.right - 2 * tileSize <= viewportRect8.right && vi==1
) {
  executeall2=1
}else if(vi==1){
  executeall2=0
  if(removefroviewpirtifoutside==1){
    tile.remove()
  }
}
if(vi!==1){
  executeall2=1
}
  if(executeall==1&&executeall2==1){
    
  
    
  function removefromtilemap(){
    const currentX = parseInt(tile.dataset.x)
const currentY = parseInt(tile.dataset.y)
const currentS = parseInt(tile.dataset.s)

setTimeout(function() {
  if (onece5 == 1) {
    if (finishproject == 1) {
      onece5 = 0;
      for (var i = 0; i < 2; i++) {
        const blocksToRemove = tileMap[dimension].filter(block =>
          parseInt(block[0]) === currentX &&
          parseInt(block[1]) === currentY &&
          parseInt(block[2]) === currentS
        );
        blocksToRemove.forEach(blockToRemove => {
          const indexToRemove = tileMap[dimension].indexOf(blockToRemove);
          tileMap[dimension].splice(indexToRemove, 1);
        });
        config.savedTileMap = tileMap;
        setTimeout(function() {
          onece5 = 1;
        }, 100);
      }
    }
  }
}, 300);
  }
if(codescript!==undefined&&codescript!==null&&codescript&&tile.dataset.executecode!==1){
    if(!tile.dataset.executecode){
      tile.dataset.executecode=1
    }
    codes.push([codescript[0],codescript[1]])
    interpretCode(codescript[0],0)
  }
    var targetToX=playerX;
    var targetToY=playerY;
    var targetToX2 = null;
var targetToY2 = null;
    var shootingTargettargetToX=-100;
    var shootingTargettargetToY=-100;
if (addotherclasses!==undefined&&addotherclasses!==null&&addotherclasses!==""&&addotherclasses!=="null") {
  for (var i = 0; i < addotherclasses.length; i++) {
    if (!tile.classList.contains(addotherclasses[i])) {
      tile.classList.add(addotherclasses[i]);
    }
  }
}
function KillThis(){
  if(true){

   if(cantbedamaged==1){}else{
    let gototarget = findClosestProjetitle(tile, collisionobject);
if (gototarget&&gototarget!==NaN&&gototarget!==null&&gototarget!==undefined) {
  gototarget.remove()
}}

                  if(ifvariablekillthiswhenshown!==undefined&&ifvariablekillthiswhenshown!==null){
                    tile.dataset.hp -= 5;
                  }
                  if (ifvariablekillthiswhencollision !== undefined && ifvariablekillthiswhencollision !== null) {
  tile.dataset.hp -= 5;
}
                  tile.dataset.hp -= config.playerdamage;
if(config.folder!==undefined){

  if(config.folder.sounds.player[2]){
  let newaudio;
  const base64Wav = config.folder.sounds.player[2];

  newaudio = new Audio();
  newaudio.src = base64Wav;
  newaudio.setAttribute('preload', 'auto');

  document.body.appendChild(newaudio);
  
  newaudio.play();
  }}
                  if (tile.dataset.hp < 1) {
if(changedimensionifdeffacted!==undefined&&changedimensionifdeffacted!==null&&changedimensionifdeffacted!==" "){
  dimension=parseInt(changedimensionifdeffacted)
  config.dimension=parseInt(changedimensionifdeffacted)
  updatePORTEl();
  updateviewport()
}

if(spawn_if_killed!==undefined&&spawn_if_killed!==null&&spawn_if_killed!=="undefined"){
     let numbersprites=1
     if(spawnnumber!==undefined&&spawnnumber!==null&&spawnnumber!=="null"&&spawnnumber!==""){
       numbersprites=spawnnumber
     }else{
       numbersprites=1
     }

     for(let i=0;i<numbersprites;i++){
          let el= document.createElement('div')

     let ofss=1
     if(ofss!==undefined&&ofss!==null){
       ofss=spawningdistance*tileSize
     }else{
       ofss=1
     }
     let offsetXt=0
     let offsetYt=0
     if(spawningoffset!==undefined&&spawningoffset!==null){
     if (spawningoffset[0] !== undefined && spawningoffset[1] !== undefined && spawningoffset[0] !== null && spawningoffset[1] !== null && spawningoffset !== undefined && spawningoffset !== null) {
       if(spawningoffset[0]!==undefined){
  offsetXt = parseFloat(spawningoffset[0])*tileSize
       }if(spawningoffset[1]!==undefined){
  offsetYt = parseFloat(spawningoffset[1])*tileSize
       }
}
if(offsetXt==undefined&&offsetYt==undefined){offsetXt = 0
offsetYt = 0}else{
}}
     let x=(left+Math.floor(Math.random()*(ofss*2))-ofss)+offsetXt
     let y=(top+Math.floor(Math.random()*(ofss*2))-ofss)+offsetYt
     if(isNaN(x)){
       x=(left+Math.floor(Math.random()*(ofss*2))-ofss)
       y=(top+Math.floor(Math.random()*(ofss*2))-ofss)
if (isNaN(x)) {
  x = left
  y = top
}
     }

    let elm=parseInt(spawn_if_killed)
     el.className = `alltiles${TILES[elm][1]} tile1 sprite${TILES[elm][1]}`;
     el.style.backgroundImage = `url('${TILES[elm][2]}')`;
       el.style.left = x+"px"
       el.style.top = y+"px"
       el.style.zIndex="5"
       el.classList.add('SPRITE')

       el.style.width = tileSize - parseInt(el.style.width / 2) + "px"
       el.style.height = tileSize - parseInt(el.style.height / 2) + "px"
       el.style.transform=`scale(${TILES[elm][3]||1})`;

       document.querySelector('#Econtent').appendChild(el);
     }
}
const currentX = parseInt(tile.dataset.x)
const currentY = parseInt(tile.dataset.y)
const currentS = parseInt(tile.dataset.s)
setTimeout(function() {
  if (onece5 == 1) {
    if (finishproject == 1) {
      onece5 = 0;
      for (var i = 0; i < 2; i++) {
        const blocksToRemove = tileMap[dimension].filter(block =>
          parseInt(block[0]) === currentX &&
          parseInt(block[1]) === currentY &&
          parseInt(block[2]) === currentS
        );
        blocksToRemove.forEach(blockToRemove => {
          const indexToRemove = tileMap[dimension].indexOf(blockToRemove);
          tileMap[dimension].splice(indexToRemove, 1);
        });
   //     config.savedTileMap = tileMap;
        setTimeout(function() {
          onece5 = 1;
        }, 100);
      }
    }
  }
}, 300);
if(movetilesdeffacted!==undefined&&movetilesdeffacted!==null){
  movemap(movetilesdeffacted[1],movetilesdeffacted[2],movetilesdeffacted[0]);
}
if(despawn!==undefined&&despawnMS!==undefined||cantbedamaged!==1){
                    if (score1 == 1) {
                      score += 1
                    } else {
                      killed += 1;
                      config.killed+=1
                    }
}

                    tile.remove();
                    deletedtiles.push(tile);
                  }
                                      }
}
    const viewport = document.getElementById('viewport');
              let left = parseFloat(tile.style.left) || 0;
              let top = parseFloat(tile.style.top) || 0;
              if(!isNaN(parseFloat(tile.style.height))&&tile.style.height){
              let rdheight = (parseFloat(tile.style.height)/4) ;}
if (weird3dblockwall == null&&weird3dblockwall == undefined &&weird3dblockwall) {
  if (parseFloat(player.style.top) > top+rdheight){
    tile.style.zIndex="0"
  }else{
    tile.style.zIndex="10"
  }
}
if (randomteleporting!==undefined&&randomteleporting!==null&&randomteleporting!==""&&randomteleporting!=="undefined") {
  if(!tile.dataset.teleporting){
tile.dataset.teleporting=1
  }
  if(tile.dataset.teleporting==1){
  const [duration, xmin, xmax, ymin, ymax] = randomteleporting;
  // Random teleportation logic
  setInterval(() => {
    const newX = left+Math.random() * (xmax - xmin) + xmin;
    const newY = top+Math.random() * (ymax - ymin) + ymin;
    // Update tile position
    left=newX
    top=newY
    tile.dataset.teleporting=0
  }, duration);
}}
const currentX = parseInt(tile.dataset.x)
const currentY = parseInt(tile.dataset.y)
  if (!tile.dataset.buildedX) {
    tile.dataset.buildedX = left / tileSize 
  }
  if (!tile.dataset.buildedY) {
  tile.dataset.buildedY = top / tileSize
  }
              if (gravitypow !== undefined && gravitypow !== null) {
top+=parseInt(gravitypow);
tile.style.left = left + 'px';
tile.style.top = top + 'px';
}

var closestElement = null;
var closestDistance = Infinity;

Array.from(document.getElementsByClassName(collisionobject)).forEach(element => {
    var elementX = parseFloat(element.style.left) || 0;
    var elementY = parseFloat(element.style.top) || 0;
    var distance4 = Math.sqrt(Math.pow(elementX - left, 2) + Math.pow(elementY - top, 2));
    if (distance4 < closestDistance) {
        closestElement = element;
        closestDistance = distance4;
    }
});
 closestIndex = Array.from(document.getElementsByClassName(collisionobject)).indexOf(closestElement);
console.log(closestIndex)
if(despawnMS!==undefined&&despawnMS!==null&&despawnMS!==""){
  if (!tile.dataset.desapwning) {
  tile.dataset.desapwning = 1
  setTimeout(function(){
if (initialHp > 10) {
  deletedtiles.push(tile);
  tile.remove()
} else {
  KillThis()
}
  },parseInt(despawnMS))
  }
}
              if (despawn!==undefined&&despawn!==null&&despawn!=="") {
                if (!tile.dataset.despawn) {
                  tile.dataset.despawn = despawn
                }
                tile.dataset.despawn--;
                if (tile.dataset.despawn < 1) {
                  if(initialHp>10){
                  deletedtiles.push(tile);
                  tile.remove()
                  }else{
                    KillThis()
                  }
                }
              }
               if(spawn!==undefined&&spawn!==null&&spawn!==""){
    if (!tile.dataset.spawnduration) {
      tile.dataset.spawnduration = spawn[0];
    }
    if (!tile.dataset.currentdurationtime) {
      tile.dataset.currentdurationtime = spawn[0];
    }}
    if(spawn2!==undefined&&spawn2!==null&&spawn2!==""){
    if (!tile.dataset.spawnduration2) {
      tile.dataset.spawnduration2 = spawn2[0];
    }
    if (!tile.dataset.currentdurationtime2) {
      tile.dataset.currentdurationtime2 = spawn2[0];
    }}
    if(spawn3inside!==undefined&&spawn3inside!==null&&spawn3inside!==""){
    if (!tile.dataset.spawnduration3) {
      tile.dataset.spawnduration3 = spawn3inside[0];
    }
    if (!tile.dataset.currentdurationtime3) {
      tile.dataset.currentdurationtime3 = spawn3inside[0];
    }}
    if (document.getElementsByClassName(collisionobject).length > 0) {
        gototarget = document.getElementsByClassName(collisionobject)[closestIndex];
        targetToX = parseInt(gototarget.style.left) / tileSize;
        targetToY = parseInt(gototarget.style.top) / tileSize;
    }

if (spawn3inside !== undefined && spawn3inside !== null && spawn3inside !== "") {
  let duration = tile.dataset.spawnduration3
  let counting = tile.dataset.currentdurationtime3
  let element = spawn3inside[1]
  tile.dataset.currentdurationtime3--
  if (tile.dataset.currentdurationtime3 < 1) {
tile.dataset.currentdurationtime3 = duration
     let numbersprites=1

     for(let i=0;i<numbersprites;i++){
     let el= document.createElement('div')

     let ofss=1
     if(ofss!==undefined&&ofss!==null){
       ofss=1
     }else{
       ofss=1
     }
     let offsetXt=0
     let offsetYt=0
     if(spawningoffset!==undefined&&spawningoffset!==null){
     if (spawningoffset[0] !== undefined && spawningoffset[1] !== undefined && spawningoffset[0] !== null && spawningoffset[1] !== null && spawningoffset !== undefined && spawningoffset !== null) {
       if(spawningoffset[0]!==undefined){
  offsetXt = parseFloat(spawningoffset[0])*tileSize
       }if(spawningoffset[1]!==undefined){
  offsetYt = parseFloat(spawningoffset[1])*tileSize
       }
}
if(offsetXt==undefined&&offsetYt==undefined){offsetXt = 0
offsetYt = 0}else{
}}
     let x=(left+Math.floor(Math.random()*(ofss*2))-ofss)+offsetXt
     let y=(top+Math.floor(Math.random()*(ofss*2))-ofss)+offsetYt
     if(isNaN(x)){
       x=(left+Math.floor(Math.random()*(ofss*2))-ofss)
       y=(top+Math.floor(Math.random()*(ofss*2))-ofss)
if (isNaN(x)) {
  x = left
  y = top
}
     }

    let elm=parseInt(element)
     el.className = `alltiles${TILES[elm][1]} tile1 sprite${TILES[elm][1]}`;
     el.style.backgroundImage = `url('${TILES[elm][2]}')`;
       el.style.left = x+"px"
       el.style.top = y+"px"
       el.style.zIndex="5"
       el.classList.add('SPRITE')
       el.style.transform=`scale(${TILES[elm][3]||1})`;
       // tile.style.willChange = 'transform';
       el.style.width = tileSize - parseInt(el.style.width / 2) + "px"
       el.style.height = tileSize - parseInt(el.style.height / 2) + "px"
       //alert(TILES[elm][1]+' '+TILES[elm][2])
       document.querySelector('#Econtent').appendChild(el);
     }
  }
}
if (spawn2 !== undefined && spawn2 !== null && spawn2 !== "") {
  let duration = tile.dataset.spawnduration2
  let counting = tile.dataset.currentdurationtime2
  let element = spawn2[1]
  tile.dataset.currentdurationtime2--
  if (tile.dataset.currentdurationtime2 < 1) {
tile.dataset.currentdurationtime2 = duration
     let numbersprites=1

     if(spawnnumber!==undefined&&spawnnumber!==null&&spawnnumber!=="null"&&spawnnumber!==""){
       numbersprites=spawnnumber
     }else{
       numbersprites=1
     }
     for(let i=0;i<numbersprites;i++){
     let el= document.createElement('div')
//     alert("spawned")
     let ofss=1
     if(ofss!==undefined&&ofss!==null){
       ofss=spawningdistance*tileSize
     }else{
       ofss=1
     }
     let offsetXt=0
     let offsetYt=0
     if(spawningoffset!==undefined&&spawningoffset!==null){
     if (spawningoffset[0] !== undefined && spawningoffset[1] !== undefined && spawningoffset[0] !== null && spawningoffset[1] !== null && spawningoffset !== undefined && spawningoffset !== null) {
       if(spawningoffset[0]!==undefined){
  offsetXt = parseFloat(spawningoffset[0])*tileSize
       }if(spawningoffset[1]!==undefined){
  offsetYt = parseFloat(spawningoffset[1])*tileSize
       }
}
if(offsetXt==undefined&&offsetYt==undefined){offsetXt = 0
offsetYt = 0}else{
}}
     let x=(left+Math.floor(Math.random()*(ofss*2))-ofss)+offsetXt
     let y=(top+Math.floor(Math.random()*(ofss*2))-ofss)+offsetYt
     if(isNaN(x)){
       x=(left+Math.floor(Math.random()*(ofss*2))-ofss)
       y=(top+Math.floor(Math.random()*(ofss*2))-ofss)
if (isNaN(x)) {
  x = left
  y = top
}
     }
//alert(x+" "+y+" "+left)
    let elm=parseInt(element)
     el.className = `alltiles${TILES[elm][1]} tile1 sprite${TILES[elm][1]}`;
     el.style.backgroundImage = `url('${TILES[elm][2]}')`;
       el.style.left = x+"px"
       el.style.top = y+"px"
       el.style.zIndex="5"
       tile.style.transform=`scale(${TILES[elm][3]||1})`;
       el.classList.add('SPRITE')
       el.style.transform=`scale(${TILES[elm][3]||1})`;
       // tile.style.willChange = 'transform';
       el.style.width = tileSize - parseInt(el.style.width / 2) + "px"
       el.style.height = tileSize - parseInt(el.style.height / 2) + "px"
       //alert(TILES[elm][1]+' '+TILES[elm][2])
       document.querySelector('#Econtent').appendChild(el);
     }
  }
}
if(!tile.delaylagreduce&&showindicator === 1||showindicator === "1"){
  tile.delaylagreduce=3
  tile.delaylagreduce2=2
}
    if (showindicator === 1||showindicator === "1") {
      tile.delaylagreduce-=1

        if(tile.delaylagreduce<1){
        const playerHPQ = (tile.dataset.hp);
        tile.delaylagreduce2-=1
                if (tile.delaylagreduce2 < 1) {
          document.querySelectorAll('.hpindicator').forEach(Document => {
            Document.remove()
          })
          tile.delaylagreduce2=2
        }

        const HPqIndicator = document.createElement('div');
        HPqIndicator.classList.add('wskaźnik-hp');
        HPqIndicator.textContent = `HP: ${playerHPQ}`;
        HPqIndicator.style.width="35px"
        HPqIndicator.style.fontSize="10px"
        HPqIndicator.style.position="absolute"
        HPqIndicator.style.top="-20px"
        HPqIndicator.transform='translate(-300px,0)'
        HPqIndicator.style.color="white"
        HPqIndicator.style.background="black"
        HPqIndicator.className="hpindicator"

        const leftPozycja = parseInt(tile.style.left) + 'px';
        const topPozycja = (parseInt(tile.style.top) - 20) + 'px';
        tile.appendChild(HPqIndicator);
        tile.delaylagreduce=10
    }}
 if(spawn!==undefined&&spawn!==null&&spawn!==""){
   let duration = tile.dataset.spawnduration
   let counting = tile.dataset.currentdurationtime 
   let element = spawn[1]
   tile.dataset.currentdurationtime --
   if(tile.dataset.currentdurationtime  < 1){
     tile.dataset.currentdurationtime = duration
     let numbersprites=1
     if(spawnnumber!==undefined&&spawnnumber!==null&&spawnnumber!=="null"&&spawnnumber!==""){
       numbersprites=spawnnumber
     }else{
       numbersprites=1
     }
     for(let i=0;i<numbersprites;i++){
     let el= document.createElement('div')
//     alert("spawned")
     let ofss=1
     if(ofss!==undefined&&ofss!==null){
       ofss=spawningdistance*tileSize
     }else{
       ofss=1
     }
     let offsetXt=0
     let offsetYt=0
     if(spawningoffset!==undefined&&spawningoffset!==null){
     if (spawningoffset[0] !== undefined && spawningoffset[1] !== undefined && spawningoffset[0] !== null && spawningoffset[1] !== null && spawningoffset !== undefined && spawningoffset !== null) {
       if(spawningoffset[0]!==undefined){
  offsetXt = parseFloat(spawningoffset[0])*tileSize
       }if(spawningoffset[1]!==undefined){
  offsetYt = parseFloat(spawningoffset[1])*tileSize
       }
}
if(offsetXt==undefined&&offsetYt==undefined){offsetXt = 0
offsetYt = 0}else{
}}
     let x=(left+Math.floor(Math.random()*(ofss*2))-ofss)+offsetXt
     let y=(top+Math.floor(Math.random()*(ofss*2))-ofss)+offsetYt
     if(isNaN(x)){
       x=(left+Math.floor(Math.random()*(ofss*2))-ofss)
       y=(top+Math.floor(Math.random()*(ofss*2))-ofss)
if (isNaN(x)) {
  x = left
  y = top
}
     }
//alert(x+" "+y+" "+left)
    let elm=parseInt(element)
     el.className = `alltiles${TILES[elm][1]} tile1 sprite${TILES[elm][1]}`;
     el.style.backgroundImage = `url('${TILES[elm][2]}')`;
       el.style.left = x+"px"
       el.style.top = y+"px"
       el.style.transform=`scale(${TILES[element][3]||1})`;
       el.style.zIndex="5"
       el.classList.add('SPRITE')
       // tile.style.willChange = 'transform';
       el.style.width = tileSize - parseInt(el.style.width / 2) + "px"
       el.style.height = tileSize - parseInt(el.style.height / 2) + "px"
       //alert(TILES[elm][1]+' '+TILES[elm][2])
       document.querySelector('#Econtent').appendChild(el);
     }}
   }
if(anableshootingattackforentities==1){
        //  alert("shooting anabled")
          let gototarget = findClosestProjetitle(tile, collisionobject);
          if(gototarget){
        //  alert("")
          shootingTargettargetToX = parseInt(gototarget.style.left) / tileSize;
          shootingTargettargetToY = parseInt(gototarget.style.top) / tileSize;
        }}
//console.log(closestIndex + ' ' + JSON.stringify(gototarget));
         // alert(collisionobject)
          if (gototarget) {
            //alert(targetToX)
          //  console.log(collisionobject)
          } else {
          }
          const tileRect = tile.getBoundingClientRect();
          const viewportRect = viewport.getBoundingClientRect();
          if (!tile.dataset.hp) {
            tile.dataset.hp = initialHp;
          }
                if (collision === 0) {
                    // Change tile class to avoid collision
                    tile.classList.remove('tile');
                    tile.classList.add('tile1');
                   /* if(customhitboxplayercollision!==undefined&&customhitboxplayercollision!==null &&customhitboxplayercollision){
                    tile.dataset.collisionsize= parseFloat(customhitboxplayercollision)
                    }*/
                }
                let distanceToProjectile=20
                if(anableshootingattackforentities==1){
                   distanceToProjectile = Math.sqrt((shootingTargettargetToX - left / tileSize) ** 2 + (shootingTargettargetToY - top / tileSize) ** 2);
                }
                let distanceToPlayer = Math.sqrt((targetToX - left / tileSize) ** 2 + (targetToY - top / tileSize) ** 2);
if(otherentitycollision!==undefined&&otherentitycollision!==null&&otherentitycollision!==NaN&&otherentitycollision!==""){
for (let tileId in tileConfig) {
  let tiles = document.querySelectorAll(`.${tileId}`);
  tiles.forEach((tiled) => {
    let viewport2 = document.getElementById('viewport');
    const tileRect = tiled.getBoundingClientRect();
    const viewportRect = viewport2.getBoundingClientRect();
    if (
      tileRect.top + 2 * tileSize >= viewportRect.top &&
      tileRect.left + 2 * tileSize >= viewportRect.left &&
      tileRect.bottom - 2 * tileSize <= viewportRect.bottom &&
      tileRect.right - 2 * tileSize <= viewportRect.right
    ) {
      let elm = parseInt(tiled.dataset.s)
      let snum = TILES[elm][1]
      if (snum == parseInt(otherentitycollision)) {
        let targetDX= parseInt(tiled.style.left)/tileSize
        let targetDY= parseInt(tiled.style.left)/tileSize
        let distanceToElement = Math.sqrt((targetDX - left / tileSize) ** 2 + (targetDY - top / tileSize) ** 2);
        if(distanceToElement<1.5){
          KillThis()
        }
      }
    }
  })
}
}
if(lookatobject==1){
const playerCenterXz = targetToX 
const playerCenterYz = targetToY
const deltaXz = playerCenterXz - (parseInt(tile.style.left)/tileSize);
const deltaYz = playerCenterYz - (parseInt(tile.style.top)/tileSize);

let anglez = Math.atan2(deltaYz, deltaXz) * (180 / Math.PI);
tile.style.transform=`rotate(${anglez}deg)`
}
if (ifvariablekillthiswhenshown !== undefined && ifvariablekillthiswhenshown !== null) {
  let name = ifvariablekillthiswhenshown[0];
  let operator = ifvariablekillthiswhenshown[1];
  let value = parseInt(ifvariablekillthiswhenshown[2]);
  let operators = {
    "=": (a, b) => a == b,
    "==": (a, b) => a == b,
    "===": (a, b) => a === b,
    "!=": (a, b) => a !== b,
    "!==": (a, b) => a !== b,
    "<": (a, b) => a < b,
    ">": (a, b) => a > b,
    "<=": (a, b) => a <= b,
    ">=": (a, b) => a >= b
  };
  if (Vables.hasOwnProperty(name) && operators[operator](Vables[name], value)) {
    KillThis();
  }
}
if(oldGravity!==null&&oldGravity!==undefined&&distanceToPlayer > dist&&distanceToPlayer < dist+3){
  
  gravity=oldGravity
  console.log(oldGravity)
}
if(customhitboxplayercollision!==undefined&&customhitboxplayercollision!==null&&customhitboxplayercollision){
  dist=customhitboxplayercollision
}
                if(distanceToPlayer <= dist ){

                  
if( hideshowplayer==1){
  document.getElementById('playerskin').style.opacity="1"
}
if (hideshowplayer == 0) {
  document.getElementById('playerskin').style.opacity = "0"
}
                  if(collisionEVAL!==null&&collisionEVAL!==undefined&&collisionEVAL){
eval(collisionEVAL)
                  }
if (BLOCKTYPE == 'ladder') {
  movePlayer(0, -(config.gravitypower*gravityvelocity||0.10))
   canJUMP=1
}
if (BLOCKTYPE == 'water') {
 
  canJUMP = 1
}
if (BLOCKTYPE == 'float') {
  movePlayer(0, -(config.gravitypower * gravityvelocity || 0.10))
  
if(oldGravity==null||oldGravity==undefined){oldGravity=gravity}
gravity=0
}
if (collisionfilter !== null && collisionfilter !== undefined) {
  //alert(collisionfilter)
  //   let [x1, y1, x2, y2]=collisionfilter
  console.log(config.screenfilter)
  //  config.screenfilter=[x1, y1, x2, y2]
  config.screenfilter = collisionfilter
}
if (ifvariablekillthiswhencollision !== undefined && ifvariablekillthiswhencollision !== null) {
  let name = ifvariablekillthiswhencollision[0];
  let operator = ifvariablekillthiswhencollision[1];
  let value = parseInt(ifvariablekillthiswhencollision[2]);
  let operators = {
    "=": (a, b) => a == b,
    "==": (a, b) => a == b,
    "===": (a, b) => a === b,
    "!=": (a, b) => a !== b,
    "!==": (a, b) => a !== b,
    "<": (a, b) => a < b,
    ">": (a, b) => a > b,
    "<=": (a, b) => a <= b,
    ">=": (a, b) => a >= b
  };
  if (Vables.hasOwnProperty(name) && operators[operator](Vables[name], value)) {
    KillThis();
  }
}
if(changeplayerdamage!==undefined&&changeplayerdamage!==null&&changeplayerdamage!==' '){
  config.playerdamage=parseInt(changeplayerdamage)
}
  if(collisionchangerandomdimension!==undefined&&collisionchangerandomdimension!==null){
  const randomDimension = Math.floor(Math.random() * (collisionchangerandomdimension[1] - collisionchangerandomdimension[0] + 1)) + collisionchangerandomdimension[0];
  if (randomDimension !== undefined && randomDimension !== null && randomDimension !== "undefined") {
    dimension = parseInt(randomDimension);
    config.dimension = parseInt(randomDimension);
    updatePORTEl();
    updateViewport();
  }}
if(collisionchangedimension!==undefined &&collisionchangedimension!==null&&collisionchangedimension!=="undefined"){
  dimension=parseInt(collisionchangedimension)
  config.dimension=parseInt(collisionchangedimension)
  updatePORTEl();
  updateViewport()
}
if(resetkills==1){
  killed=0
  config.killed=0
}
/*

*-----------------------------------------*
                Distance Player
*-----------------------------------------*

*/
if(ifentityexistonVPmovetilesandthiskill!==undefined&&ifentityexistonVPmovetilesandthiskill!==null&&ifentityexistonVPmovetilesandthiskill!=="undefined"&&ifentityexistonVPmovetilesandthiskill!==null){
  let output1=0
  for (let tileId in tileConfig) {
    let tiles = document.querySelectorAll(`.${tileId}`);
  tiles.forEach((tiled) => {
    let viewport2 = document.getElementById('viewport');
    const tileRect = tiled.getBoundingClientRect();
const viewportRect = viewport2.getBoundingClientRect();
              if (
            tileRect.top + 2 * tileSize >= viewportRect.top &&
            tileRect.left + 2 * tileSize >= viewportRect.left &&
            tileRect.bottom - 2 * tileSize <= viewportRect.bottom &&
            tileRect.right - 2 * tileSize <= viewportRect.right
          ) {
            let elm=parseInt(tiled.dataset.s)
            let snum=TILES[elm][1]
if(snum==parseInt(ifentityexistonVPmovetilesandthiskill)){
  output1=1
  KillThis()
}
          } 
  })
}
}
if(changeplayertexture==1){
  if(playertextureleft!==undefined){
    config.folder.texture.player[1]=playertextureleft
  }
  if (playertextureright!==undefined) {
config.folder.texture.player[2]=playertextureright
}
if (playertexturedown!==undefined) {
config.folder.texture.player[6]=playertexturedown
}
if (playertextureup!==undefined) {
config.folder.texture.player[3]=playertextureup
}
/*if(playertexturestayup!==undefined){
}*/
if (playertexturestaydown !== undefined) {
config.folder.texture.player[7]=playertexturestaydown
}
if (playerstayup !== undefined) {
  config.folder.texture.player[9] = playerstayup
  
}
if (playertexturestayleft !== undefined) {
config.folder.texture.player[5]=playertexturestayleft
}
if (playertexturestayright !== undefined) {
config.folder.texture.player[4]=playertexturestayright
}
if(playertexturedefault !==undefined){
playerskin=playertexturedefault
}
}
if(hideifevent!==undefined&&hideifevent!==null&&hideifevent!=="undefined"&&hideifevent!==""){
  document.getElementById(hideifevent).style.display="none"
}
if (showifevent !== undefined && showifevent !== null && showifevent !== "undefined" && showifevent !== "" ) {
  document.getElementById(showifevent).style.display = "block"
}
if(parseInt(changebackground)==1){
  let texture=backgroundtexture
   currentbase64img=TILES[texture][2]
   bgimg = TILES[texture][2]
config.bg = TILES[texture][2]
                      document.getElementById('content').style.backgroundImage = `url('${TILES[texture][2]}')`
                    if (!('stickybg1' in config)) {

                      config['stickybg1'] = 0;
                    } else {
                    }
                    if (config.stickybg1 == 0) {
                      document.getElementById('content').style.backgroundImage = `url('${TILES[texture][2]}')`
                      document.getElementById('content2').style.backgroundImage = ``
                      bgimg = TILES[texture][2]
                      config.bg = TILES[texture][2]
                    } else {
                      document.getElementById('content2').style.backgroundImage = `url('${TILES[texture][2]}')`
                      document.getElementById('content').style.backgroundImage = ``
                      bgimg = TILES[texture][2]
                      config.bg = TILES[texture][2]
                    }
}
                  if (dialogueends_killedmoveandthisremove !== undefined && dialogueends_killedmoveandthisremove !== null && dialogueends_killedmoveandthisremove[0] <= killed) {
  movemap(dialogueends_killedmoveandthisremove[2], dialogueends_killedmoveandthisremove[3], dialogueends_killedmoveandthisremove[1]);
  deletedtiles.push(tile)
  tile.remove()
if (changeloopmusicwhendialogueends !== undefined && changeloopmusicwhendialogueends !== null) {
  if (audioInstance !== undefined) {

    audioInstance.pause();
    audioInstance.currentTime = 0;
    audioInstance = null;
  }
  if (changeloopmusicwhendialogueends !== '') {
    const base64Wav = changeloopmusicwhendialogueends;
    currentbase64 = changeloopmusicwhendialogueends

    audioInstance = new Audio();
    audioInstance.src = base64Wav;
    audioInstance.setAttribute('preload', 'auto');

    document.body.appendChild(audioInstance);

    audioInstance.addEventListener('canplay', function() {

      audioInstance.play().catch(function(error) {
        console.log("Error cannot play sound", error);
      });
    });
    audioInstance.loop = true;
    toonce = 0;
  }
}
  removefromtilemap()
}
                  if (!tile.dataset.dialogue&&NPCdialogue!==undefined &&NPCdialogue!==null&& NPCdialogue!==""&& NPCdialogue!=="null") {
  tile.dataset.dialogue = 0
}
if(dialiguesounds!==undefined&&dialiguesounds!==null){
  currentsoundformessage=dialiguesounds
}
if(tile.dataset.dialogue == 0&&NPCdialogue!==undefined &&NPCdialogue!==null&& NPCdialogue!==""&& NPCdialogue!=="null"){
  tile.dataset.dialogue = 1
  var dialog =NPCdialogue
  pausemove=1
  for (var i = 0; i < dialog.length; i++) {
  message(dialog[i])
  }
}
if(!tile.dataset.ONESPAWN&&NPCdialogueends_spawn !== "" && NPCdialogueends_spawn !== "null" && NPCdialogueends_spawn !== undefined && NPCdialogueends_spawn !== null){
  tile.dataset.ONESPAWN=0
}
if (NPCdialogueends_spawn !== "" && NPCdialogueends_spawn !== "null" && NPCdialogueends_spawn !== undefined && NPCdialogueends_spawn !== null&&tile.dataset.ONESPAWN==0){
  if (NPCdialogueends_spawn !== "" && NPCdialogueends_spawn !== "null" && NPCdialogueends_spawn !== undefined && NPCdialogueends_spawn !== null && indialogue == 0&&tile.dataset.ONESPAWN==0) {
    tile.dataset.ONESPAWN=1
deletedtiles.push(tile)
tile.remove()
if (changeloopmusicwhendialogueends !== undefined && changeloopmusicwhendialogueends !== null) {
  if (audioInstance !== undefined) {

    audioInstance.pause();
    audioInstance.currentTime = 0;
    audioInstance = null;
  }
  if (changeloopmusicwhendialogueends !== '') {
    const base64Wav = changeloopmusicwhendialogueends;
    currentbase64 = changeloopmusicwhendialogueends
    audioInstance = new Audio();
    audioInstance.src = base64Wav;
    audioInstance.setAttribute('preload', 'auto');
    document.body.appendChild(audioInstance);
    audioInstance.addEventListener('canplay', function() {
      audioInstance.play().catch(function(error) {
        console.log("fatal err", error);
      });
    });
    audioInstance.loop = true;
    toonce = 0;
  }
}
    let element = NPCdialogueends_spawn
    let el = document.createElement('div')
    let x = left
    let y = top
    let elm = parseInt(element)
    el.className = `alltiles${TILES[elm][1]} tile1 sprite${TILES[elm][1]}`;
    el.style.backgroundImage = `url('${TILES[elm][2]}')`;
    el.style.zIndex = "5"
    el.style.left = x + "px"
    el.style.top = y + "px"
    el.style.transform=`scale(${TILES[element][3]||1})`;
    el.classList.add('SPRITE')
    // tile.style.willChange = 'transform';
    el.style.width = tileSize - parseInt(el.style.width / 2) + "px"
    el.style.height = tileSize - parseInt(el.style.height / 2) + "px"
    //alert(TILES[elm][1]+' '+TILES[elm][2])
    document.querySelector('#Econtent').appendChild(el);
  }
}
if (NPCdialogueends_remove == 1 && indialogue == 0) {
  tile.remove()
}
if(!tile.dataset.once0C2){
  tile.dataset.once0C2=0
}
if (!tile.dataset.once0C22) {
  tile.dataset.once0C22 = 0
}
if (collisiontexture !== null && collisiontexture !== undefined && tile.dataset.once0C2== 0) {
  tile.dataset.once0C2 = 1;
  if(tile.dataset.once0C22 == 0){
  const previousBackground = tile.style.backgroundImage;
  tile.dataset.once0C22 = previousBackground;
  }
  tile.style.backgroundImage = `url('${collisiontexture}')`;
setTimeout(function() {
  if (distanceToPlayer <= dist/2) {
  tile.style.backgroundImage = `url('${collisiontexture}')`;
tile.dataset.once0C2 = 0;
}
setTimeout(function() {
  tile.style.backgroundSize = "100%";
tile.style.backgroundImage = tile.dataset.once0C22;
tile.style.backgroundSize = "100%";
tile.dataset.once0C2 = 0;
},2500)
},2500)
}
// config.projetitlecfig= {"timelife":40,"nomove":0,"speed":1.5,"cooldownDuration":500};
if(changeVariablecollisionevent!==undefined&& changeVariablecollisionevent!==null){
  if(changeVariablecollisionevent[0]){
    if(changeVariablecollisionevent[1]){
let name =changeVariablecollisionevent[0]
let value =parseInt(changeVariablecollisionevent[1])
//alert(name+" "+value)
   Vables[name] = eval(value);
  // alert(JSON.stringify(Vables))
if (!V.includes(name)) {
  V.push(value);
}
    }
  }
}
                  if(collisioneventprojectilespeed!==null&&collisioneventprojectilespeed!==undefined){
                   config.projetitlecfig.speed= parseInt(collisioneventprojectilespeed)
                  }
if (collisioneventprojectilesize !== null && collisioneventprojectilesize !== undefined) {
  config.projetitlecfig.scale = parseInt(collisioneventprojectilesize)
}
                  if (collisioneventprojectileduration!== null && collisioneventprojectileduration !== undefined) {
                    config.projetitlecfig.duration= parseInt(collisioneventprojectileduration)
                  }
                  if(collisioneventprojectilelifetime!==null&&collisioneventprojectilelifetime!==undefined){
                    config.projetitlecfig.timelife= parseInt(collisioneventprojectilelifetime)
                  }
                  if(shiftFix==0){
                  if(abilities!==undefined&&abilities!==null){
                    shiftFix=1
                    if(abilities[0]==''){
                    }else if (abilities[0] == 'maxhp') {
                    if (abilities[2] == '+') {
                      config.HpBarConfiguration.maxHp =parseInt(config.HpBarConfiguration.maxHp)+ parseInt(abilities[1])
                     // alert(config.HpBarConfiguration.maxHp)
                    } else if (abilities[2] == '-') {
                      config.HpBarConfiguration.maxHp =parseInt(config.HpBarConfiguration.maxHp)- parseInt(abilities[1])
                    } else {
                      config.HpBarConfiguration.maxHp = abilities[1]
                    }
                    }else if (abilities[0] == 'airjump') {
                      config.airjump = abilities[1]
                    } else if (abilities[0] == 'hp') {
                      if(abilities[2]=='+'){
                        config.HpBarConfiguration.numberHp=parseInt(config.HpBarConfiguration.numberHp) + parseFloat(abilities[1])
                      //  alert(config.HpBarConfiguration.numberHp)
                      }else if (abilities[2] == '-') {
                      config.HpBarConfiguration.numberHp=parseInt(config.HpBarConfiguration.numberHp) - parseInt(abilities[1])
                      }else{
                    config.HpBarConfiguration.numberHp=parseInt(abilities[1])
                      }
                   //   alert(config.HpBarConfiguration.numberHp)
                    } else if (abilities[0] == 'shootingdelay') {
                    } else if (abilities[0] == 'shoot') {
                    config.playershoots=abilities[1]
                    }}
                    setTimeout(function(){
                      shiftFix=0
                    },3000)
                  }
                if(spawnpoint==1){
                  config.oldmusic=currentbase64
                  config.savedTileMap=tileMap;
                  config.olddimension=dimension
                  config.dimension=dimension
                  config.oldbg=config.bg
                  config.spawnX=left / tileSize
                  config.spawnY=(top / tileSize)-1
                }
                if (teleportBy !==undefined&& teleportBy!==null&& teleportBy!==""&& teleportBy!==0) {
                  movePlayer(parseInt(teleportBy[1]),parseInt(teleportBy[0]))
                  requestAnimationFrame(updateViewport)
                }
if (changeLoopMusic !== undefined && changeLoopMusic !== null) {
  if(base64WavY!==changeLoopMusic){
  base64WavY = changeLoopMusic;
  
    if (audioInstance) {
        audioInstance.pause();
        audioInstance.currentTime = 0;
     //   audioInstance = null;
    }
    if (changeLoopMusic !== '') {
        
        currentbase64=changeLoopMusic

     //   audioInstance = new Audio();
        audioInstance.src = base64WavY;
        audioInstance.setAttribute('preload', 'auto');

        document.body.appendChild(audioInstance);

        audioInstance.addEventListener('canplay', function() {

            audioInstance.play().catch(function(error) {
                console.log("fatal err", error);
            });
        });
        audioInstance.loop = true;
        toonce = 0;
    }}
} else if (changeLoopMusicMain == 1) {
  if(currentbase64!==config.music&&currentbase64!==''){
  if(base64WavY!==config.music){
  base64WavY = config.music;
  
    if (audioInstance) {
        audioInstance.pause();
        audioInstance.currentTime = 0;
     //   audioInstance = null;
    }
    if (config.music !== '') {
        
        currentbase64=changeLoopMusic

     //   audioInstance = new Audio();
        audioInstance.src = base64WavY;
        audioInstance.setAttribute('preload', 'auto');

        document.body.appendChild(audioInstance);

        audioInstance.addEventListener('canplay', function() {

            audioInstance.play().catch(function(error) {
                console.log("fatal err", error);
            });
        });
        audioInstance.loop = true;
        toonce = 0;
    }}
}else{
//  alert(currentbase64)
}}
                }
if(collectable!==1&&collectable!==undefined){
    }else{
      if (collecting === 1 && distanceToPlayer <= dist*2) {
const currentX = parseInt(tile.dataset.x)
const currentY = parseInt(tile.dataset.y)
const currentS = parseInt(tile.dataset.s)

setTimeout(function() {
  if (onece5 == 1) {
    if (finishproject == 1) {
      onece5 = 0;
      for (var i = 0; i < 2; i++) {
        const blocksToRemove = tileMap[dimension].filter(block =>
          parseInt(block[0]) === currentX &&
          parseInt(block[1]) === currentY &&
          parseInt(block[2]) === currentS
        );
        blocksToRemove.forEach(blockToRemove => {
          const indexToRemove = tileMap[dimension].indexOf(blockToRemove);
          tileMap[dimension].splice(indexToRemove, 1);
        });

        setTimeout(function() {
          onece5 = 1;
        }, 100);
      }
    }
  }
}, 300);
      setTimeout(function() {
        deletedtiles.push(tile);
tile.remove();
      }, 100)
      }
    }
                if(collectable!==1){
                  if(attack === 1 && distanceToPlayer <= dist && anableshootingattackforentities !==1 ){
if(cantbedamaged!==1||cantbedamaged==undefined||cantbedamaged==null){
 KillThis()
}
                  } else  if (attack === 1 &&  distanceToProjectile <= 1) {

                  if(cantbedamaged!==1||cantbedamaged==undefined||cantbedamaged==null){
                    KillThis()
}}
                }else{
                }
                if (!(tile.dataset.bugfix1)) {
                  tile.dataset.bugfix1 = 0
                }
tile.dataset.bugfix1++
          if(collisionwithotherblocks==1){
          let power=1
let tiles3 = document.querySelectorAll('.tile5 , .tile');
for (let tile2 of tiles3) {
          const rect1 = tile.getBoundingClientRect();
          const rect2 = tile2.getBoundingClientRect();
          const wallThickness = 2;
          if (rect1.bottom > rect2.top + 5 &&
            rect1.top < rect2.bottom - 10 &&
            rect1.right + 5 > rect2.left + 5 &&
            rect1.left < rect2.right - 5) {
          } else {
          }
          if (rect1.top < rect2.bottom + 3 && rect1.bottom > rect2.bottom + 3 && rect1.right > rect2.left && rect1.left < rect2.right) {
            top +=power * speed;
          }
          if (rect1.left +3< rect2.right + wallThickness && rect1.right > rect2.right && rect1.bottom > rect2.top  && rect1.top < rect2.bottom ) {
            left += power*speed;
          }
          if (
              rect1.right > rect2.left - 3 &&
              rect1.left < rect2.left &&
              rect1.bottom > rect2.top &&
              rect1.top < rect2.bottom
            ) {
            left -= power * speed * 1.2;
          }
if (rect1.bottom +6 > rect2.top - wallThickness && rect1.top < rect2.top -15&& rect1.right +2> rect2.left + wallThickness && rect1.left -2< rect2.right - wallThickness) {
}else{
}
          if (rect1.bottom +3 > rect2.top - wallThickness && rect1.top+6 < rect2.top -5&& rect1.right +2> rect2.left + wallThickness && rect1.left -2< rect2.right - wallThickness) {
if(gravity==0){
            top -= power*speed}else{
              top -= power-0.10
            }
//VelocityY = -0.2;
           // console.log("ok")
          } else {
          }
          if (rect1.bottom + 1 > rect2.top - wallThickness && rect1.top < rect2.top && rect1.right > rect2.left + wallThickness && rect1.left < rect2.right - wallThickness) {
          } else {
            Topcol = 0;
          }
       /*  if (player.x < rect2.x && player.y + 55 > rect2.y && player.y < rect2.y + 55) {
            rect2.x = player.x - 50;
          }*/
          if (rect1.bottom + 5 >= rect2.top &&
            rect1.top < rect2.bottom &&
            rect1.right > rect2.left &&
            rect1.left < rect2.right) {
            collide = 1;
            cav = 0
          } else {
            collide = 0;
          }
        }
          }
          let vi2=0

          if(vi==1){
            const offset = 700
if (
    tileRect.top + 2 * tileSize + offset >= viewportRect.top &&
    tileRect.left + 2 * tileSize + offset >= viewportRect.left &&
    tileRect.bottom - 2 * tileSize - offset <= viewportRect.bottom &&
    tileRect.right - 2 * tileSize - offset <= viewportRect.right
) {

} else {
tile.remove()
}
          if (
            tileRect.top+2*tileSize >= viewportRect.top &&
            tileRect.left +2*tileSize  >= viewportRect.left&&
            tileRect.bottom-2*tileSize <= viewportRect.bottom &&
            tileRect.right-2*tileSize <= viewportRect.right
          ) {
            vi2=0
          }else{
            vi2=1
            tile.dataset.bugfix1=0
            if (tile.dataset.dialogue) {
  tile.dataset.dialogue = 0
}
          }
          }
          if(vi2==0){

            if (!tile.dataset.direction) {
                tile.dataset.direction = Math.random() * 360
            }
            const directionInRadians = (parseFloat(tile.dataset.direction) * Math.PI) / 180;

if(detectanabled==1){
  tile.classList.add('detect')
}
function hasCollision(class1, class2) {
    const elements1 = document.querySelectorAll(`.${class1}`);
    const elements2 = document.querySelectorAll(`${class2}`);
    for (const element1 of elements1) {
        const rect1 = element1.getBoundingClientRect();
        for (const element2 of elements2) {
            const rect2 = element2.getBoundingClientRect();
            if (
                rect1.bottom >= rect2.top &&
                rect1.top <= rect2.bottom &&
                rect1.right >= rect2.left &&
                rect1.left <= rect2.right
            ) {
                return true; // Collision detected
            }
        }
    }
    return false; // No collision found
}
/*
if(hasCollision('detect',collisionobject)){
  alert("")
}
*/
if(tile.dataset.bugfix1>5){
            // Calculate distance using Pythagorean theorem
            // Initialize HP if not already set
if(hurt==1){
  tile.classList.add('hurtblock');
}
            // Check if the tile is within the specified area
            let minimum=0
            if (mindistance !== undefined) {
   minimum = parseInt(mindistance) || 0
} else {
   minimum = 0
}
            if (isWithinArea(left / tileSize, top / tileSize, area)) {
                if (movementType === 'follow' && distanceToPlayer <= distance&& distanceToPlayer >= minimum|| distanceToPlayer >= reversedistance && reversedistance!==undefined&&reversedistance!==null&&reversedistance!=="null") {

if (getPlayerPositionRelativeToTile(tile,parseFloat(tile.style.left)/ tileSize2,parseFloat(tile.style.top)/ tileSize2)&&moveonlywhenplayerlooking==1&&moveonlywhenplayerlookingaway!==1) {
left += Math.cos(directionInRadians) * speed;
top += Math.sin(directionInRadians) * speed;
} else if(moveonlywhenplayerlookingaway==1&&moveonlywhenplayerlooking!==1&&!getPlayerPositionRelativeToTile(tile,parseFloat(tile.style.left)/ tileSize2,parseFloat(tile.style.top)/ tileSize2)){
  left += Math.cos(directionInRadians) * speed;
top += Math.sin(directionInRadians) * speed;
}else if(moveonlywhenplayerlooking!==1&&moveonlywhenplayerlookingaway!==1){
left += Math.cos(directionInRadians) * speed;
top += Math.sin(directionInRadians) * speed;
}
                } else if (movementType === 'avoid' && distanceToPlayer <= distance&& distanceToPlayer >= minimum||distanceToPlayer >= reversedistance && reversedistance!==undefined&&reversedistance!==null&&reversedistance!=="null") {
                    //  avoiding the player
if (getPlayerPositionRelativeToTile(tile, parseFloat(tile.style.left) / tileSize2, parseFloat(tile.style.top) / tileSize2) && moveonlywhenplayerlooking == 1 && moveonlywhenplayerlookingaway !== 1) {
  left -= Math.cos(directionInRadians) * speed;
  top -= Math.sin(directionInRadians) * speed;
} else if (moveonlywhenplayerlookingaway == 1 && moveonlywhenplayerlooking !== 1 && !getPlayerPositionRelativeToTile(tile, parseFloat(tile.style.left) / tileSize2, parseFloat(tile.style.top) / tileSize2)) {
  left -= Math.cos(directionInRadians) * speed;
  top -= Math.sin(directionInRadians) * speed;
} else if (moveonlywhenplayerlooking !== 1 && moveonlywhenplayerlookingaway !== 1) {
  left -= Math.cos(directionInRadians) * speed;
  top -= Math.sin(directionInRadians) * speed;
}
                } else if (randomMovement === 1 && distanceToPlayer > distance||distanceToPlayer <= reversedistance && reversedistance!==undefined&&reversedistance!==null&&reversedistance!=="null") {
                    // Logic for random movement when outside the player's distance
                    let randomDirection = parseFloat(tile.dataset.randomDirection); // Get or set random direction from dataset
                    if (!randomDirection || Math.floor(Math.random() * 12) === 2) {
                        // If randomDirection is not defined or random condition is met, generate a new random direction
                        randomDirection = Math.random() * 360;
                        tile.dataset.randomDirection = randomDirection; // Save the generated direction in dataset
                    }
                    left += Math.cos(randomDirection * Math.PI / 180) * speed;
                    top += Math.sin(randomDirection * Math.PI / 180) * speed;
                }
if (randomMovement === 3 && movementType === 'move') {
    let firstX = tile.dataset.firstX ? parseFloat(tile.dataset.firstX) : 0;
    let firstY = tile.dataset.firstY ? parseFloat(tile.dataset.firstY) : 0;
let one=0
if (tile.dataset.firstY !== 0&&tile.dataset.firstY !== undefined&&tile.dataset.firstY !== null) {
  one = 1
}
if(one==0){
  tile.dataset.firstX=left/tileSize
  tile.dataset.firstY=top/tileSize
}
//console.log(tile.dataset.firstY)
    let currentPositionIndex = tile.dataset.gotopozindex ? parseInt(tile.dataset.gotopozindex) : 0;
    let [x, y] = arena[currentPositionIndex];

    let targetX = firstX + x;
    let targetY = firstY + y;
    tile.dataset.targetX=targetX
    tile.dataset.targetY=targetY
//console.log("d:"+currentPositionIndex)
if (currentPositionIndex >= arena.lenght ) {
              if (deletewhencustommoveended == 1) {
                deletedtiles.push(tile);
               // alert(tile)
                tile.remove()
              }
              if(parseInt(patternendbacktostart)==1){

                            const currentXD = parseInt(tile.dataset.firstX)
                            const currentYD = parseInt(tile.dataset.firstY)
                            left = currentXD * tileSize
                            right = currentYD * tileSize
                            tile.style.left = left + 'px';
                            tile.style.top = top + 'px';
              }
}
    if (left / tileSize === targetX && top / tileSize === targetY) {

        currentPositionIndex = (currentPositionIndex + 1) ;

        if (currentPositionIndex >= arena.length) {
            currentPositionIndex = 0;
            if(deletewhencustommoveended==1){
              deletedtiles.push(tile);

              tile.remove()
            } 
         if (parseInt(patternendbacktostart) == 1) {

           const currentXD = parseInt(tile.dataset.buildedX)
           const currentYD = parseInt(tile.dataset.buildedY)
           left = currentXD * tileSize
           top = currentYD * tileSize
           tile.style.left = left + 'px';
           tile.style.top = top + 'px';
         }
        }
        [x, y] = arena[currentPositionIndex];

        tile.dataset.gotopozindex = currentPositionIndex;

        tile.dataset.firstX = left / tileSize;
        tile.dataset.firstY = top / tileSize;
    }

    if (left / tileSize < targetX) {
        left += speed;
    } else if (left / tileSize > targetX) {
        left -= speed;
    }
    if (top / tileSize < targetY) {
        top += speed;
    } else if (top / tileSize > targetY) {
        top -= speed;
    }

    tile.style.left = left + "px";
    tile.style.top = top + "px";
}

                tile.style.left = left + "px";
                tile.style.top = top + "px";
    if (regenerateplayerpos !== undefined && regenerateplayerpos !== null) {
      if(!tile.dataset.ticksupd){
        tile.dataset.ticksupd=-1
      }
    }
if (tile.dataset.ticksupd) {
  tile.dataset.ticksupd++
  if(tile.dataset.ticksupd>parseInt(regenerateplayerpos)){
    tile.dataset.direction = Math.atan2(targetToY - top / tileSize, targetToX - left / tileSize) * (180 / Math.PI);
    tile.dataset.ticksupd=-1
  }
}

                if(oneDirectionFollow==1){
                if((tile.dataset.oneDirectionFollow2)){
                  tile.dataset.oneDirectionFollow2=0
                }else{
                  tile.dataset.oneDirectionFollow2=1
                }
                }else{
                  tile.dataset.oneDirectionFollow2=1
                }
                // Math.random() < 0.5
                if (tile.dataset.oneDirectionFollow2==1) {
                  if(oneDirectionFollow==1){
                    tile.dataset.oneDirectionFollow2=0
                  }

                    tile.dataset.direction = Math.atan2(targetToY - top / tileSize, targetToX - left / tileSize) * (180 / Math.PI);
                }
            } else {
                // Tile is outside the specified area, move towards the edge of the area
               // console.log(JSON.stringify(tileConfig[tileId]))
                const [x1, y1, x2, y2] = area;
                if (left / tileSize < x1) {
                    left += speed;
                } else if (left / tileSize > x2) {
                    left -= speed;
                }
                if (top / tileSize < y1) {
                    top += speed;
                } else if (top / tileSize > y2) {
                    top -= speed;
                }
                // Set the new position
                tile.style.left = left + "px";
                tile.style.top = top + "px";
if (deletebool == true) {
  deletedtiles.push(tile);

  tile.remove();
}
            }}}else{
            }
if(noAttackfunction==1&&distanceToPlayer <= 1 ){
  if(cantbedamaged!==1||cantbedamaged==undefined||cantbedamaged==null){

                  tile.dataset.hp -= 1;
if(config.folder!==undefined){
  if(config.folder.sounds.player[2]){
  let newaudio;
  const base64Wav = config.folder.sounds.player[2];

  newaudio = new Audio();
  newaudio.src = base64Wav;
  newaudio.setAttribute('preload', 'auto');
  document.body.appendChild(newaudio);
  newaudio.play();
  }}
                  if (tile.dataset.hp < 1) {KillThis()
}
                                      }
}
}
        });
    }}

}
if (stop === 1) {
  for (const tileId in tileConfig) {
    var tiles = document.querySelectorAll(`.${tileId}`);
    tiles.forEach((tile) => {
     /* tile.removeAttribute('gotopozindex');
      tile.removeAttribute('firstX');
      tile.removeAttribute('firstY');*/
      //tile.remove()
      //console.log(tile);
    });
  }
}
}
// Function to check if a point is within the specified area
function isWithinArea(x, y, area) {
    const [x1, y1, x2, y2] = area;
    return x >= x1 && x <= x2 && y >= y1 && y <= y2;
}

// ATTACK AND BULLET'S 
var attack = 0;
var projectiles = [];
var onceshootmode = 0;
var cooldownActive = false;
var cooldownDuration = 300
function attack2() {
  if (!('projetitlecfig' in config)) {

        config['projetitlecfig'] = {"timelife":38,"nomove":0,"speed":1.7,"cooldownDuration":350, "scale":1};
    } else {
        cooldownDuration=config.projetitlecfig.cooldownDuration||0
    }

  if (!cooldownActive) {
    attack = 1;
    cooldownActive = true;
    setTimeout(function () {
      cooldownActive = false;
    }, cooldownDuration);
    if (config.folder !== undefined) {
      if (config.folder.sounds.player[1]) {
        let newaudio;
        const base64Wav = config.folder.sounds.player[1];
        newaudio = new Audio();
        newaudio.src = base64Wav;
        newaudio.setAttribute('preload', 'auto');
        document.body.appendChild(newaudio);
        newaudio.play();
      }
    }

    if (config.playershoots == 1 && config.playershoots !== undefined) {
      let el = document.createElement('div');
      el.style.width = '30px';
      el.style.height = '30px';
      el.style.background = `url(${JSON.stringify(config.folder.texture.projectile[0])})`;
      el.style.zIndex="5"

      el.style.backgroundSize="100%"
      el.style.position = "absolute";
      el.className = 'projetitle';
      el.style.left = playerX * tileSize + "px";
      el.style.top = playerY * tileSize + "px";
      document.querySelector('#Econtent').appendChild(el);
      let shootdir = 0;
      let shootingspeed = 4;
      let scalee=1
      if(config.projetitlecfig.scale!==undefined&&config.projetitlecfig.scale!==null){
       scalee= config.projetitlecfig.scale
      }else{
        scalee=1
      }
      let yshootingspeed=4;
      let directionp=0
      let directionl=0
      let speedvel=config.projetitlecfig.speed;
      switch (ostclick) {
  case "left":
    directionp = -shootingspeed;
    speedvel=speedvel*1.2
    directionl = 0;
    break;
  case "right":
    directionp = shootingspeed;
    speedvel=speedvel*1.2
    directionl = 0;
    break;
  case "up":
    directionl = -shootingspeed;
    speedvel=speedvel*1.2
    directionp = 0;
    break;
  case "down":
    directionl = shootingspeed;
    speedvel=speedvel*1.2
    directionp = 0;
    break;
  default:
    directionl = 0;
    directionp = 0;
}
      let projectile = {
        element: el,
        directionX: directionp,
        directionY: directionl,
        lifespan: config.projetitlecfig.timelife||0,
        speed:speedvel||0,
        nomove:config.projetitlecfig.nomove||0,
        scale:scalee
      };
      projectiles.push(projectile);
      if (onceshootmode == 0) {
        animateProjectiles();
        onceshootmode = 1;
      }
    }
  }
}
function animateProjectiles() {
  attack = 1;
  for (let i = 0; i < projectiles.length; i++) {
    let projectile = projectiles[i];
    projectile.lifespan--;
   projectile.element.style.zoom=`${parseInt(projectile.scale)}`
    if(parseInt(projectile.nomove==1)){
    }else{
    projectile.element.style.left = (parseInt(projectile.element.style.left) + parseInt(projectile.directionX)*(projectile.speed)) + "px";
    projectile.element.style.top = (parseInt(projectile.element.style.top) + parseInt(projectile.directionY)*(projectile.speed)) + "px";
    }
    if (projectile.lifespan <= 0) {
      projectile.element.remove();
      projectiles.splice(i, 1);
      i--; 
    }
  }
  if (projectiles.length > 0) {
    setTimeout(animateProjectiles,frameTime);
  } else {
   // attack = 0;
    onceshootmode=0
  }
}
var collecting=0;
function collect(){
  collecting=1

  setTimeout(function(){
    collecting=0
    //alert("")
  },1000)
}


document.getElementById('addButton').addEventListener('touchstart', openFileInput);
function openFileInput() {
  const fileInput = document.getElementById('imageInput');
  fileInput.click();
}
document.getElementById('imageInput').addEventListener('change', handleFileSelect);
function handleFileSelect(event) {
  const fileInput = event.target;
  const files = fileInput.files;
  if (files.length > 0) {
    let spritul = config.sprites
const newBlockIndex = spritul.length + TILES.length+1;
    const collisionValue = 1;
    const image = event.target.files[0];
    
    const reader = new FileReader()

    reader.readAsDataURL(image)
    reader.addEventListener('load', () => {
          TILES.push([newBlockIndex, collisionValue, reader.result,thistilesize,translateY]);
          TILES.push([newBlockIndex+1,1,"/ NAN.png"])
          checki1()
    })
    updateViewport();
  }
}
 
let vcc238=0
function moveObjectsDown() {
  if(vcc238==0){
    vcc238=1
  let X=0
  let Y=1
  for (let dimension = 0; dimension < tileMap.length; dimension++) {
    for (let i = 0; i < tileMap[dimension].length; i++) {
      tileMap[dimension][i][0] += X; 
      tileMap[dimension][i][1] += Y; 
    }
  }
  setTimeout(function(){
    vcc238=0
  },1000)
  }
}
document.getElementById('addButton2').addEventListener('touchstart', openFileInput2);
function openFileInput2() {
  const fileInput = document.getElementById('imageInput2');
  fileInput.click();
}

document.getElementById('imageInput2').addEventListener('change', handleFileSelect2);
function handleFileSelect2(event) {
  const fileInput = event.target;
  const files = fileInput.files;
  if (files.length > 0) {
    let spritul = config.sprites
const newBlockIndex = spritul.length + TILES.length+1;
    const collisionValue = 0;
    const image = event.target.files[0];

    const reader = new FileReader()

    reader.readAsDataURL(image)
    reader.addEventListener('load', () => {
      TILES.push([newBlockIndex, collisionValue, reader.result,thistilesize,translateY]);
      TILES.push([newBlockIndex+1,1,"/ NAN.png"])
      checki1()
    })
    updateViewport();
  }
}
document.getElementById('addButton5').addEventListener('touchstart', openFileInput5);
function openFileInput5() {
  const fileInput = document.getElementById('imageInput5');
  fileInput.click();
}

document.getElementById('imageInput5').addEventListener('change', handleFileSelect5);
function handleFileSelect5(event) {
  const fileInput = event.target;
  const files = fileInput.files;
  if (files.length > 0) {
    let spritul = config.sprites
const newBlockIndex = spritul.length + TILES.length+1;
    const collisionValue = 2;
    const image = event.target.files[0];
  
    const reader = new FileReader()

    reader.readAsDataURL(image)
    reader.addEventListener('load', () => {
      TILES.push([newBlockIndex, isentity, reader.result,thistilesize,translateY]);
      TILES.push([newBlockIndex+1,1,"/ NAN.png"])
      checki1()
      setTimeout(function(){
        entityupd()
      },1000)
    })
    updateViewport();
  }
}




document.getElementById('addButton10').addEventListener('touchstart', openFileInput15);
function openFileInput15() {
  const fileInput = document.getElementById('imageInput10');
  fileInput.click();
}

document.getElementById('imageInput10').addEventListener('change', handleFileSelect15);
function handleFileSelect15(event) {
  const fileInput = event.target;
  const files = fileInput.files;
  if (files.length > 0) {
    let spritul=config.sprites
    const newBlockIndex = spritul.length + TILES.length+1; 
    const collisionValue = 2;
    const image = event.target.files[0];
  
    const reader = new FileReader()

    reader.readAsDataURL(image)
    reader.addEventListener('load', () => {
      config.sprites.push([newBlockIndex, isentity, reader.result,thistilesize,translateY,1]);
      config.sprites.push([newBlockIndex+1,1,"/ NAN.png"])
     checki1()
      setTimeout(function(){
        entityupd()
      },1000)
    })
    updateViewport();
  }
}



document.getElementById('addButton6').addEventListener('touchstart', openFileInput6);
function openFileInput6() {
  const fileInput = document.getElementById('imageInput6');
  fileInput.click();
}

document.getElementById('imageInput6').addEventListener('change', handleFileSelect6);
function handleFileSelect6(event) {
  const fileInput = event.target;
  const files = fileInput.files;
  if (files.length > 0) {
    let spritul = config.sprites
const newBlockIndex = spritul.length + TILES.length+1;
    const collisionValue = -1;
    const image = event.target.files[0];

    const reader = new FileReader()
    reader.readAsDataURL(image)
    reader.addEventListener('load', () => {
      TILES.push([newBlockIndex, collisionValue, reader.result,thistilesize,translateY]);
      //alert(TILES[newBlockIndex])
      
      TILES.push([newBlockIndex+1,1,"/ NAN.png"]);
      checki1()
    })
    updateViewport();
  }
}
document.getElementById('addButton3').addEventListener('touchstart', openFileInput3);
function openFileInput3() {
  const fileInput = document.getElementById('imageInput3');
  fileInput.click();
}
var playerskin=config.playerskin1

document.getElementById('imageInput3').addEventListener('change', handleFileSelect3);
function handleFileSelect3(event) {
  const fileInput = event.target;
  const files = fileInput.files;
  if (files.length > 0) {
    
    const collisionValue = 1;
    const image = event.target.files[0];
 
    const reader = new FileReader()

    reader.readAsDataURL(image)
    reader.addEventListener('load', () => {
      document.querySelector('.player').style.background=`url(${reader.result})`
playerskin=reader.result
if(config.folder.texture.player){
config.folder.texture.player[0]=reader.result

}
    updateViewport();
    })
  }
}
document.getElementById('addButton4').addEventListener('touchstart', openFileInput4);
function openFileInput4() {
  const fileInput = document.getElementById('imageInput4');
  fileInput.click();
}
var bgimg="/grass"

document.getElementById('imageInput4').addEventListener('change', handleFileSelect4);
function handleFileSelect4(event) {
  const fileInput = event.target;
  const files = fileInput.files;
  if (files.length > 0) {
    
    const collisionValue = 1;
    const image = event.target.files[0];
    // Create file reader object
    const reader = new FileReader()
    // Convert image to data URL
    reader.readAsDataURL(image)
    reader.addEventListener('load', () => {
  config.bg = reader.result
  var contentElement = document.getElementById("content");
  contentElement.style.backgroundImage = `url('${config.bg}')`;
  bgimg = reader.result
      updateViewport();
    })
  }
}

var last = TILES[TILES.length - 1][2]
</script>
<div id="information1bar">
<p style="position:fixed; bottom: 0px; left:50vw; transform: translate(-50%,0%); z-index: 99999; color:white">killed: <t id="killed"></t></p>
<p style="position:fixed; bottom: 0px; left:calc(50vw + 80px); transform: translate(-50%,0%); z-index: 99999; color:white">score: <t id="score"></t></p></div>
<script>
function test00(){
  document.getElementById('killed').innerHTML=killed
  document.getElementById('score').innerHTML=score
}
window.setInterval(test00,1000)
</script>
<script>
  var fps = document.getElementById("fps");
var startTime = Date.now();
var frame = 0;
function tick() {
  var time = Date.now();
  frame++;
  if (time - startTime > 1000) {
    fps.innerHTML = (frame / ((time - startTime) / 1000)).toFixed(1);
    startTime = time;
    frame = 0;
  }
  window.setTimeout(tick,200);
}
tick();
</script>
<script>
var gravity=config.gravity;
    var stick = document.querySelector('.stick');
    var joystick = document.querySelector('.joystick');
    var joystickRect = joystick.getBoundingClientRect();
    let isDragging = false;
    let joystickX = 0;
    let joystickY = 0;
    var x=0
    var y=0
    var speed=config.speed
    var ostclick="down";
  function movright(){
    movePlayer(-0.08*speed,0)
    if(config.debugmode==1){
      movePlayer(-0.08*8,0)
    }
    ostclick="left"
  }
  function movleft() {
    movePlayer(0.08*speed,0)
    if (config.debugmode == 1) {
  movePlayer(0.08 * 8, 0)
}
    ostclick="right"
  }
  function movup() {
movePlayer(0,-0.08*speed)
if (config.debugmode == 1) {
  movePlayer(0,-0.08*8)
}
ostclick="up"
  }
  function movdown() {
    movePlayer(0,0.06*speed)
    if (config.debugmode == 1) {
  movePlayer(0, 0.08 * 8)
}
    ostclick="down"
  }
    function updateJoystick(event) {
      let x, y;
      if (event.type === 'touchmove') {
        x = event.touches[0].clientX - joystickRect.left - joystickRect.width / 2;
        y = event.touches[0].clientY - joystickRect.top - joystickRect.height / 2;
      } else {
        x = event.clientX - joystickRect.left - joystickRect.width / 2;
        y = event.clientY - joystickRect.top - joystickRect.height / 2;
      }
      if (x > 30) {
        movleft()
      }
      if (x < 30) {
        movright()
      }
      const distance = Math.sqrt(x * x + y * y);
      const angle = Math.atan2(y, x);
      const maxDistance = joystickRect.width / 2 - stick.getBoundingClientRect().width / 2;
      if (y < -40 && distance > 40) {
        movup()
      }
      if (y > 40 && distance > 40) {
       movdown()
      }
      if (distance > maxDistance) {
        x = Math.cos(angle) * maxDistance;
        y = Math.sin(angle) * maxDistance;
      }
      stick.style.transform = `translate(${x}px, ${y}px)`;
    }
    stick.addEventListener('mousedown', event => {
      isDragging = true;
      updateJoystick(event);
    });
    joystick.addEventListener('mousemove', event => {
      if (isDragging) {
        updateJoystick(event);
      }
    });
    joystick .addEventListener('mouseup', () => {
      isDragging = false;
      stick.style.transform = 'translate(0px, 0px)';
    });
    stick.addEventListener('touchstart', event => {
      event.preventDefault();
      isDragging = true;
      if(toonce===0){
      aud = document.getElementById('audio')
      aud.play()
      aud.loop = true;
      if(aud.currentTime >0){
      toonce=1
      }
      aud.currentTime = 0;
      }
      updateJoystick(event);
    });
    joystick.addEventListener('touchmove', event => {
      event.preventDefault();
      if (isDragging) {
        updateJoystick(event);
      }
    });
    joystick .addEventListener('touchend', () => {
      isDragging = false;
      stick.style.transform = 'translate(0px, 0px)';
    });
</script>
<div id="hpBarContainer">
</div>
<style>
  #hpBarContainer{
   position: fixed;
   z-index: 99;
   pointer-events: none;
  }
</style>
<script>

var HpbarConfig;

function updateHpBar(currentHp) {
    const hpBarContainer = document.getElementById('hpBarContainer');
    hpBarContainer.innerHTML = ''; 
    if(config.v>0.5){
      HpbarConfig=config.HpBarConfiguration
hpBarContainer.style.left=HpbarConfig.left+"%"
currentHp = HpbarConfig.numberHP;
hpBarContainer.style.right=HpbarConfig.right+"%"
hpBarContainer.style.top=HpbarConfig.top+"%"
hpBarContainer.style.bottom=HpbarConfig.bottom+"%"
    for (let i = 0; i < HpbarConfig.maxHp; i++) {
        const heart = document.createElement('img');
        if (i < currentHp) {
            heart.src = HpbarConfig.texture;
        } else {
            heart.src = HpbarConfig.textureempty;; 
        }
        hpBarContainer.appendChild(heart);
    }}
}

var currentHp = 1; 
let hurtdelayed=0

const limitIteracji = 50;
var classicspeed = config.norspeed;
let test2 = 0;
var newcollisions = [".hurtblock"];
let to205 = true;
function checkit() {
  if( config.debugmode==0 && isgamepaused==0 ) {
    for (let tileClass of newcollisions) {
        const tiles = document.querySelectorAll(tileClass);
        for (let tile of tiles) {
            const rect1 = player.getBoundingClientRect();
            const rect2 = tile.getBoundingClientRect();
            const wallThickness = 2;
let fxc=parseInt(tile.dataset.damagedist)*(tileSize2/2)
let hurtdmg=1
if(tile.dataset.damage){
  hurtdmg=parseInt(tile.dataset.damage)
}else{
   hurtdmg=1
}
if(parseInt(tile.dataset.damagedist)==1||parseInt(tile.dataset.damagedist)==0||(tile.dataset.damagedist)==undefined){
  fxc=0
}
            if (rect1.bottom > rect2.top -(5+fxc) &&
                rect1.top < rect2.bottom + (5+fxc) &&
                rect1.right > rect2.left - (5+fxc) &&
                rect1.left < rect2.right + (5+fxc)) {

                if (to205) {
        if(config.v>0&&config.v){
if(config.folder){
if(config.folder.texture.player[8]){
document.querySelector('.player').style.background=`url(${config.folder.texture.player[8]})`
setTimeout(function(){
  document.querySelector('.player').style.background = `url(${playerskin})`
},2000)
}
}}
                  if(config.HpBarConfiguration!==undefined){

                    config.HpBarConfiguration.numberHP-= hurtdmg
                    currentHp=config.HpBarConfiguration.numberHP
                    updateHpBar(currentHp)
if (currentHp < 1) {
  config.bg = config.oldbg
  dimension = config.olddimension
  if (config.savedgamestate !== 1 && config.savedgamestate !== "1") {} else {
    if (config.savedgamestate !== undefined) {
      loadoldergamestate()
    }
  }
}
                    if (currentHp < 1) {
                      config.bg=config.oldbg
                      
                        playerY = config.spawnY;
                        playerX = config.spawnX;
                        if(config.oldmusic!==undefined&&config.oldmusic!==null&&config.oldmusic){
                        var base64WavU = config.oldmusic;
if(base64WavU!==undefined&&base64WavU!==null&&base64WavU&&config.oldmusic!==undefined&&config.oldmusic!==null&&config.oldmusic){
                        if (audioInstance&&base64WavU.length>20) {

                          audioInstance.pause();
                          audioInstance.currentTime = 0;
                          audioInstance = null;
                        }
                        if (config.music !== ''&&base64WavU.length>20) {

                          audioInstance = new Audio();
                          audioInstance.src = base64WavU;
                          audioInstance.setAttribute('preload', 'auto');

                          document.body.appendChild(audioInstance);
                
                          audioInstance.play();
                          audioInstance.loop = true;
                          toonce = 0;
                        }}}
                        config.HpBarConfiguration.numberHP=config.HpBarConfiguration.maxHp
                        setTimeout(updateViewport,50)
                        setTimeout(updateViewport,20)
                    }
if(HpbarConfig.Work==true){
                }else{
                      playerY = config.spawnY;
                      playerX = config.spawnX;
                      setTimeout(updateViewport, 50)
                      setTimeout(updateViewport, 20)
                    }
updateHpBar(config.HpBarConfiguration.numberHp);

                    to205 = false;
                    setTimeout(function () {
                        to205 = true;
                    }, HpbarConfig.hurtDelay||500);
                }else{
                  playerY = config.spawnY;
                  playerX = config.spawnX;
                  if (audioInstance) {

                    audioInstance.pause();
                    audioInstance.currentTime = 0;
                    audioInstance = null;
                  }
                  if (config.music !== '') {
                    let base64WavZ = config.music;
                  if(config.oldmusic!==undefined&&config.oldmusic!==null){
if (config.oldmusic.slice(0, 10) !== config.oldmusic) {
    base64WavZ = config.oldmusic;
} else {
    base64WavZ = config.music;
}}

                    audioInstance = new Audio();
                    audioInstance.src = base64WavZ;
                    audioInstance.setAttribute('preload', 'auto');
   document.body.appendChild(audioInstance);

                    audioInstance.play();
                    audioInstance.loop = true;
                    toonce = 0;
                  }
                  setTimeout(updateViewport, 50)
                  setTimeout(updateViewport, 20)
                }}
            }
        }
    }
}}
setTimeout(updateViewport,4000)
setTimeout(updateViewport,6000)
function normspeed() {
  const nearestDistanceThreshold = 25; 
  let nearestDistance = Number.MAX_SAFE_INTEGER;
  for (let tile of tiles) {
    const rect1 = player.getBoundingClientRect();
    const rect2 = tile.getBoundingClientRect();
    const distance = Math.sqrt(
      Math.pow(rect1.left - rect2.left, 2) +
      Math.pow(rect1.top - rect2.top, 2)
    );
    if (distance < nearestDistance) {
      nearestDistance = distance;
      if (rect1.bottom > rect2.top - 90 &&
        rect1.top < rect2.bottom + 90 &&
        rect1.right > rect2.left - 90 &&
        rect1.left < rect2.right + 90) {
        if (!(rect1.bottom > rect2.top - 80 &&
            rect1.top < rect2.bottom + 80 &&
            rect1.right > rect2.left - 80 &&
            rect1.left < rect2.right + 80)) {
          speed = config.norspeed;
          //alert("")
        }
      } else {
      }
    }
  }
  test2 += 1
  if (test2 < 8) {
    setTimeout(normspeed, 500)
  } else {
    test2 = 0
  }
}
function jump(){
  speed=4
  setTimeout(function(){
    speed=config.backspeed
    power=0.20
  },5000)
}
let oneFor2s=0
let canClick = true;
let FirtOneJump=1
function jump2(event) {
    event.preventDefault();
    if (canClick) {
        if (canJUMP == 1||FirtOneJump==1) {
            jumping();
            isonfloor=0
            FirtOneJump=0
            if (config.folder.sounds.player[0]) {
                let newaudio;
                const base64Wav = config.folder.sounds.player[0];

                newaudio = new Audio();
                newaudio.src = base64Wav;
                newaudio.setAttribute('preload', 'auto');

                document.body.appendChild(newaudio);

                newaudio.play();
                
            }
            airJump++;
            canClick = false;
            setTimeout(function() {
                canClick = true;
            }, 700); 
        }
    }
}
let gjfj=0
let olderspeed=0
const player = document.querySelector('.player');
player.style.willChange = 'transform';
var tileSize2 = tileSize;
let playerX = config.px*30;
let playerY = config.py*30;

viewport.scrollTo( 100, 100) 
setTimeout(function(){
  if(config.customcamera==1){
    viewport.scrollTo( config.cameraX * tileSize2 - viewportWidth / 2, (config.cameraY * tileSize2) - viewportHeight / viewportHeight* viewportHeight/2) 
  }
})
var thix=0
var thiy=0
var blockspassed=0
var updatevpifblockspassed=20
let by4=0
var loadingdata=0
var pausemove=0
function movePlayer(dx, dy) {
  
  if(pausemove==0){
  const maxHistoryLength = 50;



if(by4<2){
  by4++;
}else{
  by4=0
  // Add the current position to the history array
  if(loadingdata==0){
  lastplayerpos.push({ x: playerX, y: playerY });
}
  // Ensure the history array does not exceed the maximum length
  if (lastplayerpos.length > maxHistoryLength) {
    lastplayerpos.shift(); // Remove the oldest element
  }
}
  let smallestVect=0
  if(viewportWidth<viewportHeight){
    smallestVect=viewportWidth
  }else{
    smallestVect=viewportHeight
  }
  blockspassed++;
  if(speed<3){
  if (isScrolling && blockspassed > updatevpifblockspassed*speed) {
    blockspassed = 0
    if (config.roommode !== 1&&config.roommode !== 1) {
  updateViewport()}
    isScrolling = false;
  
  }}else if(speed<5){
  if (isScrolling && blockspassed > updatevpifblockspassed*speed-3) {
    blockspassed = 0
    if (config.roommode !== 1&&config.roommode !== 1) {
  updateViewport()}
    isScrolling = false;
  
  }}else if (isScrolling && blockspassed > (viewportWidth/2.5)/Math.abs(speed-4)) {
    blockspassed = 0
    if (config.roommode !== 1&&config.roommode !== 1) {
  updateViewport()}
    isScrolling = false;
  
  }
  if(config.newengine4==1){
  for (var i = 0; i <= speed; i++) {
playerX += dx / speed;
thiy = dy / speed;
thix = dx / speed;
playerY += dy / speed;
collision()
  }}else{
    playerX += dx ;
thiy = dy ;
thix = dx ;
playerY += dy ;

  }
  
  document.getElementById('console').innerHTML ='x:'+ Math.round(playerX*100)/100 +' &nbsp &nbsp &nbsp y:'+Math.round(playerY*100)/100

  player.style.left = playerX * tileSize2 + 'px';
  player.style.top = playerY * tileSize2 + 'px';
  }collision();
  
  if(document.getElementById('player')&&document.getElementById('playerskin')){
  
  var playerbox=document.getElementById('player')
  var playerlayer=document.getElementById('playerskin')
  playerlayer.style.left=playerbox.style.left
  playerlayer.style.top=playerbox.style.top
  playerlayer.style.background=playerbox.style.background
  playerlayer.style.backgroundImage=playerbox.style.backgroundImage
  if(config.playersizeHasHitBox==0){
  var playerf = document.querySelector('#playerskin');

var scaleValue = parseFloat(config.playersizeNOHITBOX);

//var playerAfterStyle = window.getComputedStyle(player, '::after');

var newAfterTransform = `scale(${scaleValue})`;
playerf.style.setProperty('--after-transform', newAfterTransform);
playerf.style.backgroundSize="100%"
}else{
  var playerf = document.querySelector('#playerskin');
document.querySelector('#playerskin').style.transform=`scale(${parseFloat(config.playersizeNOHITBOX)})`
playerf.style.backgroundSize="100%"
}
  
  
}}
function setPlayer(dx, dy) {
  playerX = dx;
  thiy = dy;
  thix = dx;
  playerY = dy;
  document.getElementById('console').innerHTML = 'x:' + (playerX) + 'y:' + (playerY)
  player.style.left = playerX * tileSize2 + 'px';
  player.style.top = playerY * tileSize2 + 'px';
}
setTimeout(move, 2)
checkIfElementExited(player, viewport)
function move(){
}
function checkIfElementExited(player, viewport) {
    let dzoom = 1;
    //config.roommode = 2
    if (parseInt(viewport.style.zoom)) {
        dzoom = parseInt(viewport.style.zoom);
    }

    if (config.roommode !== 1&& config.roommode!==2) {
        viewport.scrollTo(
            (playerX * tileSize2) - viewportWidth / 2 * (dzoom + 0.1), 
            (playerY * tileSize2) - viewportHeight / 2 * (dzoom + 0.1)
        );
    } else if (config.roommode == 1) {
        // Calculate player's position relative to the viewport
        const playerViewportX = playerX* tileSize2 - viewport.scrollLeft;
        const playerViewportY = playerY * tileSize2 - viewport.scrollTop;

        const edgeThreshold = 50; // 50 pixels from the edge of the viewport

        let scrollX = viewport.scrollLeft;
        let scrollY = viewport.scrollTop;

        if (playerViewportX < edgeThreshold) {
            scrollX = playerX* tileSize2 - edgeThreshold;
        } else if (playerViewportX > viewport.clientWidth - edgeThreshold) {
            scrollX = playerX * tileSize2 - viewport.clientWidth + edgeThreshold;
        }

        if (playerViewportY < edgeThreshold) {
            scrollY = playerY * tileSize2 - edgeThreshold;
        } else if (playerViewportY > viewport.clientHeight - edgeThreshold) {
            scrollY = playerY * tileSize2 - viewport.clientHeight + edgeThreshold;
        }

        viewport.scrollTo(scrollX, scrollY);
    }else if (config.roommode == 2) {
  // Calculate player's position relative to the viewport
  const playerViewportX = playerX * tileSize2 - viewport.scrollLeft;
  const playerViewportY = playerY * tileSize2 - viewport.scrollTop;

  const edgeThreshold = 50; // 50 pixels from the edge of the viewport

  let scrollX = viewport.scrollLeft;
  let scrollY = viewport.scrollTop;

  if (playerViewportX < edgeThreshold) {
    scrollX = playerX * tileSize2 - edgeThreshold;
    viewport.scrollTo(
  (playerX * tileSize2) - viewportWidth / 2 * (dzoom + 0.1),
  (playerY * tileSize2) - viewportHeight / 2 * (dzoom + 0.1));
  updateViewport()
  } else if (playerViewportX > viewport.clientWidth - edgeThreshold) {
    scrollX = playerX * tileSize2 - viewport.clientWidth + edgeThreshold;
   viewport.scrollTo(
  (playerX * tileSize2) - viewportWidth / 2 * (dzoom + 0.1),
  (playerY * tileSize2) - viewportHeight / 2 * (dzoom + 0.1));
updateViewport()
  }

  if (playerViewportY < edgeThreshold) {
    scrollY = playerY * tileSize2 - edgeThreshold;
    viewport.scrollTo(
  (playerX * tileSize2) - viewportWidth / 2 * (dzoom + 0.1),
  (playerY * tileSize2) - viewportHeight / 2 * (dzoom + 0.1));
updateViewport()
  } else if (playerViewportY > viewport.clientHeight - edgeThreshold) {
    scrollY = playerY * tileSize2 - viewport.clientHeight + edgeThreshold;
 
viewport.scrollTo(
  (playerX * tileSize2) - viewportWidth / 2 * (dzoom + 0.1),
  (playerY * tileSize2) - viewportHeight / 2 * (dzoom + 0.1));
  updateViewport()
  }

  
}
}


var power=0.20
var tiles = document.querySelectorAll('.tile');
  function constructn(){
     tiles = document.querySelectorAll('.tile5 , .tile');
  }
var topside=0
var to1=0
//check()
function check(){
  for (let tile of tiles) {
    const rect1 = player.getBoundingClientRect();
    const rect2 = tile.getBoundingClientRect();
    const wallThickness = 2;
    if (rect1.bottom > rect2.top - 4 &&
      rect1.top < rect2.bottom + 4 &&
      rect1.right  > rect2.left + 4 &&
      rect1.left < rect2.right - 4) {
  to1+=1
  //alert(to1)
  if(loadingdata==0){
      cofnijczas(to1);}
     // console.log("oh")
      //alert("he")
      //    VelocityY = -0.01;
      Centercol = 1;
      topside = 0;
      gravityvelocity=0
      /*   playerY -= 0.6;*/
    //  playerX -= 0.1;
    }else{
      setTimeout(function(){
        to1=1
      },1000)
    }
  }
//  requestAnimationFrame(check)
}
/*
if (rect1.bottom > rect2.top - 5 &&
rect1.top < rect2.bottom + 5 &&
rect1.right > rect2.left - 5 &&
rect1.left < rect2.right + 5) {
*/
var collidingjump=0
var collidingjump2=0
/* PLAYER COLLISION*/
      function collision() {
        if( config.debugmode==0 && isgamepaused==0 ) {
        for(let i=0; i<1;i++){
          check()
        for (let tile of tiles) {
          const rect1 = player.getBoundingClientRect();
          const rect2 = tile.getBoundingClientRect();
          const wallThickness = 2;
          if(false){
            
            





          }else{

          if (rect1.top < rect2.bottom + 3 && rect1.bottom > rect2.bottom + 5 && rect1.right > rect2.left && rect1.left < rect2.right) {
            playerY +=power * speed;
            player.style.top = playerY * tileSize + 'px';
        //    collide = 1
        speed=config.backspeed
            setTimeout(normspeed,1000)
          }
          if (rect1.left < rect2.right+4  && rect1.right > rect2.right && rect1.bottom > rect2.top &&
  rect1.top < rect2.bottom - 2) {
            playerX += power*speed*1.19;
            player.style.left = playerX * tileSize + 'px';
            player.style.top = playerY * tileSize + 'px';
            collide = 1
            speed=config.backspeed
            setTimeout(normspeed,1000)
          }
          if (
              rect1.right > rect2.left - 3 &&
              rect1.left < rect2.left &&
              rect1.bottom > rect2.top &&
              rect1.top < rect2.bottom-2
            ) {

            playerX -= power * speed * 1.19;
            player.style.left = playerX * tileSize + 'px';
            player.style.top = playerY * tileSize + 'px';
            collide = 1
            speed = config.backspeed
            setTimeout(normspeed, 1000)
          }
if (rect1.bottom +6 > rect2.top - wallThickness && rect1.top < rect2.top && rect1.right > rect2.left +7  && rect1.left < rect2.right-7 ) {
  isonfloor=1
canJUMP=1
airJump=0
gravityvelocity=1
if(collidingjump2==0){
  collidingjump=1
  collidingjump2=1
  setTimeout(function(){
    collidingjump=0
    collidingjump2=0
  },200)
}
}else{
}
if (rect1.bottom +3 > rect2.top - wallThickness && rect1.top+20 < rect2.top -5&& rect1.right +2> rect2.left + wallThickness && rect1.left -2< rect2.right - wallThickness) {
  gravityvelocity=1
}
          if (rect1.bottom +3 > rect2.top - wallThickness && rect1.top+6 < rect2.top -5&& rect1.right +2> rect2.left + wallThickness && rect1.left -2< rect2.right - wallThickness) {
if(gravity==0){
            playerY -= power*speed}else{
              playerY -= (power* gravityvelocity)-0.10
            }
//VelocityY = -0.2;
           // console.log("ok")
gravityvelocity=1
            player.style.left = playerX * tileSize + 'px';
            player.style.top = playerY * tileSize + 'px';
  //          VelocityY = 0;
            speed=config.backspeed
            setTimeout(normspeed,1000)
          } else {
          }
          if (rect1.bottom + 1 > rect2.top - wallThickness && rect1.top < rect2.top && rect1.right > rect2.left + wallThickness && rect1.left < rect2.right - wallThickness) {

            spgrav = 0
            player.style.left = playerX * tileSize + 'px';
            player.style.top = playerY * tileSize + 'px';
speed=config.backspeed
setTimeout(normspeed,1000)
            Topcol = 1
          } else {
            Topcol = 0;
          }
       /*  if (player.x < rect2.x && player.y + 55 > rect2.y && player.y < rect2.y + 55) {
            rect2.x = player.x - 50;
          }*/
          if (rect1.bottom + 5 >= rect2.top &&
            rect1.top < rect2.bottom &&
            rect1.right > rect2.left &&
            rect1.left < rect2.right) {
            collide = 1;
            cav = 0
          } else {
            collide = 0;
          }
        }}}
      }}
function h(){
}
var by3=0
let toto = 0;
let iindex = 0;
var frameTime = 1000 / targetFPS;
let gravityvelocity = 1
var tlo2 = 0
      function anim() {
      }
      var yyy=0
      let yzd=0
      var running=0
      var oldspeedd=0
function loop() {
   
  if (!('defps' in config)) {
  config['defps'] = 15;
}
frameTime = 1000 / config.defps;
  if (!('screenfilter' in config)) {
  config['screenfilter'] = [0,0,0,0];
}
if (!('runningspeed' in config)) {
  config['runningspeed'] = 3;
}
if(running==1){
  if(oldspeedd!==speed){
    oldspeedd=speed
  }
  speed=config.runningspeed
}else{
   
  speed=config.speed
}
 
  if (document.getElementById('Jump')) {
  cantsavebugfix=1
}else{
  cantsavebugfix=0
}
if (document.getElementById('Run')) {
  document.getElementById('Run').addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    running = 1;
  });
  document.getElementById('Run').addEventListener('touchend', function() {
    running = 0;
  });
}
if (!('renderertype' in config)) {
  config['renderertype'] = 1;
}
if (!('information1bar' in config)) {
  config['information1bar'] = 1;
}if (!('information2bar' in config)) {
  config['information2bar'] = 1;
}
if (!('information3bar' in config)) {
  config['information3bar'] = 1;
}
if(config.information1bar==1){
document.getElementById('information1bar').style.display="block"}else{
  document.getElementById('information1bar').style.display="none"
}
if(config.information2bar==1){
document.getElementById('playPauseButton').style.display="block"}else{
  document.getElementById('playPauseButton').style.display="none"
}
if(config.information3bar==1){
document.getElementById('playPauseButton2').style.display="block"}else{
  document.getElementById('playPauseButton2').style.display="none"
}
if(config.renderertype==1){
  // antianalising 
  document.getElementById('viewport').style.imageRendering="pixelated"
}else{
  document.getElementById('viewport').style.imageRendering=""
}
if (!('sprites' in config)) {
  config['sprites'] = [];
}
if (!('spritesmap' in config)) {
  config['spritesmap'] = [[], [], [], [],[]];
}
if (!('HTML5' in config)) {
  config['HTML5'] = " ";
}
if(document.getElementById("HTMLADDCODE")){
if(document.getElementById("HTMLADDCODE").innerHTML!==config.HTML5){
document.getElementById("HTMLADDCODE").innerHTML=config.HTML5 
}}
if (!('newengine4' in config)) {
  config['newengine4'] = 0;
}
SPRITES=config.sprites
  var playerbox=document.getElementById('player')
  if (playerskin) {
  playerbox.style.background = `url(${playerskin})`
  playerbox.style.backgroundImage=`url(${playerskin})`
}
  var playerlayer=document.getElementById('playerskin')
  playerlayer.style.left=playerbox.style.left
  playerlayer.style.top=playerbox.style.top
  playerlayer.style.background=playerbox.style.background
  playerlayer.style.backgroundImage=playerbox.style.backgroundImage
  
  if(isgamepaused==1){
classicspeed = 8
speed = 8
}else{
}
  config.px=(playerX)/tileSize;config.py=playerY/tileSize;
  if (!('oldmusic' in config)) {
  config['oldmusic'] = config.music;
}
if (!('oldmap' in config)) {
  config['oldmap'] = 0;
}
if (!('olddimension' in config)) {
  config['olddimension'] = dimension;
}
if (!('oldbg' in config)) {
  config['oldbg'] = config.bg;
}
  if (!('playerdamage' in config)) {
  config['playerdamage'] = 1;
}
  if (!('maxgravityvelocity' in config)) {
config['maxgravityvelocity'] = 1;
} 
if (!('gravitypower' in config)) {
  config['gravitypower'] = 0.5;
}
if (!('gravityvelocityspeed' in config)) {
  config['gravityvelocityspeed'] = 0.4;
}

  if (!('savedgamestate' in config)) {

  config['savedgamestate'] = 0;
}
  if(config.zoom!==1&&config.zoom!==0&&config.zoom!==undefined&& config.testmode==1){
   viewport.style.zoom= config.zoom
   document.querySelector('#content2').style.zoom = document.querySelector('#viewport').style.zoom;
  }
if (!('dimension' in config)) {

  config['dimension'] = 0;
}
  if (!('projectile' in config.folder.texture)) {

  config.folder.texture['projectile'] = [0,0];
} else {
}

  if (!('playersizeNOHITBOX' in config)) {
  config['playersizeNOHITBOX'] = 1;
}
if (!('playersizeHasHitBox' in config)) {
  config['playersizeHasHitBox'] = 0;
}
if(config.playersizeHasHitBox==0){
  var player = document.querySelector('#playerskin');

var scaleValue = parseFloat(config.playersizeNOHITBOX);

//var playerAfterStyle = window.getComputedStyle(player, '::after');

var newAfterTransform = `scale(${scaleValue})`;
player.style.setProperty('--after-transform', newAfterTransform);
player.style.backgroundSize="100%"
}else{
document.querySelector('#playerskin').style.transform=`scale(${parseFloat(config.playersizeNOHITBOX)})`
player.style.backgroundSize="100%"
}
let resizableDiv=document.getElementById('viewport')
const newWidth=config.width
const newHeight=config.height
resizableDiv.style.width = `${newWidth}px`;
viewportWidth = newWidth
viewportHeight = newHeight
config.width = newWidth
config.height = newHeight
resizableDiv.style.height = `${newHeight}px`;
  document.addEventListener('keydown', function(event) {
  switch (event.key) {
    case 'w':
      if (document.getElementById('Up')) {
        upButtonDown = 1;
      }
      if (document.getElementById('Jump')) {
        jump2(event);
      }
      break;
    case 'c':
      if (document.getElementById('Run')) {
        running = 1;
      }
      break;

    case 'a':
      if (document.getElementById('Left')) {
        leftButtonDown = 1;
      }
      break;
      
    case 's':
      if (document.getElementById('Down')) {
        downButtonDown = 1;
      }
      break;
    case 'd':
      if (document.getElementById('Right')) {
        rightButtonDown = 1;
      }
      break;
    case 'x':
      if (document.getElementById('Attack')) {
        attack2();
      }
      break;
    case 'x':
      if (document.getElementById('Attack')) {
        attack2();
      }
      break;
    case 'q':
      if (document.getElementById('Jump')) {
        jump2(event);
      }
      break;
  }
  if (event.keyCode === 32) {
    if (document.getElementById('Attack')) {
      attack2();
    }
  }
});
document.addEventListener('keyup', function(event) {
  switch (event.key) {
    case 'w':
      if (document.getElementById('Up')) {
        upButtonDown = 0;
      }
      break;
    case 'a':
      if (document.getElementById('Left')) {
        leftButtonDown = 0;
      }
      break;
      case 'c':
      if (document.getElementById('Run')) {
        running = 0;
      }
      break;

    case 's':
      if (document.getElementById('Down')) {
        downButtonDown = 0;
      }
      break;
    case 'd':
      if (document.getElementById('Right')) {
        rightButtonDown = 0;
        
        
      }
      break;
    case 'x':
      if (document.getElementById('Attack')) {

      }
      break;
    case 'w':
      if (document.getElementById('Jump')) {

      }
      break;
  }
});
    checkit();
    if(yyy<20){
      yyy++
    }else{
      yyy=0
      updateHpBar(currentHp)
    }
    if (toto > 1) {
        toto = 0;
    }
    if (toto == 0) {
        moveTilesRandomly();
    }
    toto += 1;
   // yzd++
    if (config.debugmode == 0) {
        if (config.sidescroll == 1) {
         // if(yzd>3){ yzd=0
            checkIfElementExited(player, viewport);//}
        }
    } else {
        checkIfElementExited(player, viewport);
    }
    
    if (leftButtonDown == 0 && upButtonDown == 0 && rightButtonDown == 0 && downButtonDown == 0 && isjumping == false) {
      if (playerskin) {
        document.querySelector('.player').style.background = `url(${playerskin})`
      }
    }
    
    if(ostclick=="right"){
      if(config.v>0&&config.v){
      if(config.folder){
      if (config.folder.texture.player[4]) {
        document.querySelector('.player').style.background = `url(${config.folder.texture.player[4]})`
      }}}
    }
    if(ostclick=="down"){
      if(config.v>0&&config.v){
      if(config.folder){
      if (config.folder.texture.player[7]) {
        document.querySelector('.player').style.background = `url(${config.folder.texture.player[7]})`
      }}}
    }
    if(ostclick=="left"){
      if(config.v>0&&config.v){
      if(config.folder){
      if (config.folder.texture.player[5]) {
        document.querySelector('.player').style.background = `url(${config.folder.texture.player[5]})`
      }}}
    }
    if(ostclick=="up"){
      if(config.v>0&&config.v){
      if(config.folder){
      if (config.folder.texture.player[9]) {
        document.querySelector('.player').style.background = `url(${config.folder.texture.player[9]})`
      }}}
    }
    if(isjumping==true){
      if(config.v>0&&config.v){
      if(config.folder){
      if (config.folder.texture.player[3]) {
        document.querySelector('.player').style.background = `url(${config.folder.texture.player[3]})`
      }}}
    }
    if (leftButtonDown == 1) {
        movright();
        if(config.v>0&&config.v){
        if(config.folder){
        if(config.folder.texture.player[1]){
        document.querySelector('.player').style.background=`url(${config.folder.texture.player[1]})`
        }
        }}
    }
    if (downButtonDown == 1) {
        movdown();
        if(config.v>0&&config.v){
if(config.folder){
if(config.folder.texture.player[6]){
document.querySelector('.player').style.background=`url(${config.folder.texture.player[6]})`
}
}}
    }
    if (upButtonDown == 1) {
        movup();
        if(config.v>0&&config.v){
        if(config.folder){
        if (config.folder.texture.player[3]) {
          document.querySelector('.player').style.background=`url(${config.folder.texture.player[3]})`
        }}}
    }
    if (rightButtonDown == 1) {
        movleft()
        if(config.v>0&&config.v){
        if(config.folder){
        if (config.folder.texture.player[2]) {
          document.querySelector('.player').style.background=`url(${config.folder.texture.player[2]})`
         }}}
    }
    
    if (movePlayer(0, 0)) {
    } else {
        thix = 0;
        thiy = 0;
    }
    stick = document.querySelector('.stick');
    joystick = document.querySelector('.joystick');
    joystickRect = joystick.getBoundingClientRect();
    if (gravity == 1) {
      if(tlo2<3){
        tlo2+=1
      }else{
        console.log(config.maxgravityvelocity+' '+gravityvelocity+' : coljuml'+collidingjump)
        if(config.maxgravityvelocity!==undefined){
      if(gravityvelocity<config.maxgravityvelocity){
if(gravity==1&&collidingjump==0){
gravityvelocity+=config.gravityvelocityspeed
console.log(config.maxgravityvelocity)
}
tlo2=0
}
}else{
}}if(gravity==1&&collidingjump==0){
        movePlayer(0,config.gravitypower*gravityvelocity||0.10);
          if(config.v>0&&config.v&& config.gravity==1){
if(config.folder){
if(config.folder.texture.player[6]){
document.querySelector('.player').style.background=`url(${config.folder.texture.player[6]})`
}
}}
}
    }
    by3++;
    if (isScrolling && by3 > 60) {
      by3 = 0

      isScrolling = false;
    }
    constructn()

    setTimeout(() => {
     loop()
    }, frameTime);
}
var isjumping=false;
let airJump=0
function jumping() {
  
  if(config.airjump<=airJump){
    canJUMP = 0;
    airJump=0
  }else{
  }
    isjumping=true
    gravity = 0;
    olderspeed = speed;
    gjfj += 1;
   // speed = 1.0;
    playerY -= config.jumpingpower;
    if (gjfj < config.longjump) {
        requestAnimationFrame(jumping);
    } else {
        gjfj = 0;
        speed = olderspeed;
        gravity = 1;
        isjumping=false
    }
}

requestAnimationFrame(loop);
requestAnimationFrame(loop);


/* EDITOR*/
var brushSize = 1;
let bugfix2=0
function buildBlock(event) {

if(buildmap==1){
  const rect = content.getBoundingClientRect();
  const x = Math.floor((event.clientX - rect.left) / tileSize2);
  const y = Math.floor((event.clientY - rect.top) / tileSize2);
  // Funkcja do zbudowania bloków w obszarze o określonym rozmiarze
 // alert(TILES[item][0])
  function buildBlocksAroundPosition(startX, startY) {
    if(config.testmode==0){
  for (let offsetX = -brushSize + 2; offsetX <= brushSize; offsetX++) {
    for (let offsetY = -brushSize + 2; offsetY <= brushSize; offsetY++) {
      const currentX = startX + offsetX - 1;
      const currentY = startY + offsetY - 1;
      const existingBlockIndex = tileMap[dimension].findIndex(tile => tile[0] === currentX && tile[1] === currentY);
      const existingBlockIndex2 = config.spritesmap[dimension].findIndex(tile => tile[0] === currentX && tile[1] === currentY);
if (layers === 0) {
  if (existingBlockIndex2 !== -1) {
    config.spritesmap[dimension].splice(existingBlockIndex2, 1);
    updatePORTEl();
}}
      
      if (layers === 0) {
        if (existingBlockIndex !== -1) {
//alert("-")
          tileMap[dimension].splice(existingBlockIndex, 1);
          return;
        } else {

          tileMap[dimension].push([currentX, currentY, item]); 
        //  alert(item)
        //  newtilemap[dimension].push([currentX, currentY, item]); 
        }
      } else {

        tileMap[dimension].push([currentX, currentY, item]);
      //  newtilemap[dimension].push([currentX, currentY, item]); 
      }
      config.savedTileMap=tileMap;
     // alert("")
    }
  }

  updateViewport();
    }
}

  if(config.testmode==0){
  buildBlocksAroundPosition(x, y);
  updateViewport();
}}else{
const rect = content.getBoundingClientRect();
const x = Math.floor((event.clientX - rect.left) / tileSize2);
const y = Math.floor((event.clientY - rect.top) / tileSize2);
// Funkcja do zbudowania bloków w obszarze o określonym rozmiarze
// alert(TILES[item][0])
function buildBlocksAroundPosition(startX, startY) {
  if (config.testmode == 0) {
    for (let offsetX = -brushSize + 2; offsetX <= brushSize; offsetX++) {
      for (let offsetY = -brushSize + 2; offsetY <= brushSize; offsetY++) {
        const currentX = startX + offsetX - 1;
        const currentY = startY + offsetY - 1;
        const existingBlockIndex = config.spritesmap[dimension].findIndex(tile => tile[0] === currentX && tile[1] === currentY);
        if (layers === 0) {
          if (existingBlockIndex !== -1) {
            //alert("-")
            config.spritesmap[dimension].splice(existingBlockIndex, 1);
            updatePORTEl();
            return;
          } else {

            config.spritesmap[dimension].push([currentX, currentY, item2]);
            //  newtilemap[dimension].push([currentX, currentY, item]); 
          }
        } else {

          config.spritesmap[dimension].push([currentX, currentY, item2]);
          //  newtilemap[dimension].push([currentX, currentY, item]); 
        }
       // config.savedTileMap = tileMap;
        // alert("")
      }
    }

    updatePORTEl();
  }
}

if (config.testmode == 0) {
  buildBlocksAroundPosition(x, y);
  updateViewport();
}
}
  
  
}
/*
dld()
function dld(){
//  console.log(JSON.stringify(tileMap))
  setTimeout(dld,4000)
}*/
content.addEventListener('click', buildBlock);

const maxHistoryLength = 200;
function upd10() {

  lastplayerpos.push({ x: playerX, y: playerY });

  if (lastplayerpos.length > maxHistoryLength) {
    lastplayerpos.shift(); // Remove the oldest element
  }

}

function cofnijczas(ilerazycofnac) {
  for (let i = 0; i < ilerazycofnac; i++) {
    if (lastplayerpos.length > 1) {
      const previousPos = lastplayerpos.pop(); // Get the previous position
      playerX = previousPos.x;
      playerY = previousPos.y;
      // Update the player's visual position
      player.style.left = playerX * tileSize2 + 'px';
      player.style.top = playerY * tileSize2 + 'px';
    }
  }
}
</script> 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPS Counter</title>
    <style>
        #fpsCounter {
            position: fixed;
            z-index: 9999;
            bottom: 0;
            right: 0;
            padding: 5px;
            background-color: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="notaproject" id="fpsCounter"></div>
    <script>
        const fpsCounter = document.getElementById('fpsCounter');
        let frameCount = 0;
        let lastTimestamp = performance.now();
        function updateFPS() {
            const currentTimestamp = performance.now();
            const elapsedMilliseconds = currentTimestamp - lastTimestamp;
            const elapsedSeconds = elapsedMilliseconds / 1000;
            const fps = Math.round((frameCount / elapsedSeconds));
            fpsCounter.textContent = `FPS: ${fps}`;
            frameCount = 0;
            lastTimestamp = currentTimestamp;
            setTimeout(updateFPS,1000);
        }
        function animate() {
            frameCount++;
            requestAnimationFrame(animate);
        }
        updateFPS();
        animate();
    </script>
</body>
</html>
<style>
.enginebox{
  background:url('./boxes.png');
  background-size: 100% 100%;
  
}
  .added{
    pointer-events: all;
  }
</style>
<gui id="withgui" style="pointer-events: none">
  <div class="btns">
    <div class="null added"></div>
    <div class="btn added" id="Up"></div>
    <div class="null added"></div>
    <div class="btn added" id="Left"></div>
    <div class="null added"></div>
    <div class="btn added" id="Right"></div>
    <div class="null added"></div>
    <div class="btn added" id="Down"></div>
    <div class="null added"></div>
  </div>
</gui>
<!--<div onclick="toggleUplayer()" style="width:50px; height:50px; background: url('./zlayer1.png') center center/contain no-repeat; color:lime; text-align:center; font-size:30px; line-height:30px; position:absolute; right: 215px; top:16px; z-index: 99" class="notaproject"></div>
<script>
</script>-->
<div class="f notaproject enginebox" id="sus" style="position: absolute; width: 210px; height: calc(100vh - 2px) ; image-rendering: pixelated; background-size: 100% 100%; z-index: 999999;overflow: hidden;left:0;
overflow : scroll;">
  <div onclick="toggleVS()" class="enginebox" style="width:50px; height:50px; color:yellow; text-align:center; font-size:30px; line-height:30px; position:absolute; left: 10px; top:16px; animation: rainbow 3s infinite;">+</div>
<div onclick="toggleMENS(); playUpdateSound2()" class="enginebox" style="width:50px; height:50px;  color:yellow; text-align:center; font-size:30px; line-height:30px; position:absolute; left: 62px; top:16px; animation: rainbow 3s infinite;" class="nothing" >⚙️</div>
<div onclick="togglemode1(); playUpdateSound()" class="enginebox" style="width:50px; height:50px;   color:yellow; text-align:center; font-size:30px; line-height:30px; position:absolute; left: 114px; top:16px; animation: rainbow 3s infinite;">...</div>
  <div id="Iblocks" style="margin-top:70px; margin-left:20px;padding: 0;"></div>
  <div id="I2blocks" style="margin-top:0px; margin-left:20px;padding: 0;"></div>
</div>
<style>
  .btn{
    width:40px;
    height: 40px;
    background: #6F6F6FA1;
    margin:5px;
    float:left;
  }
  .null {
      width: 40px;
      height: 40px;
      background: #00000000;
      margin: 5px;
      float:left;
    }
    gui{
      position: abso;
      width:100vw;
      height:100vh;
      z-index 20;
    }
.btns{
  zoom: 1;
  position: absolute;
  bottom: 20px;
  left:10px;
  width: 150px;
}
</style>
</body>
</html>
<script>
function testy() {
  config.guiHTML = document.querySelector('gui').innerHTML;
//  config.guiHTML2 = document.querySelector('#project2').innerHTML;
  console.log(config.guiHTML);
}
function testa() {
  setTimeout(function () {
    if (config.customGUI == 1) {
      const elementyDoUsuniecia = document.querySelectorAll('.added');
      elementyDoUsuniecia.forEach(function (element) {
        element.remove();
      });
      document.querySelector('gui').innerHTML = config.guiHTML;
      document.querySelector('#project2').innerHTML = config.guiHTML2;
      if (document.getElementById('Left')) {
        document.getElementById('Left').addEventListener('touchstart', function (event) {
          event.preventDefault(); // Prevent default behavior
          leftButtonDown = 1;
        });
        document.getElementById('Left').addEventListener('touchend', function () {
          leftButtonDown = 0;
        });
      }
      if (document.getElementById('Right')) {
        document.getElementById('Right').addEventListener('touchstart', function (event) {
          event.preventDefault(); // Prevent default behavior
          rightButtonDown = 1;
        });
        document.getElementById('Right').addEventListener('touchend', function () {
          rightButtonDown = 0;
        });
      }
      if (document.getElementById('Up')) {
        document.getElementById('Up').addEventListener('touchstart', function (event) {
          event.preventDefault(); // Prevent default behavior
          upButtonDown = 1;
        });
        document.getElementById('Up').addEventListener('touchend', function () {
          upButtonDown = 0;
        });
      }
      if (document.getElementById('Down')) {
        document.getElementById('Down').addEventListener('touchstart', function (event) {
          event.preventDefault(); // Prevent default behavior
          downButtonDown = 1;
        });
        document.getElementById('Down').addEventListener('touchend', function () {
          downButtonDown = 0;
        });
      }
      var jumpElement = document.getElementById('Jump');
      if (jumpElement) {
        jumpElement.addEventListener('touchstart', function (event) {
          event.preventDefault(); // Prevent default behavior
          jump2(event);
        });
      }
      var atackelement = document.getElementById('Attack');
      if (atackelement) {
        atackelement.addEventListener('touchstart', function (event) {
          event.preventDefault(); // Prevent default behavior
          attack2();
        });
      }
document.addEventListener('keydown', function(event) {
    switch(event.key) {
        case 'w':
            if (document.getElementById('Up')) {
                upButtonDown = 1;
}
            if (document.getElementById('Jump')) {
              jump2(event);
            }
            break;
        case 'a':
            if (document.getElementById('Left')) {
                leftButtonDown = 1;
            }
            break;
        case 's':
            if (document.getElementById('Down')) {
                downButtonDown = 1;
            }
            break;
        case 'd':
            if (document.getElementById('Right')) {
                rightButtonDown = 1;
            }
            break;
        case 'x':
            if (document.getElementById('Attack')) {
attack2();
            }
            break;
case 'x':
if (document.getElementById('Attack')) {
  attack2();
}
break;
        case 'q':
            if (document.getElementById('Jump')) {
jump2(event);
            }
            break;
    }
    if (event.keyCode === 32) {
if (document.getElementById('Attack')) {
  attack2();
}
}
});
document.addEventListener('keyup', function(event) {
    switch(event.key) {
        case 'w':
            if (document.getElementById('Up')) {
                upButtonDown = 0;
            }
            break;
        case 'a':
            if (document.getElementById('Left')) {
                leftButtonDown = 0;
            }
            break;
        case 's':
            if (document.getElementById('Down')) {
                downButtonDown = 0;
            }
            break;
        case 'd':
            if (document.getElementById('Right')) {
                rightButtonDown = 0;
            }
            break;
        case 'x':
            if (document.getElementById('Attack')) {

            }
            break;
        case 'w':
            if (document.getElementById('Jump')) {

            }
            break;
    }
});
    }
  }, 1000);
}
testa();
window.setInterval(testy, 5000);
</script>
<div style="overflow:hidden;overflow:scroll;position: absolute; top:50vh; left:50vw; transform: translate(-50%,-50%); width: 90%; height:80%; background: black; padding: 10px; z-index: 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999;"class="entitymenu">
<div onclick="togglemenu()">
  close menu
</div>
<style>
  #contentofjsoneditor{
    zoom:0.8;
  }
</style>
<div id="contentofjsoneditor" style="z-index: 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999; ">
<div class="json-editor" >
    <button onclick="addEntity()">add</button>
    <button onclick="saveJson()">save</button>
  </div>
  <details>1.type null in editor to turn off the option <br>
2. ENTITIES configuration is really hard to work with it there is almost everything possible 
but update will come with others options :) </details>
  <div id="entities-container"></div>
  </div>
</div>
<!-- Building -->
<style>
  #container123{
    position: absolute; top:0;right:100px;zoom:0.7;
    transform : translate(-50px,0);
    font-size: 7px;
  }
  .box0{ width:50px;height:60px;background: #6F6F6F; float: left; margin:4px; justify-content: center; align-items: center ; display: flex; font-size: 30px}
  .box1{ width:50px;height:60px;background: #ACACAC; float: left; margin:4px; justify-content: center; align-items: center ; display: flex; font-size: 20px}
</style>
<div id="container123" class="notaproject d dr hide">
  <div id="add123" class="box0" onclick="add123()"   >+</div>
  <div id="value123" class="box1"                      >doesn't work :P </div>
  <div id="sub123" class="box0" onclick="sub123()"   >-</div>
</div>
<script>
  var item=1;
  var buildmap=1
  var item2=1
  function add123(){ if(item > -1 ){ item ++ ; updt()}}function sub123(){if(item > 0 ){ item -- ; updt()}}function updt(){document.getElementById('value123').innerText=item}
</script>
<!-- dimensions -->
<style>
  #container1232{
    position: absolute; top:0px;right:155px
    ;zoom:0.7;
    font-size: 7px;
    transform : translate(-50px,0);
  }
.d{
  z-index: 999999
}
</style>
<div id="container1232" class="notaproject d dr hide">
  <div  class="box0" onclick="add1232()"   >+</div>
  <div id="value1232" class="box1"                      >dimension</div>
  <div class="box0" onclick="sub1232()"   >-</div>
</div>
<script>
  function add1232(){ if(dimension > -1 ){ dimension ++ ; updt2()}}function sub1232(){if(dimension > 0 ){ dimension -- ; updt2()}}function updt2(){document.getElementById('value1232').innerText=dimension; updateViewport();updatePORTEl();}
</script>
<!-- brushSize -->
<style>
  #container1233{
    position: absolute; top:0px;right:210px;zoom:0.7;
    font-size: 7px;
    transform : translate(-50px,0);
  }
</style>
<div id="container1233" class="notaproject d dr hide">
  <div  class="box0" onclick="add1233()"   >+</div>
  <div id="value1233" class="box1"                      >brush size</div>
  <div class="box0" onclick="sub1233()"   >-</div>
</div>
<script>
  function add1233(){ if(brushSize > -1 ){ brushSize ++ ; updt3()}}function sub1233(){if(brushSize > 0 ){ brushSize -- ; updt3()}}function updt3(){document.getElementById('value1233').innerText=brushSize; updateViewport()}
</script>
<div id="toggleButton" style="width:50px;height:40px;background: #6F6F6F; float: left; margin:4px; justify-content: center; align-items: center ; display: flex; position:absolute;font-size: 5px; top:50px; right:50px; z-index:999"onclick="toggleLayers()" class="notaproject">build on blocks</div>
<script>
  let layers = 0;
function toggleLayers() {
  layers = 1 - layers
  const button = document.getElementById('toggleButton');
  if (layers === 1) {

    button.style.backgroundColor = 'green';
  } else {

    button.style.backgroundColor = ' #6F6F6F'; // 
  }

}
</script>
  <style>
.menu-container {position: absolute;bottom: 15%;width:0%;height:0%;right: 15%;text-align: center;display: block;z-index: 9999999;}
.menu-content {
    background-color: #F0F0F0;
    z-index: 9999999;
    padding: 30px;
    position: fixed;
    z-index: 2;
    display: none;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 60%;
    height: 70%;
    overflow: hidden;
    overflow: scroll;

    background: url('./boxes.png') no-repeat;
    background-size: 100% 100% ;
    background-attachment: fixed;
    background-position:0% 0%;
    image-rendering: pixelated; 
}
.menu-toggle {cursor: none;border-radius: 100%;background-color: #4CAF50;color: white;padding: 20px 20px;border: none; position: fixed; bottom: 50%; left:0px; z-index: 99999;}.menu-toggle:hover {background-color: #45a049;}.menu-container:hover .menu-content {display: block;} 
.mn div{ cursor: none;background-color: #4CAF50;color: white;padding: 5px 20px;border: none;width:calc(100% - 0px);}
.menu2-content {background-color: #0E0E0E;padding: 5px;position: fixed;border: 1px solid #1C1C1C;top: 50%;left: 50%;transform: translate(-50%,-50%);
  width:95%;height:95%;overflow: hidden; 
  color:white;
}
.menu0-content {background-color: #C4C4C4;padding: 5px;position: absolute;border: 1px solid #EDEDED;top: 50%;left: 50%;transform: translate(-50%,-50%);
  width:80%;height:80%;overflow: hidden; overflow: scroll;
}
.closebutton{
  width: 20px;
  height:20px;
  justify-content: center; 
  align-items: center;
  display: flex;
  background: #8F3434;
  border-radius: 20%;
}
  </style>
</head>
<body>
<style>
</style>
<!--  <div class="menu-container notaproject" onclick="playUpdateSound2(); toggleMENS()">
    <button class="menu-toggle"></button>
  </div>-->
  <script>
    let tgl=0
    function toggleMENS(){
      if(tgl==0){
        tgl=1
          document.querySelector(".menu-content").style.display="block"
      }else{
        tgl=0
        document.querySelector(".menu-content").style.display="none"
      }
    }
  </script>
    <div class="menu-content" style="z-index: 999999999;" >
<pre style="white-space: pre-wrap" class="mn">
  <h3>Menu</h3>
<hr>


<div onclick="toggleHTMLEDITOR()" style="animation: 5s rainbow infinite cubic-bezier(0.19, 1, 0.22, 1);" style="background: yellow">newHTML5 CODE
</div>
<div onclick="visibility('.menu2-content'); toggleMENS()" style="animation: 5s rainbow infinite cubic-bezier(0.19, 1, 0.22, 1);" style="background: yellow">Code
</div>
<div onclick="visibility('.menu-content'); playUpdateSound3();toggleMENS()"  style="background: red">
Close Menu
</div>

<hr>

<div onclick="EditorMusicPlay('./Dark Loop.mp3')">toggle Play Dark Forest </div>
<div onclick="EditorMusicPlay('./Mushroom Design.mp3')">toggle Play Mushroom Design </div>
<div onclick="EditorMusicPlay('./Retro Forest .mp3')">toggle Play Retro Forest</div>
<hr>

<div style="background: coral" onclick="visibilitytoggle('SoundMaker')">Sound Maker</div>

    <div style="background: coral" id="" onclick="hideee()">open drawing editor</div>
<div   onclick="saveToFile()">SaveToProjectFile</div>
<div   onclick="saveToFileasJs()">SaveAsFinnalProjectJSfile</div>
<div onclick="togglemenu();playUpdateSound3();toggleMENS()" >
  make entity Tiles (menu)
</div>
<div onclick="loadfile();" style="background: blue">
  LoadProjectFile
</div>
<div onclick="editor ='left';up1()" style="background: deepskyblue">
  Editor Left
</div>
<div onclick="editor ='right';up1()" style="background: deepskyblue">
  Editor right
</div>
<div onclick="config.savedTileMap.push([]);tileMap.push([]); config.spritesmap.push([]); alert(config.spritesmap.length+' '+config.savedTileMap+' '+tileMap)" style="background:wheat">
  + Add dimension + add sprites Dimension 
  
</div>
<div onclick="config.roommode=2">Room scroller</div>
<div onclick="config.roommode=1">Closer sidescroller</div>
<div onclick="config.roommode=0">Normal sidescroller</div>
<div onclick="config.renderertype=1">antianalising</div>
<div onclick="config.renderertype=0">smoothing</div>
<div onclick="handleFileContent(JSON.stringify(example2));toggleMENS()">
  load example platformer game
</div>
<div onclick="config.information1bar=1"> show infos Killed Score </div>
<div onclick="config.information1bar=0"> hide infos Killed Score </div>

<div onclick="config.information2bar=1"> show pause </div>
<div onclick="config.information2bar=0"> hide pause </div>
<div onclick="config.information3bar=1"> show restart() </div>
<div onclick="config.information3bar=0"> hide restart() </div>
<div onclick="
loadtestgame();toggleMENS()
">
  load Game robot wants fangame
</div>
<script>
</script>
<div onclick="handleFileContent(JSON.stringify(example3));toggleMENS()">
  load example Apple Man game
</div>
<div onclick="document.getElementById('tutor').style.display='block';toggleMENS()" style="background: gray">
ASM tutor
</div>
<div onclick="topdownbuttonsexmp();toggleMENS()">
TopDownGameButtons
</div>
<div onclick="platformergamebuttonexmp();toggleMENS()">
  platformergamebuttonexmp
</div>
<div onclick="toggh();toggleMENS(); updateViewport()" style="background: navy">
  show classes
</div>
<div onclick="rmmake()" style="background: red">
  remove everything make
</div>
<style>
</style>
  <input type="range" id="mySlider" min="-30" max="30" value="0">
bg size:  <t id="sliderValue" style="color:black;">0</t>
<div onclick="stickybg(1);">
  sticky background 
</div>
<div onclick="stickybg(0);">
  floating background 
</div>

<div onclick="config.newengine4=1;">
  config newengine4 (1) do not use it
</div>
<div onclick="config.newengine4=0;">
  config newengine4 (0)
</div>
  <script>
  var olderaudioinstance=null
  var toggleff1=0
function EditorMusicPlay(muscle){
  toggleff1=toggle(toggleff1)
  if(toggleff1==1){
  if (audioInstance) {
    
olderaudioinstance=audioInstance
      audioInstance.pause();
audioInstance.currentTime = 0;
audioInstance = null;
    }
    
      

      let base64Wav = muscle;

      audioInstance = new Audio();
      audioInstance.src = base64Wav;
      audioInstance.setAttribute('preload', 'auto');

      document.body.appendChild(audioInstance);
      audioInstance.play();
      audioInstance.loop = true;
      toonce = 0;
    
}else{
  audioInstance.pause();
audioInstance.currentTime = 0;
audioInstance = null;

  if(olderaudioinstance!==null){
    var gnk=olderaudioinstance
    if(gnk.length){
  let base64Wav = olderaudioinstance;

audioInstance = new Audio();
audioInstance.src = base64Wav;
audioInstance.setAttribute('preload', 'auto');

document.body.appendChild(audioInstance);
audioInstance.play();
audioInstance.loop = true;
toonce = 0;
}}}}
  
  function stickybg(num) {
    if (!('stickybg1' in config)) {
        config['stickybg1'] = num;
    } else {
        config.stickybg1 = num;
    }
    if (config.stickybg1 == 0) {
        let content = document.getElementById('content');
        let content2 = document.getElementById('content2');
        content.style.backgroundImage = getComputedStyle(content2).backgroundImage;
        setTimeout(function(){
            content2.style.backgroundImage = ''; 
        }, 1000);
    } else {
        let content = document.getElementById('content');
        let content2 = document.getElementById('content2');
        content2.style.backgroundImage = getComputedStyle(content).backgroundImage;
        content.style.backgroundImage = '';
    }
}

function loadfile() {

  const input = document.createElement('input');
  input.type = 'file';
  let specialname2=".dl , .js"
input.accept=`${specialname2}`

  input.addEventListener('change', function() {
    const file = input.files[0];
    toonce = 1;
    if (file) {

      const reader = new FileReader();
      reader.onload = function(e) {
        let textContent = e.target.result;

        handleFileContent(textContent);
        
      };
      reader.readAsText(file);
    }
  });

  input.click();
}
let tdt=0;
function handleFileContent(textContent) {

document.getElementById('Econtent').innerHTML=""

config = JSON.parse(textContent);

dimension=config.dimension||0
  try {
    config = JSON.parse(textContent);
     tdt=JSON.parse(textContent)
     if (!('killed' in config)) {
  config['killed'] = 0;
} else {
killed=config.killed
}
    canJUMP=0
    gravity=config.gravity
    if (!('deletedtiles' in config)) {
      config['deletedtiles'] = [];
    } else {
    }
    if (!('airjump' in config)) {
      config['airjump'] = 0;
    } else {
    }
        if (!('folder' in config)) {
  config['folder'] = {"texture":{"player":[],"projectile":[0,0]},"textures":{},"sounds":{"player":[],"ambients":[]},"script":{},"config":{}}
} 
if (!('playershoots' in config)) {
  config['playershoots'] = 0
}
loadingdata=1
setTimeout(function(){
  lastplayerpos.push({ x: playerX, y: playerY });
  loadingdata=0
},4000)
    playerY = tdt.spawnY-0.5;
    playerX = tdt.spawnX;
    lastplayerpos.push({ x: playerX, y: playerY });
    if(!(config.folder)){
    }
    if (!('stickybg1' in config)) {
      config['stickybg1'] = 0;
    } else {
    }
    if (config.stickybg1 == 0) {
      let content = document.getElementById('content');
      let content2 = document.getElementById('content2');
      if(content2.style.backgroundImage){
      content.style.backgroundImage = getComputedStyle(content2).backgroundImage;
      setTimeout(function() {
        content2.style.backgroundImage = ''; 
      }, 1000);}
    } else {
      let content = document.getElementById('content');
      let content2 = document.getElementById('content2');
      content2.style.backgroundImage = getComputedStyle(content).backgroundImage;
      content.style.backgroundImage = '';
    }
const playerskin69=config.playerskin1

document.querySelector('.player').style.background=`url(${playerskin69})`
playerskin=playerskin69
    updateViewport() 
  setTimeout(function() {
    newtilemap=config.savedTileMap
    if (config.DarknessEffect == 1) {
      let vp = document.getElementById("viewport")
      let el = document.createElement('div')
      el.style = `width:${vp.style.width};height:${vp.style.height};`
      el.className = 'dark effects added'
      document.querySelector('#project').appendChild(el)
    } else {
      let y = document.querySelectorAll('.effects')
      for (var i = 0; i < y.length; i++) {
        if (y[i].classList == 'dark') {
          y[i].remove()
        }
      }
    }
  }, 1000)
    deletedtiles=[]
    document.getElementById('edytor').textContent=config.code
    stop=1
    code = config.code;
    classicspeed = config.norspeed;
   setPlayer(config.px*tileSize,config.py*tileSize)
    speed = config.speed;
    playerskin = config.playerskin1;
    TILES = config.blocks;
    tileMap = config.savedTileMap;
    gravity = config.gravity;
    content.style.backgroundSize=(config.bgsize)+"px"
    code=config.code
    if (audioInstance) {

      audioInstance.pause();
      audioInstance.currentTime = 0;
      audioInstance = null;
    }
    if (config.music !== '') {
      let base64Wav = config.music;
if(config.oldmusic!==undefined&&config.oldmusic!==null){
if (config.oldmusic.slice(0, 10) !== config.oldmusic) {
    base64Wav = config.oldmusic;
} else {
    base64Wav = config.music;
}}

      audioInstance = new Audio();
      audioInstance.src = base64Wav;
      audioInstance.setAttribute('preload', 'auto');

      document.body.appendChild(audioInstance);
      audioInstance.play();
      audioInstance.loop = true;
      toonce = 0;
    }
    if (config.customcamera == 1) {
      viewport.scrollTo(config.cameraX * tileSize2 - viewportWidth / 2, (config.cameraY * tileSize2) - viewportHeight / viewportHeight * viewportHeight / 2)
    }
    const contentElement = document.getElementById("content");
    document.querySelector('gui').innerHTML=config.guiHTML
    bgimg=config.bg
   ukonczoneGUI()
    contentElement.style.backgroundImage = `url('${config.bg}')`;
    document.getElementById('Scontent').innerHTML=''
    document.getElementById('Econtent').innerHTML=''
    tileConfig = config.entities
checki1()
    moveTilesRandomly()
    setTimeout(function(){
      curline=0
      edit()
      currentLine=0
      generateAllTiles()
       candocmd = 1
       curline = 0
       currentLine = 0;
       candothath = 0
       defy = 0
       jmptimes = 0
      stop=0
      RESET()
      displayEntities();
//alert(config.bg)
                    if (config.stickybg1 == 0) {
                      document.getElementById('content').style.backgroundImage = `url('${config.bg}')`
                      document.getElementById('content2').style.backgroundImage = ``
                    } else {
                      document.getElementById('content2').style.backgroundImage = `url('${config.bg}')`
                      document.getElementById('content').style.backgroundImage = ``
                    }
    },3000)

 tileSize = config.tilesize; 
document.querySelector('#content2').style.width = vp.style.width
document.querySelector('#content2').style.height = vp.style.height
document.querySelector('#content2').style.zoom = vp.style.zoom
setTimeout(edit,5000)
    //alert((config));
    updatePORTEl()
  } catch (error) {
    console.error("Błąd podczas parsowania pliku JSON:", error);
  }
}
  function rmmake(){
    document.querySelector('.Scontent').innerHTML=""
  }
const slider = document.getElementById('mySlider'), valueDisplay = document.getElementById('sliderValue');
let diff = 0, currentValue = parseInt(slider.value);
valueDisplay.textContent = currentValue;
slider.addEventListener('input', () => { diff = parseInt(slider.value); valueDisplay.textContent = diff + currentValue; });
slider.addEventListener('touchend', () => { slider.value = 0; currentValue += diff; setTimeout(() => { valueDisplay.textContent = currentValue;config.bgsize=currentValue;content.style.backgroundSize=(config.bgsize)+"px" }, 10); });
setTimeout(function(){
if(config.debugmode==1){
topdownbuttonsexmp()
document.querySelector('.player').style.background = `url('/debug.png')`
updateViewport();

document.querySelector('.player').style.background=`url("${config.playerskin1}");`;
}
updatePORTEl()
},3000)
  </script>
<!--  <input type="range" id="mySlider2" min="-10" max="10" value="0">
blocks size:  <t id="sliderValue2" style="color:black;">0</t>-->
  <script>
const slider2 = document.getElementById('mySlider2'), valueDisplay2 = document.getElementById('sliderValue2');
let diff2 = 0, currentValue2 = 30
valueDisplay2.textContent = currentValue2;
slider2.addEventListener('input', () => { diff2 = parseInt(slider2.value); valueDisplay2.textContent = diff2 + currentValue2; });
slider2.addEventListener('touchend', () => {stop=1; slider2.value = 0; currentValue2 += diff2; setTimeout(() => { valueDisplay2.textContent = currentValue2; }, 10); tileSize=currentValue2;tileSize2=currentValue2; setPlayer(6.5*30,6.5*30);  numVisibleTilesX = Math.ceil(viewportWidth / tileSize);document.getElementById("Econtent").innerHTML="";
 numVisibleTilesY = Math.ceil(viewportHeight / tileSize); setTimeout(function(){
   stop=0;
   config.tilesize=currentValue2
 },3000)});
  </script>
  <div>"make9":[2,"null",4,3,0,0,[0,0,999999,999999],false,[[0,3],[0,-3]],0,0,0,".player",1]
  "class/tag":[speed,movement('','move','avoid','follow'),distance-to-player(blocks),randommove(1/0), collisionblockforplayer like collisionblocks,Enemy HP,[x,y,x2,y2],false,if 'move'=[[0,3],[0,-3]],hurtblocklikespike, scrip doesn't work if enemy is not visible,give score,custom sprites collision for attack def='player',anable custom sprite collision, hascollisionwithblocks(1/0/null)]
    var [speed, movementType, distance, randomMovement, collision, initialHp, area, deletebool,arena,hurt,vi,score1,collisionobject="player",detectanabled,collisionwithotherblocks,deletewhencustommoveended,anableshootingattackforentities,collectable] = tileConfig[tileId];
</div>

<style>
    .json-editor {
        margin-bottom: 10px;
    }
    .json-editor button {
        margin-right: 10px;
    }
    .entity {
        margin-bottom: 10px;
        cursor: pointer;
    }
    .option {
        margin-bottom: 5px;
    }
</style>
<script>

var testexample={"examples":{"alltiles0":[2,"move",0,3,0,1,[0,0,999999,999999],true,"[[0,0],[0,0]]",0,1,0,"player",,,,,,,1]}}

    function displayEntities() {
        const container = document.getElementById('entities-container');
        container.innerHTML = '';
        for (const entity in config.entities) {
            if (config.entities.hasOwnProperty(entity)) {
                const entityDiv = document.createElement('div');
                entityDiv.classList.add('entity');
                entityDiv.textContent = entity;
                const deleteButton = document.createElement('button');
                deleteButton.style.animation='5s rainbow infinite'
                deleteButton.style.transform="translate(90vw,0)"
                deleteButton.style.border="none"
                deleteButton.style.outline="none"
                deleteButton.style.background="none"
                deleteButton.textContent = 'x';
                deleteButton.onclick = function() {
                    delete config.entities[entity];
                    displayEntities();
                };
                entityDiv.appendChild(deleteButton);
                entityDiv.addEventListener('click', () => editEntity(entity));
                container.appendChild(entityDiv);
            }
        }
    }
    function addEntity() {
    const entityName = prompt("Enter entity identyficator in your sprite (S<number>):");
    if (entityName) {
        const entityId = parseInt(entityName);
        if (!isNaN(entityId)) {
            const selectedExample = "alltiles0";
            const entityKey = "alltiles" + entityId;

            config.entities[entityKey] = JSON.parse(JSON.stringify(testexample.examples[selectedExample]));
            displayEntities();
        } else {
            alert("Please enter a valid number.");
        }
    }
}
setTimeout(function (){
  displayEntities();
},3000)
    function editEntity(entityName) {
        const options = config.entities[entityName]

        const optionNames = getOptionNames();
        let optionHTML = '';
        for (let i = 0; i < optionNames.length; i++) {
            const optionValue = options[i] !== null ? options[i] : ''; // Check if value is null, if yes, show empty string
            const optionName = optionNames[i];
            if(!optionName.startsWith('T:')){
            optionHTML += `<div class="option">
                                <label>${optionName}</label>
                                <input type="text" value="${optionValue}" data-index="${i}" data-entity="${entityName}" oninput="updateOption(this)">
                           </div>`;
        }else{
          optionHTML += `<div class="option">
                                          <label>${optionName} <td style="color:red;" >'Music'</td> </label>
                                          <input type="file" value="${optionValue}" data-index="${i}" data-entity="${entityName}" onchange="updateFileOption(this)">
                                     </div>`;
        }}
        optionHTML += `<button onclick="saveEntity('${entityName}')">save</button>`;
        document.getElementById('entities-container').innerHTML = optionHTML;
    }
    function updateOption(input) {
    const entityName = input.getAttribute('data-entity');
    const index = parseFloat(input.getAttribute('data-index'));
    let newValue = input.value;
config.entities[entityName][index] = newValue;

    try {
       let parsedValue = JSON.parse(newValue);
        if (parsedValue !== null && typeof parsedValue === 'object') {

            newValue = parsedValue;
        } else {

            newValue = input.value;
            if (!isNaN(newValue)) {
              newValue = parseFloat(newValue); 
            }
        }

  newValue = parsedValue;
    } catch (error) {

        newValue = input.value;
        if (!isNaN(newValue)) {
          newValue = parseFloat(newValue);
        }else{
          
        }
        let parsedValue = (newValue);
                if (parsedValue == "null" || parsedValue == "undefined" || parsedValue == "") {

          newValue = null 

        }
    }
    config.entities[entityName][index] = newValue;

}

function updateFileOption(input) {
  const entityName = input.getAttribute('data-entity');
  const index = parseFloat(input.getAttribute('data-index'));
  let newValue = input.value;
const file = input.files[0];
if (file) {

  const reader = new FileReader();
  reader.onload = function(e) {
    const base64Wav = e.target.result;
    reader.readAsDataURL(file)
    config.entities[entityName][index] = base64Wav;

  }
  reader.readAsDataURL(file);
}
}

    function saveEntity(entityName) {
        displayEntities();
    }
    function saveJson() {
        alert(JSON.stringify(config));
    }
    function getOptionNames() {

        return [
            "<p style='color:lime' > Speed(num)",
            "<p style='color:lime' > Movement Type(avoid,move,follow)",
            "<p style='color:lime' > Distance(num)",
            "<p style='color:lime' > Random Movement(1/0/3 for Move)",
            "<p style='color:red' > Collision-Block for a player(1/0)",
            "<p style='color:red' > Initial HP(Num)",
            "Area For Entity([startX,startY,endX,endY])",
            "Delete Bool(Boolean)",
            "<p style='color:lime' > arena Pattern moving ([[x,y],[x,y]]) [[-2,0],[2,0]] etc",
            "<p style='color:cyan' > Hurt Player(1/0)",
"<p style='color:lime' >Script Doesn't work if sprite is out of Viewport  <p style='color:blue'>(virtualization)</p></p>", 
            "Score1(1/0)",
            "<p style='color:yellow' >important !: Collision Object type 'player' default class that it will be default target. for example move follow for player",
            "Detect Enabled ( I don't remember what this doing )",
            "<p style='color:cyan' > Collision with Other Blocks(1/0)",
            "Delete When Custom Move Ended(1/0)",
            "<p style='color:red' > Your Shooting attack can Hurt this entity (1/0)",
            "Collectable(1/0)",
            "SpawnPointBlock(1/0)",
            "<p style='color:cyan' > CantBeDamaged(1/0) only By player doesn't work for example for a despawn",
            "Teleport by([y,x])",
            "<p style='color:pink' > Move Tiles when it is defaced by([(i...),x,y])",
            "<p style='color:pink' > spawn [duration,(i...)]",
            "<p style='color:red' > despawn ticks",
            "goes 1 tick one direction good for projectiles :) (1)on else off",
"changeLoopMusicTodefaul",
            "T: changeLoopMusic",
            "ability ['config[optionName]',Value,'operator '+' '-' '=''] options: (hp maxhp shoot airjump)",
            "<p style='color:orange' >noAttackfunction (1/0) you don't need to click attack to make damage for this entity</p>",
            "Respawn(1/0)",
            "collisionevent=projectilespeed(num)",
            "collisionevent=projectilenomove(1/0)",
            "collisionevent=projectileduration(num)/ticks ",
            "collisionevent=projectilelifetime/per few ticks",
            "T: collisioneventprojectiletexture",
            "collisionevent=projetitlesize number",
            "Code In Entities 0 _ 0 how ? ['1:\\n2:\\n3:',0]",
            "Puzzle Block (1/0) with i(object) / you dont need this if you use avoid, distance:2, collision block for player, speed: 6",
            "back to start position when pattern ended",
            "<p style='color:lime' > gravity",
            "change Code Variablecollisionevent [variable,value]",
            "T: hurttexture ",
            " hurtdelaytexture (number ms)",
            "<p style='color:lime' > reversedistance !( distance ) <num>",
"T: collisiontexture",
"distance2 <number> /disabled",
"movementType2 [move avoid follow]/ do not work",
"collisionobject2 [name]/disabled",
"whendistance2makepattern (in PM 2.9 full)/disabled",
"<p style='color:orange' > < NPC > Dialogue by an collision ['hello','world']",
"<p style='color:orange' >collision (eval javascript ) </p>",
"NPCdialogueends_remove (1) else do not",
"<p style='color:pink' > NPCdialogueends_spawn and kill this (i...)",
"collisiondistance <num> 'disabled'",
"Spawn 2 [duration,(i...)]",
"<p style='color: purple' > show Hp near entity (1)/0",
"<p style='color:pink' >moveonlywhenplayerlooking, // 1/0 ",
"<p style='color:pink' >moveonlywhenplayerlookingaway // 1/0",
"random teleporting [duration, xmin, xmax, ymin, ymax] !=='undefined' ",
"collision and killed then remove and move tiles [killed,(i..),x,y]",
"<p style='color:yellow' > interesting OPTION : spawn if defaced (i..)",
"ChangeifcollisionBaclgroundtexture(1/0)",
"backgroundimg from (i...)",
"hide id when collision (ID)",
"show id when collision (ID)",
"<p style='color: lime' > minimumdistance",
"T: playertextureleft",
"T: playertextureright",
"T: playertextureup",
"T: playertexturedown",
"T: playertexturestayleft",
"T: playertexturestayright",
"T: playertexturedefault",
"T: playertexturestaydown",
"changeplayertexture collision 1/0",
"resetkills 1/0 collision ",
"if collision and entity exist on viewport attack this < S > give cant be damaged and 1 hp for better experience",
"if collision with other entity attack this < S >",
`ddotherclasses ["class","nextclass"]  projetitle is special class it used for all hurtable with anableshootingattackforentities sprites for kiling it `,

"<p style='color: red' >collisionchangedimension (number of dimension)</p>",

"lookatobject1/0",
"spawningdistance", //number
"spawningoffset [x,y]", //[x,y]
"spawnnumber",
"despawnMS despawning in Mili seconds (num) /buggy doesn't work on spawned objects",
"distance collision player (number def 1)",
"deal damage player (num def 1) ",
"changeplayerdamage on collision (number def 1)",
"<p style='animation: 5s rainbow infinite; filter:sepia(50%);' >Spawn3without Spawn distance spawning inside [duration,i..] </p>",
"T: <p style='animation: 5s rainbow infinite; filter:sepia(50%);' >drop a music loop will be played if dialogue ends </p>",
"<p style='animation: 5s rainbow infinite; filter:sepia(50%);' >changedimensionifdeffacted (number) </p>",
"collisionchangerandomdimension [min ,max]",
"disabled - use index instead whenkilledspawnSprite (S...)",
"T: dialiguesounds", //+stop
"ifvariablekillthiswhencollision ['definedVariable','=,>,<,!=',number] ",
"ifvariablekillthiswhenitspawnonmap ['definedVariable','=,>,<,!=',number] ",
"<p style='animation: 5s rainbow infinite; filter:sepia(50%);' >Interesting: </p> regenerate Player position by a ticks (10) is more like a 1 second and use one direction follow good for projectile this will reset player current position by a time (enter number) ",
"<p style='color:lime' >delete If it is outside of viewport also need virtualization anabled ( enter 1/0 good for blocks )</p>",

"<p style='animation: 5s rainbow infinite; filter:sepia(50%);' >Interesting: </p> Block Type: 'float','ladder','water'  (enter) ",
"Weird 3D block if player on bottom this ZIndex=1 else ZIndex=10 (1/0)",
"Hide(0)/Show(1) 'player' (else do nothing)",
"CUSTOM EVENT COLLISION DISTANCE < def=1 full block",
"T: change player texture stay up",
"collision change screen filter [r,g,b,a] example:[\"1\",\"1\",\"1\",\"0.5\"]",
`<p style='animation: 5s rainbow infinite;'>3.0[nafu] not a finnal update  50% of this instructions configuration are not understandable for a human :P  <br><br> IMPORTANT : do not use ' use instead " make JSON OBJECT '[]' like this :["variable",1,"="] <br> type :null <br> to disable option</p>`,
/*
playertextureleft,
playertextureright,
playertextureup,
playertexturedown,
playertexturestayleft,
playertexturestayright,
playertexturedefault,
playertexturestaydown,
changeplayertexture,
resetkills,
ifentityexistonVPmovetilesandthiskill,
otherentitycollision,
addotherclasses,
collisionchangedimension,
*/
//"add ID (yourID)"
//"can hurt and move when you damaged it (1/0)",
        ];
        /*gethurttexture,gethurtdelay,
// experimental features
reversedistance ,
collisiontexture,
distance2,
movementType2,
collisionobject2,
whendistance2makepattern,*/
    }
</script>
<div onclick="emptyproj()" style="background: coral">
 makeEmptyProject (clearing Map,gravity,Blocks etc)
</div>
<div onclick="empty20()">
empty( tiles/ not map )
</div> <br>
<div onclick="empty02()">
  empty( map / not tiles )
</div> <br>
<div style="background: rebeccapurple"  onclick="backteleport()">
EXECUTE:  Teleport to spawn pos
</div>
<script>
function backteleport(){
  playerY=config.spawnY;
  playerX=config.spawnX;
  updateViewport()
}
  function empty20() {
  playerY = 200;
  playerX = 200;
  TILES = []
  
  document.querySelector('#Econtent').innerHTML = ""
  document.querySelector('#Iblocks').innerHTML = ""
  updateViewport()
}
function empty02(){
playerY=200;
playerX=200;

tileMap=[[],[],[]]
gravity=0
document.querySelector('#Econtent').innerHTML=""

updateViewport()
}
</script>
<div onclick="
newWidth = config.width*config.zoomadd;
newHeight = config.height*config.zoomadd;
cfigZ=1; config.zoomadd=1
vp.style.zoom = cfigZ*config.zoomadd;
 newWidth = config.width;
 newHeight = config.height;
vp.style.width = newWidth + 'px';
vp.style.height = newHeight + 'px';
">
 off zoom
</div>
<div onclick="gravity=0; ">
  top down mode
</div>
<div onclick="gravity=1; ">
  gravity
</div>
<script>

  function fileSelection(file, variable, index) {
    console.log("file:", file);
    console.log("var:", variable);
    console.log("ivar:", index);

    if(index!==-1){
    variable[index] = file;
    }else{
    }
    console.log("var:", variable);
  }
  function changeVariable(file,variable, index) {

    fileSelection(file, variable, index);
  }

  function handleFileButtonClickA(inputId, index) {
    document.getElementById(inputId).click();
  }

  function handleFileInputChangeA(event,variable, index) {
    const file = event.target.files[0];
        // Create file reader object
        const reader = new FileReader()
        // Convert image to data URL
        reader.readAsDataURL(file)
    config.folder.texture.player[0]=playerskin
        reader.addEventListener('load', () => {
    changeVariable(reader.result,variable, index);
        });
  }
</script>

<div>Experimental : It only works on newer update 1.<stroke class="verisondata"></stroke></div>
<script>
function updtd(){
if(config.v){
  document.querySelector('.verisondata').innerText=config.v
}else{
  document.querySelector('.verisondata').innerHTML=0
}
}
window.setInterval(updtd,6000)
</script>
<div>on version 1.1 Experimental</div>
<button>player take damage</button>
<input type="file" id="fileInput30" onchange="handleFileInputChangeA(event,config.folder.texture.player,  8)" />

<hr>
<h2>Player Texture</h2>
Player Left
<input type="file" id="fileInput10" onchange="handleFileInputChangeA(event,config.folder.texture.player,  1)" />
Player Right
<input type="file" id="fileInput20" onchange="handleFileInputChangeA(event,config.folder.texture.player,  2)" />
Stay Right
<input type="file" id="fileInput60" onchange="handleFileInputChangeA(event,config.folder.texture.player,  4)" />
Stay Left
<input type="file" id="fileInput50" onchange="handleFileInputChangeA(event,config.folder.texture.player,  5)" />
Player Jump
<input type="file" id="fileInput30" onchange="handleFileInputChangeA(event,config.folder.texture.player,  3)" />
Player Down
<input type="file" id="fileInput30" onchange="handleFileInputChangeA(event,config.folder.texture.player,  6)" />
Player Stay Down
<input type="file" id="fileInput30" onchange="handleFileInputChangeA(event,config.folder.texture.player,  7)" />
Player Stay Up
<input type="file" id="fileInput30" onchange="handleFileInputChangeA(event,config.folder.texture.player,  9)" />
<br>
Player Jump sound
<input type="file" id="fileInput70" onchange="handleFileInputChangeA(event,config.folder.sounds.player,  0)" />
Player attack sound
<input type="file" id="fileInput70" onchange="handleFileInputChangeA(event,config.folder.sounds.player,  1)" />
 Player Hit Sound
<input type="file" id="fileInput70" onchange="handleFileInputChangeA(event,config.folder.sounds.player,  2)" />

<div onclick="config.playershoots=1 ">
  playershoots ? true
</div>
<div onclick="config.playershoots=0 ">
  playershoots ? false
</div>
<button onclick="handleFileButtonClickA('fileInput4', 2)">player projectile</button>
<input type="file" id="fileInput40" onchange="handleFileInputChangeA(event,config.folder.texture.projectile,0)" />

<!-- Input -->
<div>hp barleft </div>
<input type="text" id="leftInput" oninput="editInputVariable(this.value, 'left')">
<div>hp barright</div>
<input type="text" id="rightInput" oninput="editInputVariable(this.value, 'right')">
<div>hp bartop</div>
<input type="text" id="topInput" oninput="editInputVariable(this.value, 'top')">
<div>hp barbottom</div>
<input type="text" id="bottomInput" oninput="editInputVariable(this.value, 'bottom')">
<div>hp number</div>
<input type="text" id="bottomInput" oninput="editInputVariable(this.value, 'numberHP')">
<div>hp max</div>
<input type="text" id="bottomInput" oninput="editInputVariable(this.value, 'maxHp')">
<div>
{
 projectile:{
 speed
<input type="text" id="bottomInput" oninput="editInputVariable3(this.value, 'projetitlecfig', 'speed')">
 lifetime
<input type="text" id="bottomInput" oninput="editInputVariable3(this.value, 'projetitlecfig', 'timelife')">
 duration
<input type="text" id="bottomInput" oninput="editInputVariable3(this.value, 'projetitlecfig','cooldownDuration')">
scale
<input type="text" id="bottomInput" oninput="editInputVariable3(this.value, 'projetitlecfig','scale')">
 }
}
</div>
<div>hurt duration hurtDelay</div>
<input type="text" id="bottomInput" oninput="editInputVariable(this.value, 'hurtDelay')">
<div>hp texture</div>
<input type="file" id="fileInput70" onchange="handleFileInputChangeA(event,config.HpBarConfiguration,  'texture')" />
<div>hp emptytexture</div>
<input type="file" id="fileInput70" onchange="handleFileInputChangeA(event,config.HpBarConfiguration,  'textureempty')" />
<button onclick="handleFileButtonClickA('fileInput1', 1)">player speed</button>
<input type="text" id="leftInput" oninput="editInputVariable2(this.value, 'speed'); updspeed()">
<button onclick="handleFileButtonClickA('fileInput1', 1)">player nor speed</button>
<input type="text" id="leftInput" oninput="editInputVariable2(this.value, 'norspeed'); updspeed()">
<button onclick="handleFileButtonClickA('fileInput1', 1)">player backspeed</button>
<input type="text" id="leftInput" oninput="editInputVariable2(this.value, 'backspeed'); updspeed()">

<button onclick="handleFileButtonClickA('fileInput1', 1)">player running speed</button>
<input type="text" id="leftInput" oninput="editInputVariable2(this.value, 'runningspeed'); updspeed()">
<hr>

<button onclick="handleFileButtonClickA('fileInput1', 1)">player SIZE</button>
<input type="text" id="leftInput" oninput="editInputVariable30(this.value, 'playersizeNOHITBOX'); updspeed()">
<button onclick="handleFileButtonClickA('fileInput1', 1)">player SIZE With HITBOX(1/0)</button>
<input type="text" id="leftInput" oninput="editInputVariable2(this.value, 'playersizeHasHitBox'); updspeed()">
config.savedgamestate
<input type="text" id="leftInput" oninput="editInputVariable2(this.value, 'savedgamestate'); updspeed()">(1/0) reset progress to ost save point if player died  

config['maxgravityvelocity']
<hr>
<input type="text" id="leftInput" value="1" oninput="editInputVariable20(this.value, 'maxgravityvelocity'); updspeed()">(number) max gravity multiple speed def use 1
<input type="text" id="leftInput" value="1" oninput="editInputVariable20(this.value, 'gravityvelocityspeed'); updspeed()">
gravityvelocityspeed
<input type="text" id="leftInput" value="1" oninput="editInputVariable20(this.value, 'gravitypower'); updspeed()"  >(number) gravity power default 0.1/0.2

<br>
<input type="text" id="leftInput" value="1" oninput="editInputVariable20(this.value, 'airjump'); updspeed()">airjump 

<br><hr>
<input type="text" id="leftInput" value="1" oninput="editInputVariable20(this.value, 'defps'); updspeed()" value="13" >MAX FPS ( makes game more smothered if greater but game will be slower on low frequency devices ) 12Fps/, old 15Fps
<script>
function updspeed(){
  speed=config.speed
  normspeed=config.speed
}

function editInputVariable(value, propertyName) {

    if (config.HpBarConfiguration.hasOwnProperty(propertyName)) {
        config.HpBarConfiguration[propertyName] = value;

    } else {
        console.error("unknown properties :", propertyName);
    }
}
function editInputVariable2(value, propertyName) {

    if (config.hasOwnProperty(propertyName)) {
        config[propertyName] = value;
        
    } else {
        console.error("unknown properties:", propertyName);
    }
}
function editInputVariable30(value, propertyName) {

if (config.hasOwnProperty(propertyName)) {
config[propertyName] = parseFloat(value)

} else {
console.error("unknown properties:", propertyName);
}
}
function editInputVariable20(value, propertyName) {

  if (config.hasOwnProperty(propertyName)) {
    config[propertyName] = parseFloat(value);
  } else {
    console.error("unknown properties:", propertyName);
  }
}
function editInputVariable3(value, propertyName,name) {

  if (config[propertyName].hasOwnProperty(name)) {
    config[propertyName][name] = value;
  } else {
    console.error("error:", propertyName);
  }
}
</script>
<script>
let fgh=0
function togglemenu(){
  document.querySelector('.entitymenu').classList.toggle('hide')
}
setTimeout(togglemenu,1000)
function toggh(){
  if(fgh==0){
    showlines=1
    fgh=1
  }else{
    showlines=0
    fgh=0
  }
}
function topdownbuttonsexmp(){
  document.querySelector('gui').innerHTML=`  <div class="btns">
      <div class="null added"></div>
      <div class="btn added" id="Up"></div>
      <div class="null added"></div>
      <div class="btn added" id="Left"></div>
      <div class="null added"></div>
      <div class="btn added" id="Right"></div>
      <div class="null added"></div>
      <div class="btn added" id="Down"></div>
      <div class="null added"></div>
    </div>
 	   	  <div class="jumpbtn added" id="Attack" style="transform: translate(0%,-100%)" onclick="attack2()"></div>
`
setTimeout(ukonczoneGUI,2000)
}
function platformergamebuttonexmp() {
  document.querySelector('gui').innerHTML = `  \n   <div class=\"btns\">\n    \n    \n    \n    \n    \n    \n    \n    \n    \n   </div>\n    <button id=\"Left\" class=\" przesuwalny added\" style=\"width: 50px; height: 50px; background: rgb(80, 80, 200); left: 4.14062vw; top: 84.3793vh;\"></button><button id=\"Right\" class=\" przesuwalny added\" style=\"width: 50px; height: 50px; background: rgb(80, 80, 200); left: 13.5156vw; top: 84.7743vh;\"></button><button id=\"Jump\" class=\" przesuwalny added\" style=\"width: 50px; height: 50px; background: rgb(80, 120, 200); left: 85.625vw; top: 84.5833vh;\"></button><button id=\"Attack\" class=\" przesuwalny added\" style=\"width: 50px; height: 50px; background: rgb(80, 120, 200); left: 85.3906vw; top: 65vh;\"></button>`
  setTimeout(ukonczoneGUI,2000)
}
function emptyproj(){
  playerY=200;
  playerX=200;
  TILES=[]
  tileMap=[[],[],[]]
  gravity=0
  document.querySelector('#Econtent').innerHTML=""
  document.querySelector('#Iblocks').innerHTML=""
  document.querySelector('#I2blocks').innerHTML=""
  updateViewport()
}

  function updateSpriteConfigNpc() {
    try {

      stop=1

      tileConfig = config.entities
alert(JSON.stringify(config.entities))
setTimeout(function(){
  stop=0
  alert(JSON.stringify(tileConfig))
},3000)
    } catch (error) {
      console.error(' JSON:', error);
    }
  }

</script>
</pre>
    </div>
  <div class="hide menu2-content" style="z-index: 9999999999;">
        <div class="teditor" onclick="TEditor()">
          editor
        </div>
        <button style="position: absolute; top:0; right:0; z-index: 9999999999999; " onclick="edyytor()" >
          update
        </button>
<div id="cog">
      <div id="codeContainer"></div>
      <div id="scrollplus"></div>
    </div>
    <div class="rspeed2" onclick="STOP()">
      stop
    </div>
    <div class="rset" onclick="RESET()">
      reset
    </div>
    <div id="Alert">
      hey
    </div>
    <div id="devConsole"></div>
    <div class="varscontainer">
    <div class="vars"></div>
    </div>
    <div id="codeContainer2">
      <div id="output"></div>
      <div id="scrollplus"></div>
    </div>
    <div id="speed2SliderContainer">
      <div id="speed2Slider">
        <div id="sliderHandle"></div>
      </div>
      <div id="speed2Value">speed2: 1</div>
    </div>
    <div class="closebutton" onclick="visibility('.menu2-content')" style="position: absolute; bottom:10px; right:10px">x</div>
    <textarea name="" id="edytor" class="hide" cols="30" rows="10"></textarea>
  </div>
    <div class="hide menu0-content men1">
      <div class="closebutton" onclick="visibility('.men1-content')" style="position: absolute; bottom:10px; right:10px">x</div>
    </div>
<style>
  .hide{
    display: none;
    visibility: none;
  }
  .hide2{
    display: none
  }
  .a{
    background: #969696;
    color:#171717;
    z-index: 1;
    padding:5px;
  }
</style>
<script>
function visibility(element){
  document.querySelector(element).classList.toggle('hide')
}
function toggleVS() {
 var p =  document.querySelectorAll('.a,.containerZ')
 for(i=0; i<p.length; i++){
   p[i].classList.toggle('hide2')
 }
}
function toggleHTMLEDITOR(){
  var p = document.querySelectorAll('.containerC')
for (i = 0; i < p.length; i++) {
  p[i].classList.toggle('hide')
}
}
</script>
<!DOCTYPE html>
<html lang="en" onclick="document.documentElement.requestFullscreen()">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <style>
        html {
            background: #000000;
            color: #F4F4F4;
        }
        * {
            margin: 0;
            
        }
        #devConsole {
            position: fixed;
            top: 10px;
            font-size: 10px;
            width: calc(50% + 5px);
            right: 10px;
            background-color: #070707;
            border: 1px solid #A2FAA3;
            padding: 10px;
        }
        #codeContainer {
        }
        #codeContainer2 {
          position: fixed;
          top: 60px;
          right: 10px;
          font-size: 12px;
          width: 30%;
          height: 50%;
          overflow: auto;
          background-color: #0D0D0D;
          border: 1px solid #A2FAA3;
          padding: 10px;
          transform: translateY(-50%, 0%);
        }
        #output {
            padding-left: 10px;
        }
        #scrollplus {
            width: 100vw;
            height: 30px;
        }
        .highlight {
            background-color: #4AD69178;
            padding: 1px;
            box-shadow: 0px 0px 5px #00FF81;
            border-radius: 4px;
        }
                #cog {
                  position: fixed;
                  width: 100vw;
                  height: 100vh;
                  overflow: hidden;
                  overflow: scroll;
                }
                .rspeed2{
                  position: absolute;
                  display: flex;
                  justify-content: center;
                  bottom:20px;
                  right:20px;
                  width: 40px;
                  height: 20px;
                  background: #0A0B09;
                  border: 1px solid #9AF38A;
                }
                .rset {
                  position: absolute;
                  display: flex;
                  justify-content: center;
                  bottom: 20px;
                  right: 70px;
                  width: 40px;
                  height: 20px;
                  background: #0A0B09;
                  border: 1px solid #9AF38A;
                  z-index: 12;
                }
                .teditor {
                  position: fixed;
                  display: flex;
                  z-index: 100;
                  justify-content: center;
                  bottom: 20px;
                  left: 20px;
                  width: 40px;
                  height: 20px;
                  background: #0A0B09;
                  border: 1px solid #9AF38A;
                }
#Alert{
  position: absolute;
  border: 1px solid #9AF38A;
  background: #101310;
  transform: translate(-50%,-50%);
  top:50vh;
  left:50vw;
  width:150px;
  display: none;
  align-items: center;
  justify-content: center;
  height:100px;
  z-index: 9;
}
.vars {
  word-wrap: break-word; 
  white-space: pre-wrap; 
}
.varscontainer {
  position: absolute;
  border: 1px solid #9AF38A;
  background: #101310;
  top: 60px;
  right: calc(30% + 15px);
  width: 20%;
  align-items: center;
  justify-content: center;
  height: 50%;
  z-index: 1;
 overflow: hidden;
 overflow: scroll;
}
.hide{
  display: none
}
.tile-number {
  display: block;
  position: fixed;
  z-index: 9999999999999;
  background-color: #42445A70;
  width: 100px;
  padding: 10px;
  border: 1px solid black;
  color: black;
}
.visible {
  display: block;
}
    </style>
</head>
<body>
  <div id="container3">n</div>
  <!-- TUTORIAL -->
<div id="tutor" onclick="document.getElementById('tutor').style.display='none'" class="notaproject"style="position:fixed; top:50vh; left:50vw; transform: translate(-50%,-50%); width: 80vw; height: 80vh;background: rgb(50,50,50);overflow:hidden;overflow:scroll; display:none; z-index: 999999999; " >
<pre style="white-space: pre-wrap; color: white; font-family: 'Courier New', monospace;">
how entity code work<br>
"make9":[2,"null",4,3,0,0,[0,0,999999,999999],false,[[0,3],[0,-3]],0,0,0,".player",1]<br>
"class/tag":[speed,movement('','move','avoid','follow'),distance-to-player(blocks),randommove(1/0),collisionblockforplayer like collisionblocks,Enemy HP,[x,y,x2,y2],false,if 'move'=[[0,3],[0,-3]],hurtblocklikespike,script doesn't work if enemy is not visible,give score,custom sprites collision for attack def='player',enable custom sprite collision,collisionwithotherblocks,deletewhencustommoveended]<br>
speed, movementType, distance, randomMovement, collision, initialHp, area, deletebool, arena, hurt, vi, score1, collisionobject="player", detectenabled, collisionwithotherblocks, deletewhencustommoveended<br><br>

1. <span style="color: #00FF00;">**Variable (Line):**</span><br>
- <span style="color: #00FF00;">**Syntax:**</span> `l variable_name value`<br>
- <span style="color: #00FF00;">**Example:**</span> `l score 0`<br>
- <span style="color: #00FF00;">**Description:**</span> Assigns a value to a variable.<br><br>

2. <span style="color: #00FF00;">**Output Text:**</span><br>
- <span style="color: #00FF00;">**Syntax:**</span> `ot text`<br>
- <span style="color: #00FF00;">**Example:**</span> `ot Hello, World!`<br>
- <span style="color: #00FF00;">**Description:**</span> Outputs text to the console or other output.<br><br>

3. <span style="color: #00FF00;">**Collision Check:**</span><br>
- <span style="color: #00FF00;">**Syntax:**</span> `col object1 object2 line`<br>
- <span style="color: #00FF00;">**Example:**</span> `col player enemy 42`<br>
- <span style="color: #00FF00;">**Description:**</span> Checks for collision between two objects. If a collision occurs, performs actions on the specified line of code.<br><br>

4. <span style="color: #00FF00;">**Convert Sprite to Block:**</span><br>
- <span style="color: #00FF00;">**Syntax:**</span> `cnvrt sprite`<br>
- <span style="color: #00FF00;">**Example:**</span> `cnvrt player`<br>
- <span style="color: #00FF00;">**Description:**</span> Converts the specified sprite to a block.<br><br>

5. <span style="color: #00FF00;">**Output to Local Results:**</span><br>
- <span style="color: #00FF00;">**Syntax:**</span> `out variable value`<br>
- <span style="color: #00FF00;">**Example:**</span> `out score 100`<br>
- <span style="color: #00FF00;">**Description:**</span> Adds a value to the local results (possible effects in the game).<br><br>

6. <span style="color: #00FF00;">**Move Sprite:**</span><br>
- <span style="color: #00FF00;">**Syntax:**</span> `move sprite x y`<br>
- <span style="color: #00FF00;">**Example:**</span> `move player 5 0`<br>
- <span style="color: #00FF00;">**Description:**</span> Moves the sprite by the specified x and y values.<br><br>

7. <span style="color: #00FF00;">**Jump If:**</span><br>
- <span style="color: #00FF00;">**Syntax:**</span> `jmp line`<br>
- <span style="color: #00FF00;">**Example:**</span> `jmp 10`<br>
- <span style="color: #00FF00;">**Description:**</span> Jumps to the specified line of code.<br><br>

8. <span style="color: #00FF00;">**Gravity:**</span><br>
- <span style="color: #00FF00;">**Syntax:**</span> `gravity 1` or `gravity 0`<br>
- <span style="color: #00FF00;">**Example:**</span> `gravity 1`<br>
- <span style="color: #00FF00;">**Description:**</span> Turns gravity on (1) or off (0).<br><br>

9. <span style="color: #00FF00;">**Build Tile Map:**</span><br>
- <span style="color: #00FF00;">**Syntax:**</span> `build x y type`<br>
- <span style="color: #00FF00;">**Example:**</span> `build 3 4 3`<br>
- <span style="color: #00FF00;">**Description:**</span> Adds a tile of the specified type at position x, y on the map.<br><br>

10. <span style="color: #00FF00;">**AND Condition:**</span><br>
- <span style="color: #00FF00;">**Syntax:**</span> `and variable value line`<br>
- <span style="color: #00FF00;">**Example:**</span> `and health 0 20`<br>
- <span style="color: #00FF00;">**Description:**</span> Checks the logical AND condition and jumps to the specified line if the condition is met.<br>
<hr>
11. texture %texture[index] %to_texture[index]<br>
e.g., texture 1 2<br>
Changes the texture of given elements to the texture of another element.<br>
<hr>
12. press ID Line<br>
Checks if a button is pressed; if so, jumps to the specified line.<br>
<hr>
13. tp class1 to class2<br>
e.g., tp player sprites39<br>
movem i(num..) x,y<br>
Moves a block from the tileMap. Unlike move, it can move blocks not loaded.<br>
dialogue < text> will display dialogue :)
</pre>
</div>
<script>
</script>
<!-- Container for NPC dialog -->
<div id="npcDialog" style="position: absolute; bottom: 0; left: 0; z-index: 99; display: none; width: 100vw; margin:0; height: 50px; background: rgba(0, 0, 5, 0.4); color: white;">
    <div id="npcText"></div>
    <div id="arrow">⤵️</div>
</div>
<script>
    // Global queue for storing dialog messages
    const dialogQueue = [];
var indialogue=0
    // NPC dialog function
    function message(text) {
        const npcDialog = document.getElementById('npcDialog');
        const npcText = document.getElementById('npcText');
        // Add the message to the dialog queue
        dialogQueue.push(text);
        // If there's no dialog currently showing, display the next message
        if (!npcDialog.style.display || npcDialog.style.display === 'none') {
            displayNextDialog();
        }
    }
let newaudio2;
function displayNextDialog() {
    const npcDialog = document.getElementById('npcDialog');
    const npcText = document.getElementById('npcText');
    if (indialogue !== 1) {
        if (currentsoundformessage.length > 20) {
            const base64Wav = currentsoundformessage;

            newaudio2 = new Audio();
            newaudio2.src = base64Wav;
            newaudio2.setAttribute('preload', 'auto');
            newaudio2.loop = true;

            document.body.appendChild(newaudio2);

            newaudio2.play();
        }
    }
    indialogue = 1;

    if (dialogQueue.length === 0) {
        npcDialog.style.display = 'none';
        if (newaudio2) {
            newaudio2.pause();
            newaudio2.currentTime = 0;
        }
        indialogue = 0;
        npcDialog.style.display = 'none';
indialogue = 0
pausemove = 0
if (newaudio2) {
  newaudio2.pause();
  newaudio2.currentTime = 0;
}
        return;
    }
    // Show NPC dialog
    npcDialog.style.display = 'block';
    // Clear previous text
    npcText.textContent = '';
    // Get the next message from the queue
    const nextMessage = dialogQueue.shift();
    // Animate text appearance
    let index = 0;
    let wordIndex = 0; // Index of the current word
    const delay = 50; // Delay between each character appearance (increased for better readability)
    const timer = setInterval(function() {
        // Add the next letter to the text
        npcText.textContent += nextMessage[wordIndex][index];
        index++;
        // If we reached the end of the current word, move to the next word
        if (index >= nextMessage[wordIndex].length) {
            index = 0;
            wordIndex++;
            // If we reached the end of all words, clear the timer
            if (wordIndex === nextMessage.length) {
                clearInterval(timer);
                if (newaudio2) {
                    newaudio2.pause();
                    newaudio2.currentTime = 0;
                }
                // Add click event listener to the dialog to display the next message
                npcDialog.addEventListener('click', function displayNext() {
                    npcDialog.removeEventListener('click', displayNext); // Remove the click event listener
  if (currentsoundformessage.length > 20) {
    const base64Wav = currentsoundformessage;

    newaudio2 = new Audio();
    newaudio2.src = base64Wav;
    newaudio2.setAttribute('preload', 'auto');
    newaudio2.loop = true;

    document.body.appendChild(newaudio2);

    newaudio2.play();
  }
                    displayNextDialog(); // Display the next dialog message
                    if (dialogQueue.length === 0) {
                    }
                });
            }
        }
    }, delay);
}

</script>
<script>

let speed2 = config.Hz; // Hz
var g=config.noasm// start(0),norun(1);
    let code =config.code;
    if(config.debugmode==1){
      g=1
    }
/*
2: l x 0
3: l y 5
4: add x 1
5: show x
6: and x y 8
7: jmp 4
8: ot HelloWorld!
9: jmp 1
1:
2: l x 0
3: l y 4
4: add x 1
5: and x y 9
6: and x z 12
7: and x a 15
8: jmp 4
9: ot Hello
10: l z 8
11: jmp 4
12: ot World
13: l a 12
14: jmp 4
15: ot CNASM
16: l o 24
17: add x 1
18: and x o 20
19: jmp 17
20: ot Program
*/
function checkclassCollision(class1, class2) {
  const elements1 = document.getElementsByClassName(class1);
  const elements2 = document.getElementsByClassName(class2);
  for (let i = 0; i < elements1.length; i++) {
    for (let j = 0; j < elements2.length; j++) {
      const rect1 = elements1[i].getBoundingClientRect();
      const rect2 = elements2[j].getBoundingClientRect();
      AX=parseInt(elements1[i].style.left)
      AY=parseInt(elements1[i].style.top)
      CX=parseInt(elements2[j].style.left)
      CY=parseInt(elements2[j].style.top)
let distanceToPlayer = Math.sqrt(((CX - AX) / tileSize) ** 2 + ((CY - AY) / tileSize) ** 2);
let dist =1.1
      if (
        distanceToPlayer<=dist
      ) {
        return 1;
      }
    }
  }
  return undefined;
}
function textToBinary(text) {
  return text.split('').map(function(char) {
    return char.charCodeAt(0).toString(2).padStart(8, '0');
  }).join(' ');
}
function numberToBinary(number) {
  return number.toString(2);
}
function TEditor(){
document.getElementById('edytor').classList.toggle('hide')
}
function parseValue(value) {
  if (!isNaN(value)) {

    return parseFloat(value);
  } else {

    if (V.includes(value)) {

      return Vables[value];
    } else {

      return 0;
    }
  }
}
function STOP(){
  const outputDiv = document.getElementById("codeContainer");
  outputDiv.innerHTML = ""
  document.querySelector('.vars').innerHTML = ""
  V = []
  g=1
}
function hideelements(element){
  if(document.querySelector(element)){
    let elements = document.querySelectorAll(element)
  for (var i = 0; i < elements.length; i++) {
elements[i].style.display="none"
elements[i].style.touchaction="none"
  }}
}
function showelements(element){
  if(document.querySelector(element)){
    let elements = document.querySelectorAll(element)
  for (var i = 0; i < elements.length; i++) {
//elements[i].style.visibility="visible"
elements[i].style.display="block"
elements[i].style.touchaction="auto"
  }}
}
var V=[]
function RESET(){
  Vables={}
  localout=[]
    g = 1
    currentLine = 0;
    curline=0
  alert2("machine communication please stand by")
  const outputDiv = document.getElementById("codeContainer");
  outputDiv.innerHTML=""
  document.querySelector('.vars').innerHTML=""
  V=[]
    setTimeout(function(){
      g = 0
    interpretCode(config.code,0)
    },2500)
}
function alert2(text){
  let xspeed2=speed2
  document.getElementById('Alert').style.display="flex"
  document.getElementById('Alert').innerText=text
  speed2=2
  setTimeout(function(){
    document.getElementById('Alert').style.display="none"
    speed2=xspeed2
  },500)
}
var touchX, touchY;
function isString(value) {
  return typeof value === 'string' || value instanceof String;
}
function setTouchPosition(event) {
  event.preventDefault()
    if (event.touches && event.touches.length > 0) {

        touchX = event.touches[0].pageX;
        touchY = event.touches[0].pageY;
    } else if (event.pageX !== undefined && event.pageY !== undefined) {

        touchX = event.pageX;
        touchY = event.pageY;
    }
}
function notouchposition(){
  touchX = Infinity;
touchY = Infinity;
}

document.querySelector('*').addEventListener('touchstart', setTouchPosition);
document.querySelector('*').addEventListener('touchend', notouchposition);
document.querySelector('*').addEventListener('mousedown', setTouchPosition);
document.querySelector('*').addEventListener('mouseup', notouchposition);
function trzymamId(klasaElementu) {
    const element = document.getElementById(klasaElementu);
//(element)
    if(element){
            const rect = element.getBoundingClientRect();
            if (
                touchX >= rect.left &&
                touchX <= rect.right &&
                touchY >= rect.top &&
                touchY <= rect.bottom
            ) {
              //console.log(touchX,touchY)
                return 1;
            }
}
}
var localout=[]
    let nospeed2lines = false;
let candocmd=1
let candothath=0
var defy=0
let jmptimes=0
    function interpretCode(code1,line1) {
      let curline = line1
let currentLine = line1;
        const lines = code1.split('\n');
        const devConsole = document.getElementById("devConsole");
        const outputDiv = document.getElementById("output");
        const codeContainer = document.getElementById("codeContainer");
         function processLine(line, lineNumber) {
           //console.log("Line:", line ,' Num:',lineNumber); // Add this line to check the value of 'line'
          if(g==0&&isgamepaused==0){
            if (line.trim() !== "") {
                const [numLine, restOfLine] = line.split(':');
                const trimmedLine = restOfLine.trim();
                displayResult2(numLine+",");
                if (trimmedLine.startsWith("l")) {
                    const match = trimmedLine.match(/l\s+(\w+)\s+(.+)/);
                    if (match) {
                      const [_, name, value] = match;
                      // Evaluate JavaScript expression for Vable assignment
                      try {
                        Vables[name] = eval(value);
                        if (!V.includes(name)) {
                          V.push(name);
                        }
                      } catch (error) {
                        console.error(`Error in line ${lineNumber}: ${error}`);
                      }
                    }
                }
else if (trimmedLine.startsWith("hide")) {
  const match = trimmedLine.match(/hide\s+(.+)/);
  if (match) {
    const [_, element] = match;
    hideelements(element)
    console.log(element)
  }
}else if (trimmedLine.startsWith("dialogue")) {
    const match = trimmedLine.match(/dialogue\s+(.+)/);
    if (match) {
        const [, element] = match;
        message(element);
    }
}
else if (trimmedLine.startsWith("movem")) {
  const match = trimmedLine.match(/movem\s+(\d+)\s+(\d+)\s+(\d+)/);
  if (match) {
    const [_, text, x, y] = match;
    console.log(parseInt(x), x);
    movemap(x,y,text);
  }
}
else if (trimmedLine.startsWith("show")) {
  const match = trimmedLine.match(/show\s+(.+)/);
  if (match) {
    const [_, element] = match;
    showelements(element)
    console.log(element)
  }
}
if (trimmedLine.startsWith("eval")) {
                  const match = trimmedLine.match(/eval\s+(.+)/);
                  if (match) {
                    const [_, evaluate] = match;
eval(evaluate)
                  }
                }else if (trimmedLine.startsWith("ot")) {
                  const match = trimmedLine.match(/ot\s+(\w+)/);
                  if (match) {
                    const [_, text] = match;
                  //  alert2(text)
                    displayResult3(text)
                  }
                } else if (trimmedLine.startsWith("col")) {
                  const match = trimmedLine.match(/col\s+(\w+)\s+(\w+)\s+(\-?\+?\d+)/);
               // alert("match")
                  if (match) {
                    const [_, col1,col2,targetLine] = match;
                    console.log(col1,col2)
if(checkclassCollision(col1,col2)){
const jumpAmount = parseInt(targetLine);
  if (targetLine.startsWith("+") || targetLine.startsWith("-")) {
    const newLineNumber = currentLine + jumpAmount;
    // alert(newLineNumber)
    //    alert("")
    updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
    highlightLine(lineNumber);
    return newLineNumber >= 0 ? newLineNumber : 0;
  } else {
    const newLineNumber = parseInt(targetLine) - 1;
    updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
    highlightLine(lineNumber);
    return newLineNumber >= 0 ? newLineNumber : 0;
  }
}
                  }
                }else if (trimmedLine.startsWith("cnvrt")) {
                  const match = trimmedLine.match(/cnvrt\s+(\w+)/);
                  if (match) {
                    const [_, text] = match;
                   //  alert(text)
                    convertspritetoblock(text)
                  }
                }else if (trimmedLine.startsWith("rm")) {
  const match = trimmedLine.match(/rm\s+(.+)/);
  if (match) {
    const [_, targetSelector] = match;
    const elementsToRemove = document.querySelectorAll(targetSelector);
    elementsToRemove.forEach(element => {
      element.remove();
    });
  }
}
else if (trimmedLine.startsWith("out")) {
                  const match = trimmedLine.match(/ot\s+(\w+)\s+(\d+)/);
                  if (match) {
                    const [_, text, value] = match;
                    addLocal(text,value)
                  }
                }else if (trimmedLine.startsWith("move")) {
  const match = trimmedLine.match(/move\s+([^\s]+)\s+(.+)\s+(.+)/);
  if (match) {
    const [_, text, x, y] = match;
    console.log(parseInt(x), x);
    spritetomove = text;
      movesprite(x, y);
  }
}
else if (trimmedLine.startsWith("make")) {
  const match = trimmedLine.match(/make\s+([^\s]+)\s+([^\s]+)\s+([^\s]+)/);
  if (match) {
    const [_, classlist2, x, y] = match;
    if (isNaN(x) || isNaN(y)) {

      const parsedX = Vables[x] !== undefined ? Vables[x] : parseFloat(x);
      const parsedY = Vables[y] !== undefined ? Vables[y] : parseFloat(y);

      if (!isNaN(parsedX) && !isNaN(parsedY)) {
        let element = document.createElement('div');
        element.classList.add(classlist2);
        element.className = `make${TILES[classlist2][0]} tile1 sprite${TILES[classlist2][1]} SPRITE`;
        element.style.backgroundImage = `url('${TILES[classlist2][2]}');`;
        element.style.left = parsedX * tileSize + "px";
        element.style.top = parsedY * tileSize + "px";
        element.style.width="30px"
        element.style.height="30px"
        document.getElementById('Scontent').appendChild(element);
        element.style.backgroundImage = `url("${TILES[parseInt(classlist2)][2]}")`;
      } else {
        alert("Nieprawidłowe wartości x lub y w komendzie 'make'");
      }
    } else {
      let element = document.createElement('div');
      element.classList.add(classlist2);
      element.className = `alltiles${TILES[classlist2][0]} tile1 sprite${TILES[classlist2][1]} SPRITE`;
      element.style.backgroundImage = `url('${TILES[classlist2][2]}');`;
      element.style.left = parseFloat(x) * tileSize + "px";
      element.style.top = parseFloat(y) * tileSize + "px";
      document.getElementById('Econtent').appendChild(element);
      element.style.backgroundImage = `url("${TILES[parseInt(classlist2)][2]}")`;
    }
  }
}
else if (trimmedLine.startsWith("tp")) {
                  const match = trimmedLine.match(/tp\s+(\w+)\s+(\w+)/);
                  if (match) {
                    const [_, class1, class2] = match;
                    teleportSprite(class1,class2)
                  }
                } else if (trimmedLine.startsWith("jmp")) {
    const match = trimmedLine.match(/jmp\s+(\-?\+?\d+)/);
    if (match) {
        const [_, targetLine] = match;
        const jumpAmount = parseInt(targetLine);
        if (targetLine.startsWith("+") || targetLine.startsWith("-")) {
            const newLineNumber = currentLine + jumpAmount;
          //  alert(newLineNumber)
        //    alert("")
            updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
            highlightLine(lineNumber);
            return newLineNumber >= 0 ? newLineNumber : 0;
        } else {
            const newLineNumber = parseInt(targetLine) - 1;
            updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
            highlightLine(lineNumber);
            return newLineNumber >= 0 ? newLineNumber : 0;
        }
    }
}
else if (trimmedLine.startsWith("jmpt")) {
                  const match = trimmedLine.match(/jmpt\s+(\d+)\s+(\d+)/);
                  alert("")
                  if (match) {
                    const [_, targetLine,times] = match;
                    if(jmptimes<times){
                      jmptimes++;
                    updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
                    highlightLine(lineNumber);
                    return parseInt(targetLine) - 1;
                  }else{
                   //jmptimes=0
                  }
                  }
                }
else if (trimmedLine.startsWith("press")) {
    const match = trimmedLine.match(/press\s+(.+)\s+(\-?\+?\d+)/);
    if (match) {
        const [_, idToCheck, targetLine] = match;
        console.log(idToCheck)
        if (trzymamId(idToCheck)) { 
        console.log("Touching")
        const jumpAmount = parseInt(targetLine);
        if (targetLine.startsWith("+") || targetLine.startsWith("-")) {
          const newLineNumber = currentLine + jumpAmount;
//alert(newLineNumber)
          //    alert("")
          updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
          highlightLine(lineNumber);
          return newLineNumber >= 0 ? newLineNumber : 0;
        } else {
          const newLineNumber = parseInt(targetLine) - 1;
          updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
          highlightLine(lineNumber);
          return newLineNumber >= 0 ? newLineNumber : 0;
        }
        }
    }
}
else if (trimmedLine.startsWith("gravity")) {
                  const match = trimmedLine.match(/gravity\s+(\d+)/);
                  if (match) {
                    const [_, targetLine] = match;
                    if(targetLine==1){
                      gravity=1
                    }else{
                      gravity=0
                    }
                  }
                }
else if (trimmedLine.startsWith("build")) {
  const match = trimmedLine.match(/build\s+([\d\w]+)\s+([\d\w]+)\s+([\d\w]+)/);
  if (match) {
    const [_, x, y, t] = match;
    const parsedX = parseValue(x);
    const parsedY = parseValue(y);
    const parsedT = parseValue(t);
    tileMap[dimension].push([parsedX, parsedY, parsedT]);
    updateViewport();
  }
}
else if (trimmedLine.startsWith("and")) {
  const match = trimmedLine.match(/and\s+(\w+)\s+(\w+)\s+(\-?\+?\d+)/);
  if (match) {
    const [_, Vable, value, targetLine] = match;
    console.log(Vable,value)
    if (evaluateConditionAND(Vable,value)) {
      const jumpAmount = parseInt(targetLine);
      if (targetLine.startsWith("+") || targetLine.startsWith("-")) {
        const newLineNumber = currentLine + jumpAmount;

        updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
        highlightLine(lineNumber);
        return newLineNumber >= 0 ? newLineNumber : 0;
      } else {
        const newLineNumber = parseInt(targetLine) - 1;
        updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
        highlightLine(lineNumber);
        return newLineNumber >= 0 ? newLineNumber : 0;
      }
    }
  }
}
else if (trimmedLine.startsWith("nand")) {
  const match = trimmedLine.match(/nand\s+(\w+)\s+(\w+)\s+(\-?\+?\d+)/);
  if (match) {
    const [_, Vable, value, targetLine] = match;
    console.log(Vable, value)
    if (evaluateConditionNAND(Vable, value)) {
      const jumpAmount = parseInt(targetLine);
      if (targetLine.startsWith("+") || targetLine.startsWith("-")) {
        const newLineNumber = currentLine + jumpAmount;
        //  alert(newLineNumber)
        //    alert("")
        updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
        highlightLine(lineNumber);
        return newLineNumber >= 0 ? newLineNumber : 0;
      } else {
        const newLineNumber = parseInt(targetLine) - 1;
        updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
        highlightLine(lineNumber);
        return newLineNumber >= 0 ? newLineNumber : 0;
      }
    }
  }
}
else if (trimmedLine.startsWith("not")) {
  const match = trimmedLine.match(/not\s+(\w+)\s+(\-?\+?\d+)/);
  if (match) {
    const [_, Vable, targetLine] = match;
    if (evaluateConditionNOT(Vable)) {
      const jumpAmount = parseInt(targetLine);
      if (targetLine.startsWith("+") || targetLine.startsWith("-")) {
        const newLineNumber = currentLine + jumpAmount;
        //  alert(newLineNumber)
        //    alert("")
        updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
        highlightLine(lineNumber);
        return newLineNumber >= 0 ? newLineNumber : 0;
      } else {
        const newLineNumber = parseInt(targetLine) - 1;
        updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
        highlightLine(lineNumber);
        return newLineNumber >= 0 ? newLineNumber : 0;
      }
    }
  }
}
else if (trimmedLine.startsWith("jif")) {
                    const match = trimmedLine.match(/jif\s+(\w+)\s+(\W+)\s+(\d+)\s+(\d+)/);
                    if (match) {
                        const [_, Vable, operation, value, targetLine] = match;
                        if (evaluateCondition(Vable, operation, parseInt(value))) {
                             updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
                            highlightLine(lineNumber);
                            return parseInt(targetLine);
                        }
                    }
                }
else if (trimmedLine.startsWith("ppos")) {
  const match = trimmedLine.match(/ppos\s+(.+)\s+(.+)\s+(\d+)/);
  if(candocmd){
  if (match) {
    var [_, x, y, add] = match;
    x=parseFloat(x)
    y=parseFloat(y)
add=parseFloat(add)
   // alert2(x+'...'+y)
//    candocmd=0
    if(add){
    movePlayer((x),(y))
    }else{
    setPlayer((x),(y))
    } 
    updateViewport()
  }}
//  candocmd=1
}
else if (trimmedLine.startsWith("chblock")) {
  const match = trimmedLine.match(/chblock\s+(\d+)\s+(\d+)\s+(\w+)\s+(\d+)/);
  // chblock x,y,type,line
  if (match) {
    const [_, x, y, type, line] = match;
  }
}else if (trimmedLine.startsWith("add")) {
                    const match = trimmedLine.match(/add\s+(\w+)\s+(\d+)/);
                    if (match) {
                        const [_, Vable, value] = match;
                        if (Vables[Vable] !== undefined) {
                            Vables[Vable] += parseInt(value);
                        }
                    }
                } else if (trimmedLine.startsWith("sub")) {
                    const match = trimmedLine.match(/sub\s+(\w+)\s+(\d+)/);
                    if (match) {
                        const [_, Vable, value] = match;
                        if (Vables[Vable] !== undefined) {
                            Vables[Vable] -= parseInt(value);
                        }
                    }
                } else if (trimmedLine.startsWith("show")) {
                    const match = trimmedLine.match(/show\s+(\w+)/);
                    if (match) {
                        const [_, Vable] = match;
                        displayResult("Output :", Vable);
                    }
                }else if (trimmedLine.startsWith("texture")) {
                  const match = trimmedLine.match(/texture\s+(\w+)\s+(\w+)/);
                  if (match) {
                    const [_, input,texture] = match;
                    TILES[input][2]=TILES[texture][2]
                  }
                }else if (trimmedLine.startsWith("bgtexture")) {
                  const match = trimmedLine.match(/texture\s+(\w+)/);
                  if (match) {
                    const [_, texture] = match;
                    document.getElementById('content').style.backgroundImage= `url('${TILES[texture][2]}')`
                    if (!('stickybg1' in config)) {

                      config['stickybg1'] = 0;
                    } else {
                    }
                    if (config.stickybg1 == 0) {
                      document.getElementById('content').style.backgroundImage= `url('${TILES[texture][2]}')`
                      document.getElementById('content2').style.backgroundImage= ``
                      bgimg=TILES[texture][2]
                    config.bg=TILES[texture][2]
                    } else {
                      document.getElementById('content2').style.backgroundImage= `url('${TILES[texture][2]}')`
                      document.getElementById('content').style.backgroundImage= ``
                      bgimg=TILES[texture][2]
                    config.bg=TILES[texture][2]
                    }
                  }
                }
                highlightLine(lineNumber);

                 updateDevConsole(lineNumber, speed2, Object.keys(Vables).length);
                const outputDiv = document.getElementById("codeContainer");
                if (codeContainer.children.length > 30) {
                  codeContainer.removeChild(codeContainer.firstChild);
                }
            addVar()
            }
            return null;
        }
        }
let zonz = 0;
function interpret() {
if(isgamepaused==0){
  if (config.Hz <1009 && currentLine < lines.length) {
    const startTime = performance.now();
    function processNextLine() {
  if (g === 0 ) {
    const result = processLine(lines[currentLine], currentLine + 1);
    if (result !== null) {
      if (result !== null) {
        currentLine = result;
      }else {
        console.warn("Trying to jump to an out-of-bounds line.:", result);
      }
    } else {
      currentLine++;
    }
    if(config.Hz >1 ){
      if(candothath==0){
        candothath=1
        setTimeout(() => {
          processNextLine()
        }, frameTime);
    setTimeout(() => {
      candothath=0
      setTimeout(() => {
        processNextLine()
      }, frameTime);
    }, config.Hz);
      }
    }else{
      setTimeout(() => {
        requestAnimationFrame(processNextLine);
      }, frameTime);
      defy++;
      if(defy>config.boosttimeout){
        defy=0
      }
    }
  }
}
    processNextLine()
    function processWithTimeout(count, delay) {
    if (count > 0) {
        setTimeout(function() {
            requestAnimationFrame(processNextLine);
            processWithTimeout(count - 1, delay);
        }, delay);
    }
}

const requestCount = config.requests || 1;
const delay = 50;

processWithTimeout(requestCount, delay);
  }
}}
         function updateDevConsole(lineNumber, currentspeed2, VableCount) {
            devConsole.innerHTML = `line: ${lineNumber}, speed: ${currentspeed2} Hz, loaded variables: ${VableCount}`;
        }
function addVar() {
  document.querySelector('.vars').innerHTML = "";
  for (let i = 0; i < V.length; i++) {
    document.querySelector('.varscontainer').scrollBy(0,200)
    document.querySelector('.vars').innerHTML += V[i] + "=" + Vables[V[i]] + " x" + numberToBinary(Vables[V[i]]) + "\n";
  }

  let xorResult = 0;
  for (let i = 0; i < V.length; i++) {
    xorResult ^= Vables[V[i]];
  }

  let xorIndex = localout.findIndex(item => item[0] === "XOR");
  if (xorIndex !== -1) {

    localout[xorIndex][1] = xorResult;
  } else {

    localout.push(["XOR", xorResult]);
  }

  for (let i = 0; i < localout.length; i++) {
    document.querySelector('.vars').innerHTML +='<br>' + localout[i][0] + "=" + localout[i][1] + " x" + numberToBinary(localout[i][1]) + "\n";
  }
}
        function highlightLine(lineNumber) {
            outputDiv.innerHTML = lines
                .map((line, index) => `<div class="${index + 1 === lineNumber ? 'highlight' : ''}">${line}</div>`)
                .join('');
        }
        interpret();
    }
    function evaluateCondition(Vable, operation, value) {
     // console.log(operation)
      operation=parseFloat(operation)
        if (Vables[Vable] !== undefined) {
            if (operation === ">") {
                return Vables[Vable] > value;
            } else if (operation === "<") {
                return Vables[Vable] < value;
            } else if (operation === "==") {
                return Vables[Vable] === value;
              //  console.log('done1')
            }
        }
        return false;
    }
function evaluateConditionAND(Vable, value) {
  if (Vables[Vable] !== undefined) {
    if (Vables[Vable]==Vables[value]) {
      console.log('done1')
      return Vables[Vable]==Vables[value];
    }
  }
  return false;
}
function evaluateConditionNOT(Vable) {
  if (Vables[Vable] !== undefined) {
    if (Vables[Vable] <1) {
      console.log('done1')
      return Vables[Vable] <1;
    }
  }
  return false;
}
function evaluateConditionNAND(Vable, value) {
  if (Vables[Vable] !== undefined) {
    if (Vables[Vable]!==Vables[value]) {
      console.log('done1')
      return Vables[Vable]!==Vables[value];
    }
  }
  return false;
}
    function displayResult(t, Vable) {
        const outputDiv = document.getElementById("codeContainer");
        document.getElementById("cog").scrollBy(0, 2000);
        outputDiv.innerHTML += `<div>  <d style="color: #4AD6BB;" >${t}</d>  <d style="color:yellow;" >${Vable}</d>:   <d style="color: #209195;" >${Vables[Vable]}</d> <d style="color:#FFF" > ${numberToBinary(Vables[Vable])} </d></div><br>`;
    }
function displayResult3(t, Vable) {
        const outputDiv = document.getElementById("codeContainer");
        document.getElementById("cog").scrollBy(0, 2000);
        outputDiv.innerHTML += `<div>  <d style="color: #F1F1F;" >${t}</d></div>`;
    }
    function displayResult2(t) {
        const codeContainer = document.getElementById("codeContainer");
        const cd = document.getElementById("cog");
 //       codeContainer.innerHTML += `<d style="color: #D64A4A;">${t}</d>`;
        cd.scrollBy(0,2000)
                if (codeContainer.children.length > 40) {
                  codeContainer.removeChild(codeContainer.firstChild);
                } 
    }
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    setTimeout(interpretCode(config.code,0),1000)
</script>
<style>
#edytor {
background: #161916;
border: 1px solid #9DFF9A;
width:90%;
height: 90%;
position: absolute;
transform:translate(-50%,-50%);
top:50vh;
left:50vw;
outline:none;
color:#9DFF9A;
z-index: 11;
}
</style>
<textarea name="" onchange="edyytor()" id="edytor" class="hide" cols="30" rows="10"></textarea>
<script>
function edyytor(){
  config.code=document.getElementById('edytor').value
  alert(config.code)
}
setTimeout(function(){
  document.getElementById('edytor').textContent=code
  update1()
},200)
function update1(){
  code=document.getElementById('edytor').value
//  console.log(code)
  setTimeout(update1,1000)
}
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Assembler Interpreter</title>
    <style>
        html {
            background: #000000;
            color: #F4F4F4;
            font-family: Arial, sans-serif;
        }
        * {
            margin: 0;
            
        }
        #speed2SliderContainer {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #speed2Slider {
            width: 200px;
            height: 10px;
            background-color: #1F1F1F;
            border-radius: 5px;
            margin-bottom: 10px;
            position: relative;
        }
        #sliderHandle {
            width: 20px;
            height: 20px;
            background-color: #A2FAA3;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        #speed2Value {
            font-size: 14px;
            color: #A2FAA3;
        }
    </style>
</head>
<body>
<script>
    let itisdragging = false;
    let maxSlide = 300; // Default max slide value
    // Handle speed2 slider interaction
    const speed2Slider = document.getElementById("speed2Slider");
    const sliderHandle = document.getElementById("sliderHandle");
    const speed2Value = document.getElementById("speed2Value");
    sliderHandle.addEventListener("mousedown", startSlide);
    sliderHandle.addEventListener("mouseup", stopSlide);
    sliderHandle.addEventListener("touchstart", startSlideTouch);
    sliderHandle.addEventListener("touchend", stopSlideTouch);
    function startSlide(e) {
        e.preventDefault();
        itisdragging = true;
        window.addEventListener("mousemove", slide);
        window.addEventListener("mouseup", stopSlide);
    }
    function stopSlide() {
        itisdragging = false;
        window.removeEventListener("mousemove", slide);
        window.removeEventListener("mouseup", stopSlide);
    }
    function slide(e) {
        if (itisdragging) {
            const sliderWidth = speed2Slider.offsetWidth;
            const mouseX = e.clientX - speed2Slider.getBoundingClientRect().left;
            const percentage = Math.max(0, Math.min(0, mouseX / sliderWidth));
            speed2 = 1 + Math.round(maxSlide * percentage);
            updateSlider();
        }
    }
    function startSlideTouch(e) {
        e.preventDefault();
        itisdragging = true;
        window.addEventListener("touchmove", slideTouch);
    }
    function stopSlideTouch() {
        itisdragging = false;
        window.removeEventListener("touchmove", slideTouch);
    }
    function slideTouch(e) {
        if (itisdragging) {
          speed2=1
            const sliderWidth = speed2Slider.offsetWidth;
            const touchX = e.touches[0].clientX - speed2Slider.getBoundingClientRect().left;
            const percentage = Math.max(0, Math.min(1, touchX / sliderWidth));
            speed2 = 1 + Math.round(maxSlide * percentage);
            updateSlider();
        }
    }
    function updateSlider() {
        const handlePosition = (speed2 - 0) / maxSlide * (speed2Slider.offsetWidth - sliderHandle.offsetWidth);
        sliderHandle.style.left = `${handlePosition}px`;
        speed2Value.textContent = `speed2: ${speed2}`;
    }
    // Initial setup;
    updateSlider();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        .przesuwalny {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: move;
            background-color: #4CAF50;
            color: white;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            padding: 10px;
            margin: 4px 2px;
        }
        #modal-container {
            position: fixed;
            zoom:0.8;
            overflow: hidden;
            overflow: scroll;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999999;
            display: none;
        }
        #modal-content {
            background: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
    </style>
    <title>Edytor Przycisków</title>
</head>
<body>
    <button  style="position: fixed; top:20px; left:0px;background-color: #4CAF50; 
    color: white;
    padding: 10px 20px;
    text-align: center;
    text-decoration: none;
    font-size: 16px;
    margin: 4px 2px;"
    class="notaproject d hide"
    onclick="showModal()">advance</button>
    <button style="position: absolute; top:70px; left:0px;background-color: #4CAF50;
    color: white;
    padding: 10px 20px;
    text-align: center;
    text-decoration: none;
    font-size: 16px;
    margin: 4px 2px;" class="notaproject d hide" onclick="usunElementy()">delete gui</button>
    <div id="modal-container" >
        <div id="modal-content">
            <input type="text" id="klasaInput" placeholder="new ui class">
            <br>
            <input type="text" id="styleInput" placeholder="style css for this" value="width:50px;height:50px;background:rgba(80,80,200,1); background-size:100%; border-radius:10%; left:;top:;right:;bottom:;">
            <br>
            <input type="text" id="tekstInput" placeholder="content text">
            <br>
            <input type="text" id="IdInput" placeholder="Left,Right,Up,Down,Attack,Jump,Run">
            <br>
            <button onclick="dodajPrzyciskZModalu()">add button</button>
<button onclick="dodajPrzyciskZModalu2()">add button with image</button>
            <button onclick="ukonczoneGUI()">Done GUI</button>
            <button onclick="addtoproject()">Add to project</button>
<button onclick="addtoproject2()">Add to project with image</button>
            <input type="file" name="background" id="background">
            <button onclick="hideModal()">cancel</button>
        </div>
    </div>
    <script>
let background_img=""
document.getElementById('background').addEventListener('change',backgroundimg)
function backgroundimg(event){
  const fileInput = event.target;
const files = fileInput.files;
if (files.length > 0) {
  const newBlockIndex = TILES.length; // Get the next iteration
  const collisionValue = 0;
  const image = event.target.files[0];
  // Create file reader object
  const reader = new FileReader()
  // Convert image to data URL
  reader.readAsDataURL(image)
  reader.addEventListener('load', () => {
    background_img=reader.result
  })
  updateViewport();
}
}

        function showModal() {
            const modal = document.getElementById('modal-container');
            modal.style.display = 'flex';
        }
        function hideModal() {
            const modal = document.getElementById('modal-container');
            modal.style.display = 'none';
        }
function addtoproject(){
            const klasa = document.getElementById('klasaInput').value;
            const style = document.getElementById('styleInput').value;
            const tekstPrzycisku = document.getElementById('tekstInput').value;
const idPrzycisku = document.getElementById('IdInput').value;
            const nowyPrzycisk = document.createElement('div');
            if (klasa) {
                nowyPrzycisk.className = klasa;
            }
nowyPrzycisk.id = idPrzycisku;
            if (style) {
                nowyPrzycisk.style.cssText = style;
            }
            nowyPrzycisk.textContent = tekstPrzycisku || '';
            nowyPrzycisk.className += 'PROJECT przesuwalny added';
            dodajObslugePrzesuwania(nowyPrzycisk);
            dodajObslugeUsuwanie(nowyPrzycisk);
            document.querySelector('#project2').appendChild(nowyPrzycisk);
            hideModal();
config.guiHTML2=document.querySelector('#project2').innerHTML
alert(config.guiHTML2)
if (document.getElementById('Left')) {
  document.getElementById('Left').addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    leftButtonDown = 1;
  });
  document.getElementById('Left').addEventListener('touchend', function() {
    leftButtonDown = 0;
  });
}
if (document.getElementById('Right')) {
  document.getElementById('Right').addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    rightButtonDown = 1;
  });
  document.getElementById('Right').addEventListener('touchend', function() {
    rightButtonDown = 0;
  });
}
if (document.getElementById('Up')) {
  document.getElementById('Up').addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    upButtonDown = 1;
  });
  document.getElementById('Up').addEventListener('touchend', function() {
    upButtonDown = 0;
  });
}
if (document.getElementById('Down')) {
  document.getElementById('Down').addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    downButtonDown = 1;
  });
  document.getElementById('Down').addEventListener('touchend', function() {
    downButtonDown = 0;
  });
}
var jumpElement = document.getElementById('Jump');
if (jumpElement) {
  jumpElement.addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    jump2(event);
  });
}
var atackelement = document.getElementById('Attack');
if (atackelement) {
  atackelement.addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    attack2();
  });
}
}
function addtoproject2() {
  const klasa = document.getElementById('klasaInput').value;
  const style = document.getElementById('styleInput').value;
  const tekstPrzycisku = document.getElementById('tekstInput').value;
  const idPrzycisku = document.getElementById('IdInput').value;
  const nowyPrzycisk = document.createElement('div');
  if (klasa) {
    nowyPrzycisk.className = klasa;
  }
  nowyPrzycisk.id = idPrzycisku;
  if (style) {
    nowyPrzycisk.style.cssText = style;
  }
nowyPrzycisk.style.backgroundImage=`url('${background_img}')`
  nowyPrzycisk.textContent = tekstPrzycisku || '';
  nowyPrzycisk.className += 'PROJECT przesuwalny added';
  dodajObslugePrzesuwania(nowyPrzycisk);
  dodajObslugeUsuwanie(nowyPrzycisk);
  document.querySelector('#project2').appendChild(nowyPrzycisk);
  hideModal();
  config.guiHTML2 = document.querySelector('#project2').innerHTML
  alert(config.guiHTML2)
  if (document.getElementById('Left')) {
    document.getElementById('Left').addEventListener('touchstart', function(event) {
      event.preventDefault(); // Prevent default behavior
      leftButtonDown = 1;
    });
    document.getElementById('Left').addEventListener('touchend', function() {
      leftButtonDown = 0;
    });
  }
  if (document.getElementById('Right')) {
    document.getElementById('Right').addEventListener('touchstart', function(event) {
      event.preventDefault(); // Prevent default behavior
      rightButtonDown = 1;
    });
    document.getElementById('Right').addEventListener('touchend', function() {
      rightButtonDown = 0;
    });
  }
  if (document.getElementById('Up')) {
    document.getElementById('Up').addEventListener('touchstart', function(event) {
      event.preventDefault(); // Prevent default behavior
      upButtonDown = 1;
    });
    document.getElementById('Up').addEventListener('touchend', function() {
      upButtonDown = 0;
    });
  }
  if (document.getElementById('Down')) {
    document.getElementById('Down').addEventListener('touchstart', function(event) {
      event.preventDefault(); // Prevent default behavior
      downButtonDown = 1;
    });
    document.getElementById('Down').addEventListener('touchend', function() {
      downButtonDown = 0;
    });
  }
  var jumpElement = document.getElementById('Jump');
  if (jumpElement) {
    jumpElement.addEventListener('touchstart', function(event) {
      event.preventDefault(); // Prevent default behavior
      jump2(event);
    });
  }
  var atackelement = document.getElementById('Attack');
  if (atackelement) {
    atackelement.addEventListener('touchstart', function(event) {
      event.preventDefault(); // Prevent default behavior
      attack2();
    });
  }
}
function dodajPrzyciskZModalu2() {
  const klasa = document.getElementById('klasaInput').value;
  const style = document.getElementById('styleInput').value;
  const tekstPrzycisku = document.getElementById('tekstInput').value;
  const idPrzycisku = document.getElementById('IdInput').value;
  const nowyPrzycisk = document.createElement('div');
  if (klasa) {
    nowyPrzycisk.className = klasa;
  }
  nowyPrzycisk.id = idPrzycisku;
  if (style) {
    nowyPrzycisk.style.cssText = style;
  }
nowyPrzycisk.style.backgroundImage=`url('${background_img}')`
  nowyPrzycisk.textContent = tekstPrzycisku || '';
  nowyPrzycisk.className += ' przesuwalny added';
  dodajObslugePrzesuwania(nowyPrzycisk);
  dodajObslugeUsuwanie(nowyPrzycisk);
  document.querySelector('gui').appendChild(nowyPrzycisk);
  hideModal();
  if (document.getElementById('Left')) {
    document.getElementById('Left').addEventListener('touchstart', function(event) {
      event.preventDefault(); // Prevent default behavior
      leftButtonDown = 1;
    });
    document.getElementById('Left').addEventListener('touchend', function() {
      leftButtonDown = 0;
    });
  }
  if (document.getElementById('Right')) {
    document.getElementById('Right').addEventListener('touchstart', function(event) {
      event.preventDefault(); // Prevent default behavior
      rightButtonDown = 1;
    });
    document.getElementById('Right').addEventListener('touchend', function() {
      rightButtonDown = 0;
    });
  }
  if (document.getElementById('Up')) {
    document.getElementById('Up').addEventListener('touchstart', function(event) {
      event.preventDefault(); // Prevent default behavior
      upButtonDown = 1;
    });
    document.getElementById('Up').addEventListener('touchend', function() {
      upButtonDown = 0;
    });
  }
  if (document.getElementById('Down')) {
    document.getElementById('Down').addEventListener('touchstart', function(event) {
      event.preventDefault(); // Prevent default behavior
      downButtonDown = 1;
    });
    document.getElementById('Down').addEventListener('touchend', function() {
      downButtonDown = 0;
    });
  }
  var jumpElement = document.getElementById('Jump');
  if (jumpElement) {
    jumpElement.addEventListener('touchstart', function(event) {
      event.preventDefault(); // Prevent default behavior
      jump2(event);
    });
  }
  var atackelement = document.getElementById('Attack');
  if (atackelement) {
    atackelement.addEventListener('touchstart', function(event) {
      event.preventDefault(); // Prevent default behavior
      attack2();
    });
  }
}
        function dodajPrzyciskZModalu() {
            const klasa = document.getElementById('klasaInput').value;
            const style = document.getElementById('styleInput').value;
            const tekstPrzycisku = document.getElementById('tekstInput').value;
const idPrzycisku = document.getElementById('IdInput').value;
            const nowyPrzycisk = document.createElement('div');
            if (klasa) {
                nowyPrzycisk.className = klasa;
            }
nowyPrzycisk.id = idPrzycisku;
            if (style) {
                nowyPrzycisk.style.cssText = style;
            }
            nowyPrzycisk.textContent = tekstPrzycisku || '';
            nowyPrzycisk.className += ' przesuwalny added';
            dodajObslugePrzesuwania(nowyPrzycisk);
            dodajObslugeUsuwanie(nowyPrzycisk);
            document.querySelector('gui').appendChild(nowyPrzycisk);
            hideModal();
if (document.getElementById('Left')) {
  document.getElementById('Left').addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    leftButtonDown = 1;
  });
  document.getElementById('Left').addEventListener('touchend', function() {
    leftButtonDown = 0;
  });
}
if (document.getElementById('Right')) {
  document.getElementById('Right').addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    rightButtonDown = 1;
  });
  document.getElementById('Right').addEventListener('touchend', function() {
    rightButtonDown = 0;
  });
}
if (document.getElementById('Up')) {
  document.getElementById('Up').addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    upButtonDown = 1;
  });
  document.getElementById('Up').addEventListener('touchend', function() {
    upButtonDown = 0;
  });
}
if (document.getElementById('Down')) {
  document.getElementById('Down').addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    downButtonDown = 1;
  });
  document.getElementById('Down').addEventListener('touchend', function() {
    downButtonDown = 0;
  });
}
var jumpElement = document.getElementById('Jump');
if (jumpElement) {
  jumpElement.addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    jump2(event);
  });
}
var atackelement = document.getElementById('Attack');
if (atackelement) {
  atackelement.addEventListener('touchstart', function(event) {
    event.preventDefault(); // Prevent default behavior
    attack2();
  });
}
        }
        function dodajObslugePrzesuwania(element) {
            let startX, startY, offsetX, offsetY;
            function rozpocznijPrzesuniecie(e) {
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    startX = touch.clientX;
                    startY = touch.clientY;
                    offsetX = element.getBoundingClientRect().left;
                    offsetY = element.getBoundingClientRect().top;
                    document.addEventListener('touchmove', przesun);
                    document.addEventListener('touchend', zakonczPrzesuniecie);
                }
            }
            function przesun(e) {
    if (e.touches.length === 1) {
        const touch = e.touches[0];
        // Pobierz szerokość i wysokość widoku (viewport) w vw i vh
        const viewportWidth = window.innerWidth * 0.01;
        const viewportHeight = window.innerHeight * 0.01;
        // Oblicz nowe wartości left i top w vw i vh
        const leftVw = (touch.clientX - startX + offsetX) / viewportWidth + 'vw';
        const topVh = (touch.clientY - startY + offsetY) / viewportHeight + 'vh';
        // Ustaw nowe wartości dla left i top
        element.style.left = leftVw;
        element.style.top = topVh;
    }
}
            function zakonczPrzesuniecie() {
                document.removeEventListener('touchmove', przesun);
                document.removeEventListener('touchend', zakonczPrzesuniecie);
            }
            element.addEventListener('touchstart', rozpocznijPrzesuniecie);
        }
        function dodajObslugeUsuwanie(element) {
            element.addEventListener('click',
            function(){usunelgui(element)}
            );
        }
        function usunelgui(element){
          if (confirm('Czy na pewno chcesz usunąć ten element?')) {
            element.remove();
          }
        }
function ukonczoneGUI() {
  config.guiHTML=document.querySelector('gui').innerHTML
  setTimeout(function(){
    const elementyDoUsuniecia = document.querySelectorAll('.added');
    elementyDoUsuniecia.forEach(function(element) {
      element.remove();
    });
    document.querySelector('gui').innerHTML=config.guiHTML
    testa()
  },100)
}
        function usunElementy() {
            const elementyDoUsuniecia = document.querySelectorAll('.added');
            config.guiHTML2=''
            elementyDoUsuniecia.forEach(function (element) {
                element.remove();
            });
        }
    </script>
</body>
</html>
<style>
      .particle {
      position: fixed ;
      border-radius: 20%;
      opacity: 0.2;
      z-index: 99999999;
      /*filter: url("#bm")*/
    }
    .custom-particle {
      position: absolute;
      background-color: black ;
      border-radius: 100%;
      opacity :0.0;
      z-index: 999;
    }
</style>
<script>
const particleContainer = [];
    class Particle {
      constructor(x, y, lifetime, color, radius, rotationspeed, emitCount, emitLifetime, xoffset, yoffset, radiansOffset, particleGoto, endXOffset, endYOffset, particleMovementSpeed, particleClass,xmat) {
        this.x = x;
        this.y = y;
        this.lifetime = lifetime;
        this.xmat=xmat
        this.color = color;
        this.radius = radius;
        this.rotationspeed = rotationspeed;
        this.rotation = 0;
        this.startTime = Date.now();
        this.emitCount = emitCount;
        this.emitLifetime = emitLifetime;
        this.xoffset = xoffset;
        this.yoffset = yoffset;
        this.radiansOffset = radiansOffset;
        this.particleGoto = particleGoto;
        this.endXOffset = endXOffset;
        this.endYOffset = endYOffset;
        this.particleMovementSpeed = particleMovementSpeed;
        this.vx = Math.random() * 2 - 1; // Random velocity in the x direction between -1 and 1
        this.vy = Math.random() * 2 - 1; // Random velocity in the y direction between -1 and 1
        this.element = document.createElement('div');
        this.element.className = particleClass || 'particle'; // Use custom class if provided, otherwise use 'particle'
        this.updateStyle();
        document.querySelector('#Econtent').appendChild(this.element);
      }
      updateStyle() {
        if(this.xmat==false){
        this.element.style.left = this.x  + 'px';
        this.element.style.top = this.y  + 'px';
        }else if (this.xmat == true) {
          this.element.style.left = this.x + 'vw';
          this.element.style.top = this.y + 'vh';
        }
        this.element.style.width = this.radius * 2 + 'px';
        this.element.style.height = this.radius * 2 + 'px';
        this.element.style.background = this.color;
        this.element.style.transform = `rotate(${this.rotation}deg)`;
        this.element.style.opacity = this.lifetime / this.emitLifetime;
      }
      update() {
        const currentTime = Date.now();
        const deltaTime = (currentTime - this.startTime) / 1000;
        this.rotation += this.rotationspeed * deltaTime;
        if (deltaTime >= this.lifetime) {
          this.element.remove();
          const index = particleContainer.indexOf(this);
          particleContainer.splice(index, 1);
        }
        if (this.particleGoto) {
          this.x += this.vx * this.particleMovementSpeed; // Update particle's x position based on its velocity
          this.y += this.vy * this.particleMovementSpeed; // Update particle's y position based on its velocity
        } else {
          const angle = Math.atan2(this.endYOffset, this.endXOffset);
          this.x += Math.cos(angle) * this.particleMovementSpeed; // Move towards the specified x direction
          this.y += Math.sin(angle) * this.particleMovementSpeed; // Move towards the specified y direction
        }
        if (this.emitCount > 0 && deltaTime >= this.emitLifetime) {
          this.emitCount--;
          const radians = this.radiansOffset + (Math.random() - 0.5) * Math.PI;
          let x = this.x + this.xoffset;
          let y = this.y + this.yoffset;
          if (this.particleGoto) {
            x = this.x - this.xoffset;
            y = this.y - this.yoffset;
          }
          x += this.endXOffset;
          y += this.endYOffset;
          createParticle(x, y, this.lifetime, this.color, this.radius, this.rotationspeed, 0, this.emitLifetime, this.xoffset, this.yoffset, radians, this.particleGoto, this.endXOffset, this.endYOffset, this.particleMovementSpeed, this.particleClass);
        }
      }
    }
    function createParticle(x, y, lifetime, color, radius, rotationspeed, emitCount = 0, emitLifetime = 0, xoffset = 0, yoffset = 0, radiansOffset = 0, particleGoto = false, endXOffset = 0, endYOffset = 0, particleMovementSpeed = 1, particleClass, xmat = false ) {
      const particle = new Particle(x, y, lifetime, color, radius, rotationspeed, emitCount, emitLifetime, xoffset, yoffset, radiansOffset, particleGoto, endXOffset, endYOffset, particleMovementSpeed, particleClass, xmat);
      particleContainer.push(particle);
    }
    function emitParticles(x, y, particleCount, emitLifetime, color, radius, rotationspeed, xoffset, yoffset, radiansOffset, particleGoto, endXOffset, endYOffset, particleMovementSpeed, particleClass,xmat) {
      for (let i = 0; i < particleCount; i++) {
        const xmath=xmat 
        const randomX = x + (Math.random() - 0.5) * xoffset;
        const randomY = y + (Math.random() - 0.5) * yoffset;
        const randomLifetime = emitLifetime + Math.random() * 0.5;
        const randomRotSpeed = rotationspeed + (Math.random() - 0.5) * 0;
        const radians = radiansOffset + (Math.random() - 0.5) * Math.PI;
        createParticle(randomX, randomY, randomLifetime, color, radius, randomRotSpeed, 0, emitLifetime, xoffset, yoffset, radians, particleGoto, endXOffset, endYOffset, particleMovementSpeed, particleClass,xmath);
      }
    }
    function updateParticles() {
      for (let i = 0; i < particleContainer.length; i++) {
        const particle = particleContainer[i];
        particle.update();
        particle.updateStyle();
      }
      requestAnimationFrame(updateParticles);
    }
    function initialize() {
      // Example usage:
      setInterval(() => {
//emitParticles(5*tileSize2, 3*tileSize2, 1, 4.5, "rgba(255, 255, 255, 0.2)", 100, 2.5, 50, 50, 0, true, 1000, 100, 0.8, 'custom-particle',false);
emitParticles()
      }, 1000);
      // Additional example particles:
      updateParticles();
    }
    //initialize();
  </script>
  <style>
    #editor {
      position:fixed;
      z-index: 999;
      max-width: 400px;
      height: 200px;
      width: 200px;
      top:50%;
      left:50vw;
      transform: translate(-50%,-50%);
      overflow: hidden;
      overflow: scroll;
      background-color: #fff;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }
    input, textarea {
      margin-bottom: 10px;
width: calc(100% - 20px);
padding: 10px;
border: 1px solid #ccc;
border-radius: 5px;
font-size: 14px;
    }
    .button-container {
      display: flex;
      justify-content: space-between;
    }
    button {
    }
    button:hover {
      background-color: #45a049;
    }
  </style>
</head>
<body>
  <div id="editor"  class="d notaproject hide"></div>
<script>
    var example = config;
    const editorContainer = document.getElementById('editor');
    function edit() {
        editorContainer.innerHTML = '';
        for (const key in example) {
            const name = document.createElement('div');
            name.style.color = "black";
            name.innerText = key;
            editorContainer.appendChild(name);
            if (typeof example[key] === 'number') {
                const inputContainer = document.createElement('div');
                inputContainer.className = 'button-container';
                const addButton = document.createElement('button');
                addButton.innerText = '+';
                addButton.addEventListener('click', () => {
                    updateConfig(key, '+');
                });
                inputContainer.appendChild(addButton);
                const inputElement = document.createElement('input');
                inputElement.type = 'number';
                inputElement.value = example[key];
                inputElement.addEventListener('change', (event) => {
                    updateConfig(key, parseFloat(event.target.value));
                });
                inputContainer.appendChild(inputElement);
                const minusButton = document.createElement('button');
                minusButton.innerText = '-';
                minusButton.addEventListener('click', () => {
                    updateConfig(key, '-');
                });
                inputContainer.appendChild(minusButton);
                editorContainer.appendChild(inputContainer);
            } else if (typeof example[key] === 'boolean') {
                const checkboxElement = document.createElement('input');
                checkboxElement.type = 'checkbox';
                checkboxElement.checked = example[key];
                checkboxElement.addEventListener('change', (event) => {
                    updateConfig(key, event.target.checked);
                });
                editorContainer.appendChild(checkboxElement);
            } else if (Array.isArray(example[key]) || typeof example[key] === 'string') {
                const textareaElement = document.createElement('textarea');
                textareaElement.value = example[key];
                textareaElement.addEventListener('change', (event) => {
                    updateConfig(key, event.target.value);
                });
                editorContainer.appendChild(textareaElement);
            }else{
const textareaElement = document.createElement('textarea');
textareaElement.disabled='true'
textareaElement.value = JSON.stringify(example[key])
editorContainer.appendChild(textareaElement);
            }
        }
    }
    function updateConfig(key, value) {
        if (typeof value === 'string' || Array.isArray(value)) {
            config[key] = value;
        } else if (value === '+') {
            config[key]++;
        } else if (value === '-') {
            config[key]--;
        } else if (!isNaN(value)) {
            config[key] = value;
        } else if (typeof value === 'boolean') {
            config[key] = value;
        }
    }
    setTimeout(edit, 5000);
</script>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Customowy Play/Pause</title>
    <style>
        /* Styl dla customowego diva */
        .playPauseButton {
            position: absolute;
            top: 10px;
            right: 0px;
            z-index: 0;
            cursor: pointer;
            background-color: #3498DB;
            opacity: 0.4;
            color: #fff;
            padding: 10px;
            border-radius: 5px;
        }
        /* Dodaj styl dla ikony play/pause */
        #playPauseIcon::before {
            content: "⏯️"; /* Unicode dla ikony trójkąta (play) */
        }
        /* Dodaj styl dla stanu pauzy */
        #playPauseButton.paused #playPauseIcon::before {
            content: "▶️"; /* Unicode dla ikony pauzy */
        }
    </style>
</head>
<body>
<!-- Dodaj customowy div -->
<script>
function restart(){
  config=config
 deletedtiles=[]
  const playerskin69 = config.playerskin1
//alert(playerskin69)
document.querySelector('.player').style.background = `url(${playerskin69})`
playerskin = playerskin69
updateViewport();
setTimeout(function() {
  if (config.DarknessEffect == 1) {
    let vp = document.getElementById("viewport")
    let el = document.createElement('div')
    el.style = `width:${vp.style.width};height:${vp.style.height};`
    el.className = 'dark effects added'
    document.querySelector('#project').appendChild(el)
  } else {
    let y = document.querySelectorAll('.effects')
    for (var i = 0; i < y.length; i++) {
      if (y[i].classList == 'dark') {
        y[i].remove()
      }
    }
  }
}, 1000)
bgimg=config.bg
deletedtiles = []
document.getElementById('edytor').textContent = config.code
stop = 1
code = config.code;
classicspeed = config.norspeed;
playerY = config.spawnY;
playerX = config.spawnX;
setPlayer(config.spawnX, config.spawnY)
speed = config.speed;
playerskin = config.playerskin1;
TILES = config.blocks;
tileMap = config.savedTileMap;
gravity = config.gravity;
content.style.backgroundSize = (config.bgsize) + "px"
code = config.code
if (audioInstance) {
  // Jeżeli istnieje istniejący odtwarzacz audio, zatrzymaj go
  audioInstance.pause();
  audioInstance.currentTime = 0;
  audioInstance = null;
}
if (config.music !== '') {
  const base64Wav = config.music;
  // Utwórz nowy odtwarzacz audio
  audioInstance = new Audio();
  audioInstance.src = base64Wav;
  audioInstance.setAttribute('preload', 'auto');
  // Dodaj odtwarzacz do dokumentu
  document.body.appendChild(audioInstance);
  // Odtwórz plik audio WAV
  audioInstance.play();
  audioInstance.loop = true;
  toonce = 0;
}
if (config.customcamera == 1) {
  viewport.scrollTo(config.cameraX * tileSize2 - viewportWidth / 2, (config.cameraY * tileSize2) - viewportHeight / viewportHeight * viewportHeight / 2)
}
const contentElement = document.getElementById("content");
document.querySelector('gui').innerHTML = config.guiHTML
ukonczoneGUI()
//contentElement.style.backgroundImage = `url('${config.bg}')`;
//alert(bgimg)
contentElement.style.backgroundImage = `url('${bgimg}')`;
document.getElementById('Scontent').innerHTML = ''
document.getElementById('Econtent').innerHTML = ''
tileConfig = config.entities
//document.getElementById('entitiesconfig').innerText = JSON.stringify(config.entities);
moveTilesRandomly()
setTimeout(function() {
  curline = 0
  currentLine = 0
  generateAllTiles()
  candocmd = 1
  curline = 0
  currentLine = 0;
  candothath = 0
  defy = 0
  jmptimes = 0
  stop = 0
  RESET()
                      if (config.stickybg1 == 0) {
                      document.getElementById('content').style.backgroundImage = `url('${config.bg}')`
                      document.getElementById('content2').style.backgroundImage = ``
                    } else {
                      document.getElementById('content2').style.backgroundImage = `url('${config.bg}')`
                      document.getElementById('content').style.backgroundImage = ``
                    }
}, 3000)
//alert(content.style.backgroundSize)
tileSize = config.tilesize; // Rozmiar pojedynczego kafelk
cfigZ = config.zoomoff;
vp = document.getElementById("viewport");
/*
vp.style.zoom = cfigZ * config.zoomadd;
document.querySelector('#content2').style.width = vp.style.width
document.querySelector('#content2').style.height = vp.style.height
document.querySelector('#content2').style.zoom = vp.style.zoom*/
}
    let agnstgui=null
    let gravity2=0
    let sidescroll2=null
    var backplayerY=0
    var backplayerX=0
    let backskin=null
    gravity2 = config.gravity
    function togglePlayPause() {
        const playPauseButton = document.getElementById('playPauseButton');
        // Zmień stan zmiennej isgamepaused
        isgamepaused = 1 - isgamepaused;
//alert(isgamepaused)
        // Dodaj lub usuń klasę "paused" w zależności od stanu isgamepaused
        playPauseButton.classList.toggle('paused', isgamepaused === 1);
        if(isgamepaused==0){
          }
if(isgamepaused==0){
  stop=0
  document.querySelector('.player').style.background = `url("${backskin}")`
  config.gravity = gravity2
 gravity = gravity2
  config.sidescroll = sidescroll2
  document.querySelector('gui').innerHTML = agnstgui
/*  playerY=backplayerY
  playerX=backplayerX*/
  updateViewport()
  ukonczoneGUI()
  setTimeout(function() {
    g = 1
    alert2("machine communication please stand by")
    const outputDiv = document.getElementById("codeContainer");
    outputDiv.innerHTML = ""
    document.querySelector('.vars').innerHTML = ""
    setTimeout(function() {
      g = 0
      localout = []
      Vables = {};
      nospeed2lines = false;
      candocmd = 1
      curline = 0
      currentLine = 0;
      candothath = 0
      defy = 0
      jmptimes = 0
      V = []
      interpretCode(config.code,0)
    }, 1000)
  }, 1500)
}else {
          backplayerX=playerX
          backplayerY=playerY
          backskin = config.playerskin1
          sidescroll2= config.sidescroll
          document.querySelector('.player').style.background = `url('/debug.png')`
          agnstgui=document.querySelector('gui').innerHTML
          gravity=0
          gravity=0
          gravity=0
          gravity=0
          gravity=0
          gravity=0
          gravity=0
          document.querySelector('gui').innerHTML = `  <div class="btns">
                <div class="null added"></div>
                <div class="btn added" id="Up"></div>
                <div class="null added"></div>
                <div class="btn added" id="Left"></div>
                <div class="null added"></div>
                <div class="btn added" id="Right"></div>
                <div class="null added"></div>
                <div class="btn added" id="Down"></div>
                <div class="null added"></div>
              </div>
           	   	  <div class="jumpbtn added" id="Attack" style="transform: translate(0%,-100%)" onclick="attack2()"></div>
          `
          gravity=0
          config.gravity=0
          setTimeout(function (){
            gravity=0
            config.gravity=0
          },500)
          config.sidescroll=1
          ukonczoneGUI()
          gravity=0
          stop=1
        }
    }
</script>
</body>
</html>
<style>
    @keyframes glitch-effect {
    0% { -webkit-transform: translate(0, 0); }
    5% { -webkit-transform: translate(2px, -2px); }
    10% { -webkit-transform: translate(-2px, 2px); }
    15% { -webkit-transform: translate(0, -2px); }
    20% { -webkit-transform: translate(0, 2px); }
    25% { -webkit-transform: translate(2px, 0); }
    30% { -webkit-transform: translate(-2px, -2px); }
    35% { -webkit-transform: translate(2px, 2px); }
    40% { -webkit-transform: translate(-2px, 0); }
    45% { -webkit-transform: translate(0, 0); }
    50% { -webkit-transform: translate(-2px, 2px); }
    55% { -webkit-transform: translate(2px, 2px); }
    60% { -webkit-transform: translate(-2px, 0); }
    75% { -webkit-transform: translate(0, 0); }
    80% { -webkit-transform: translate(-2px, 2px); }
    85% { -webkit-transform: translate(2px, 2px); }
    90% { -webkit-transform: translate(-2px, 0); }
    95% { -webkit-transform: translate(0, 0); }
    100% { -webkit-transform: translate(-2px, 2px); }
  }
</style>
<svg width="0" height="0">
  <filter id="ca">
    <feColorMatrix type="matrix" 
      result="red_"             
      values="4 0 0 0 0
              0 0 0 0 0 
              0 0 0 0 0 
              0 0 0 1 0"/>
    <feOffset in="red_" dx="0.8" dy="0" result="red"/>
    <feColorMatrix type="matrix" 
      in="SourceGraphic"             
      result="blue_"             
      values="0 0 0 0 0
              0 3 0 0 0 
              0 0 10 0 0 
              0 0 0 1 0"/>
    <feOffset in="blue_" dx="-0.8" dy="0" result="blue"/>    
    <feBlend mode="screen" in="red" in2="blue"/>
  </filter>
</svg>
<svg width="0" height="0">
  <filter id="be">
    <feGaussianBlur stdDeviation="200" result="blur"/>
    <feComposite in="SourceGraphic" in2="blur" operator="out" result="bloom"/>
    <feBlend in="SourceGraphic" in2="bloom" mode="screen"/>
  </filter>
</svg>
<script>
if(config.chrom==true){
  document.querySelector('#content').style.animation="glitch-effect 2s infinite"
  document.querySelector(':root').style.filter='url("#ca")'
}
if (!('airjump' in config)) {
  // Jeśli klucz nie istnieje, dodaj go z domyślną wartością
  config['airjump'] = 0;
} else {
  //  deletedtiles=config.deletedtiles
  //  alert(deletedtiles)
}
</script>
<style>
  * {
    outline: none;
}
</style>
<script>
  function togglemode1(){
    var elementsToHide = document.getElementsByClassName('d');
    Array.from(elementsToHide).forEach(element => {
      element.classList.toggle('hide')
    });
  }/*
  setTimeout(function(){
    var elementsToHide = document.getElementsByClassName('d');
    Array.from(elementsToHide).forEach(element => {
      element.classList.toggle('hide')
    });
  },4000)
*/
</script>
    <div id="blackScreen" >
      <pre id="helloWorldText" style="white-space: pre-wrap"></pre>
    </div>
    <script>
      const helloWorldText = document.getElementById('helloWorldText');
      let currentIndex = 0;
      setTimeout(() => {
document.querySelector('html').style.filter="brightness(100%)"
        const blackScreen = document.getElementById('blackScreen');
        fadeInNextText();
        function fadeInNextText() {
          helloWorldText.style.opacity = 0;
          setTimeout(() => {
            if (currentIndex < textsArray.length) {
              helloWorldText.innerHTML = textsArray[currentIndex];
              helloWorldText.style.opacity = 1;
              setTimeout(() => {
                fadeInNextText();
              }, 3500);
              currentIndex++;
            } else {
              blackScreen.style.opacity = 0;
              setTimeout(() => {
                blackScreen.style.display = 'none';
              }, 3000);
            }
          }, 400);
        }
      }, 1000);
      if (!('stickybg1' in config)) {
  // Jeśli klucz nie istnieje, dodaj go z domyślną wartością
  config['stickybg1'] = 0;
} else {
}
setTimeout(function(){
if (config.stickybg1 == 0) {
  let content = document.getElementById('content');
  let content2 = document.getElementById('content2');
  if (content2.style.backgroundImage) {
    content.style.backgroundImage = getComputedStyle(content2).backgroundImage;
    setTimeout(function() {
      content2.style.backgroundImage = ''; // Usuwa tło po 3 sekundach
    }, 1000);
  }
} else {
  let content = document.getElementById('content');
  let content2 = document.getElementById('content2');
  content2.style.backgroundImage = getComputedStyle(content).backgroundImage;
  content.style.backgroundImage = '';
}
gravity=config.gravity
},1200)
//alert(config.gravity)
setTimeout(function (){
playerY = config.px;
playerX = config.px;
if(gmgravity==1){
  config.gravity=1
  gravity=1
}
setPlayer(config.spawnX,config.spawnY+0.9)
config.spawnY=config.spawnY+0.9
},4000)
    </script>
<style>
  #Start{
    border-radius: 0%;
  }
  *{
    
  }
</style>





<style>
  * {
    margin: 0;
  }

  Maintenance button {
    background: #D5D5D5;

    border: 1.5px inset #7C7C7C2E;
  }

  Maintenance {
    border: 2px inset #B5B5B5D6;
    display: flex;
    justify-content: center;
    align-items: center;
    top:0px;
    height: 100vh;
    position: fixed;
    z-index: 999999999999999999999999999;
    width: 100vw;
    margin: 0;
    margin: 0;
    background: #E2E2E2;
    font-family: Arial, sans-serif;
  }

  #canvasContainer {
    text-align: center;
  }

  #canvas {
    border: 1.7px inset #7C7C7C73;
    display: block;
    margin: 0 auto;
    margin-top: 7px;
    width: 220px;
    height: 220px;
    background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAA1JREFUGFdjePfu3X8ACWIDyvrS0aMAAAAASUVORK5CYII=');#42445A
    image-rendering: pixelated;
    
  }

  #controlsdrw {
    margin-bottom: 20px;
    position: absolute;
    left:20px;
    top: 20px;
  }

  #outputImg {
    margin-top: 20px;
    width: 50px; height: 50px; display:none;
    background: #83838359;
  }
</style>

<Maintenance class="hidden">
  <div id="controlsdrw">
      <button id="startBtn">NEW</button>
  <button onclick="hideee()">HIDE</button>
  </div>

<br>
  <div id="canvasContainer" style="display:none;">
    <canvas id="canvas"></canvas>
    <div style="margin-top: 3px">
      <input type="color" id="colorPicker">
      <input type="range" id="brushSize" min="1" max="100" value="5">
      <button id="eraser">Eraser</button>

      <button id="saveBtn">Save as Base64</button>
    </div>
  </div>
  <img id="outputImg" style="display:none;">
  <script>
  function hideee(){
    document.querySelector('Maintenance').classList.toggle('hidden')
  }
    document.getElementById('startBtn').addEventListener('click', function() {
      let dimensions = (prompt("Enter canvas (width height) Enter width-space-height example:16 16"));
      
      

      let [width, height] = dimensions.split(' ');

      width = parseInt(width);
      height = parseInt(height);



      if (width && height) {
        const canvas = document.getElementById('canvas');
        canvas.width = width;
        canvas.height = height;

        // Disable image smoothing for pixelated effect if resolution is low
        if (width < 50 && height < 50) {
          ctx.imageSmoothingEnabled = false;
        } else {
          ctx.imageSmoothingEnabled = true;
        }

        document.getElementById('canvasContainer').style.display = 'block';
      }
    });
function startDRAWING(){
  let dimensions = (prompt("Enter canvas width height:"));

document.querySelector('Maintenance').classList.toggle('hidden')

let [width, height] = dimensions.split(' ');

width = parseInt(width);
height = parseInt(height);



if (width && height) {
  const canvas = document.getElementById('canvas');
  canvas.width = width;
  canvas.height = height;

  // Disable image smoothing for pixelated effect if resolution is low
  if (width < 50 && height < 50) {
    ctx.imageSmoothingEnabled = false;
  } else {
    ctx.imageSmoothingEnabled = true;
  }

  document.getElementById('canvasContainer').style.display = 'block';
}
}
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { alpha: true });
    const colorPicker = document.getElementById('colorPicker');
    const brushSize4 = document.getElementById('brushSize');
    const eraser = document.getElementById('eraser');
    const saveBtn = document.getElementById('saveBtn');
    const outputImg = document.getElementById('outputImg');

    let painting = false;
    let erasing = false;

    canvas.addEventListener('mousedown', startPosition);
    canvas.addEventListener('mouseup', endPosition);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('touchstart', startPosition);
    canvas.addEventListener('touchend', endPosition);
    canvas.addEventListener('touchmove', draw);

    eraser.addEventListener('click', () => {
      erasing = !erasing;
      if (erasing) {
        eraser.textContent = "Drawing";
      } else {
        eraser.textContent = "Eraser";
      }
    });

    saveBtn.addEventListener('click', () => {
    /*
var img = document.getElementById("your-image");
// create and customize the canvas
var canvas = document.createElement("canvas");
canvas.width = 500;
canvas.height = 200;
document.body.appendChild(canvas);
// get the context
var ctx = canvas.getContext("2d");
// draw the image into the canvas
ctx.drawImage(img, 0, 0);*/
    
    
    var image = ctx.getImageData(0, 0, canvas.width, canvas.height);
    outputImg.src =  canvas.toDataURL();
   // alert(canvas.toDataURL())

outputImg.style.display="block"
fetch(outputImg.src)
  .then(response => response.blob())
  .then(blob => {
    let a = document.createElement("a");
    a.href = window.URL.createObjectURL(blob);
    a.download = "Your sprite.png";
    a.click();
  });

 
});




    function getPos(e) {
      const rect = canvas.getBoundingClientRect();
      if (e.touches) {
        e = e.touches[0];
      }
      return {
        x: (e.clientX - rect.left) * (canvas.width / rect.width),
        y: (e.clientY - rect.top) * (canvas.height / rect.height)
      };
    }

    function startPosition(e) {
      painting = true;
      draw(e);
    }

    function endPosition() {
      painting = false;
      ctx.beginPath();
    }

    function draw(e) {
      e.preventDefault();
      if (!painting) return;

      const pos = getPos(e);

      ctx.lineWidth = brushSize4.value;
      ctx.lineCap = 'square';

      if (erasing) {
        ctx.globalCompositeOperation = 'destination-out';
        ctx.strokeStyle = 'rgba(0,0,0,1)';
      } else {
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = colorPicker.value;
      }

      // For low resolutions, use pixel drawing technique
      if (canvas.width < 300 && canvas.height < 300) {
        if (erasing) {
          ctx.clearRect(Math.floor(pos.x), Math.floor(pos.y), brushSize4.value, brushSize4.value);
        } else {
          ctx.fillStyle = colorPicker.value;
          ctx.fillRect(Math.floor(pos.x), Math.floor(pos.y), brushSize4.value, brushSize4.value);
        }
      } else {
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
      }
    }
  </script>
</Maintenance>
<script>
  function visibilitytoggle(something){
    document.querySelector(something).classList.toggle('hidden')
  }
</script>
<style>
  SoundMaker {
  border: 2px inset #B5B5B5D6;
  display: flex;
  color:#000000;
  flex-direction: column;
  top: 0px;
  height: 100vh;
  position: fixed;
  z-index: 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999;
  width: 100vw;
  margin: 0;
  margin: 0;
  background: #E2E2E2;
  font-family: monospace;
}
SoundMaker textarea{
  user-select: all;
  pointer-events: all;
}
</style>
<SoundMaker class="hidden">
 <button onclick="visibilitytoggle('SoundMaker')">Hide</button>
  


<body>

    <button onclick="playMusic(music)">play audio</button>
    <br>
    <div style="width:calc(100vw - 15px); height:80vh; border: 1px inset gray">
        <div style="margin:5px;width:calc(100% - 12px); height:40%; border: 1px inset gray; overflow: scroll;">
            <textarea style="margin: 5px; width: 100%; height:100vh; border: none; outline: none;" id="musicNotes" ></textarea>
        </div>
        &nbsp;play
        <text style="width: 60px; height:20px; background: #E1E1E1">1,2</text>
        <div style="margin:5px;width:calc(100% - 12px); height:90px; border: 1px inset gray; overflow: scroll;">
            engine : mm3
            <br><br>
            <button onclick="saveMusic()">Save Edited Music</button>
<pre style="white-space: pre-wrap">
  
  
Tutorial

1. Notes for runallnotes 0

[HZ, Delay for next note ms, Sound length ms, volume, easing],
 
2. Notes for runallnotes 0

[HZ, Delay for note from start music ms, Sound length ms, volume, easing],

3. other

easing :
   0-hard
   1-smooth
   2-smooth reverse 
 
</pre>
        </div>
    </div>
    <br>

    <script>
        var music = {
            "run": [2, 1],
            "tempo": 0.8,
            "loop": 1,
            "1": {
                "notes": [
                  
[100, 250, 250, 0.9, 0],
[50, 1000, 250, 0.9, 0],
[200, 1000, 250, 0.8, 0],
[200, 250, 250, 1, 0],
[250, 0, 500, 0.9, 1],
[200, 250, 250, 0.8, 0],
[150, 250, 500, 0.5, 1]
                ],
                "instrument": "sawtooth",
                "nextSection": null,
                "runallnotes": 0
            },
            "2": {
                "notes": [
                    [200, 0, 2000, 1, 2],
                    [300, 0, 2000, 1, 2],
                    [250, 0, 1000, 1, 2],
                    [200, 0, 2000, 1, 1]
                ],
                "instrument": "sine",
                "nextSection": null,
                "runallnotes": 0
            }
        };

        function playTone(audioContext, frequency, duration, volume, customInstrument, volumeEasing) {
            return new Promise(resolve => {
                const oscillator = audioContext.createOscillator();
                let type = 'square';

                switch (customInstrument) {
                    case "sine":
                        type = 'sine';
                        break;
                    case "square":
                        type = 'square';
                        break;
                    case "sawtooth":
                        type = 'sawtooth';
                        break;
                    case "triangle":
                        type = 'triangle';
                        break;
                    default:
                        type = customInstrument;
                        break;
                }

                oscillator.type = type;
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

                const gainNode = audioContext.createGain();

                if (volumeEasing === 0) {
                    gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                } else if (volumeEasing === 1) {
                    gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration / 1000);
                } else if (volumeEasing > 1) {
                    gainNode.gain.setValueAtTime(0.001, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(volume, audioContext.currentTime + duration / (volumeEasing * 1000));
                }

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.start();
                oscillator.stop(audioContext.currentTime + duration / 1000);

                oscillator.onended = resolve;
            });
        }

        async function playSection(audioContext, sectionId) {
            const section = music[sectionId];
            const { notes, instrument, nextSection, runallnotes } = section;
            const tempo = section.tempo || music.tempo;

            if (runallnotes) {
                const promises = notes.map(([hz, timeout, length, volume, volumeEasing]) => {
                    return new Promise(resolve => {
                        setTimeout(() => {
                            playTone(audioContext, hz, length / tempo, volume, instrument, volumeEasing).then(resolve);
                        }, timeout / tempo);
                    });
                });
                await Promise.all(promises);
            } else {
                for (const note of notes) {
                    const [hz, timeout, length, volume, volumeEasing] = note;
                    await playTone(audioContext, hz, length / tempo, volume, instrument, volumeEasing);
                    await new Promise(resolve => setTimeout(resolve, timeout / tempo));
                }
            }

            if (nextSection !== null) {
                await playSection(audioContext, nextSection);
            }
        }

        async function playMusic(name) {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const runSections = name.run;

            const promises = runSections.map(sectionId => playSection(audioContext, sectionId));
            await Promise.all(promises);
        }

        function saveMusic() {
            var musicJson = document.getElementById('musicNotes').value;
            
            music = JSON.parse(musicJson);
            alert(music)
        }

        function loadmusiceditor() {
            document.getElementById('musicNotes').textContent = JSON.stringify(music, (key, value) => {
                if (Array.isArray(value)) {
                    return JSON.stringify(value);
                }
                return value;
            }, 2).replace(/"\[/g, '[').replace(/\]"/g, ']');
        }

        loadmusiceditor();
    </script>
</body>
</html>



</SoundMaker>


<div class='hide containerC'
style="
position: fixed;

z-index:999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999;
top: 0;
left: 0;
width: 100vw;
height: 100vh;
background-color: black;

color: white;
opacity: 1;
transition: opacity 2s ease-in-out;"
  >
  <div style="width: 20px; height:20px; background:red; position:absolute ; top:0; right:0;" onclick="toggleHTMLEDITOR()">
x
  </div>
    <div style="width: 20px; height:20px; background:blue; position:absolute ; top:0; right:20px;" onclick='config.HTML5=document.getElementById("HTMLCODE").value'>
s
  </div>
      <div style="width: 20px; height:20px; background:orange; position:absolute ; top:0; right:40px;" onclick='document.getElementById("HTMLCODE").value==config.HTML5'>
l
    </div>
  <textarea  style="width:100vw; height:100vh;" name="" id="HTMLCODE" cols="30" rows="10"></textarea>
  
</div>


<document id="HTMLADDCODE">
  
</document>
